<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>msiempy.event API documentation</title>
<meta name="description" content="Provide event management." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/foundation.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/msiempy/event.html">
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://avatars0.githubusercontent.com/u/50667087?s=200&v=4">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>msiempy.event</code></h1>
</header>
<section id="section-intro">
<p>Provide event management.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L0-L1693" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Provide event management.   
&#34;&#34;&#34;

import time
import json
import abc
import collections
import logging
import copy
from datetime import datetime, timedelta
log = logging.getLogger(&#39;msiempy&#39;)

__pdoc__={}

from .core import NitroDict, NitroError, FilteredQueryList
from .core.utils import timerange_gettimes, parse_query_result, format_fields_for_query, divide_times, parse_timedelta

__pdoc__[&#39;EventManager.fields&#39;]=&#34;List of query fields&#34;
__pdoc__[&#39;EventManager.limit&#39;]=&#34;Max number of rows per query&#34;

class EventManager(FilteredQueryList):
    &#34;&#34;&#34;
    List-Like object.  
    Interface to query and manage events.  
    Inherits from `msiempy.core.query.FilteredQueryList`.  

    Arguments:  

    - `fields` : list of strings representing all fields you want to apprear in the Events records.
        Get the list of possible fields by calling `msiempy.event.EventManager.get_possible_fields()` method or see `msiempy.event.Event`.
        Some default fields will be present. 
    - `order` : `tuple ((direction, field))`. Direction can be &#39;ASCENDING&#39; or &#39;DESCENDING&#39;.
    - `limit` : max number of rows per query.
    - `filters` : list of filters. A filter can be a `tuple(field, [values])` or it can be a `msiempy.event.FieldFilter` or `msiempy.event.GroupFilter` if you wish to use advanced filtering.
    - `time_range` : Query time range. String representation of a time range. Not need to specify &#39;CUSTOM&#39; if `start_time` and `end_time` are set.  
    - `start_time` : Query start time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  
    - `end_time` : Query end time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  
    &#34;&#34;&#34; 

    #Constants
    #TODO Try grouped queries !
    _TYPE=&#39;EVENT&#39;
    &#34;&#34;&#34;`EVENT`: Flow query or other are not implemented&#34;&#34;&#34;
    _GROUPTYPE=&#39;NO_GROUP&#39;
    &#34;&#34;&#34;`NO_GROUP`: Grouped query is not implemented&#34;&#34;&#34;
    POSSBILE_ROW_ORDER=[
            &#39;ASCENDING&#39;,
            &#39;DESCENDING&#39;
    ]
    &#34;&#34;&#34;`ASCENDING` or `DESCENDING`&#34;&#34;&#34;

    def __init__(self, *args, fields=None, 
        order=None, limit=500, filters=None, 
        __parent__=None, **kwargs):
        #Calling super constructor : time_range set etc...
        super().__init__(*args, **kwargs)

        #Store the query parent 
        self.__parent__=__parent__

        #Declaring attributes
        self._filters=list()
        
        #Setting the default fields Adds the specified fields, make sure there is no duplicates and delete TABLE identifiers
        if fields and len(fields)&gt;0: 
            all_keys=Event.DEFAULTS_EVENT_FIELDS+list(fields)
            uniquekeys=set()
            for k in all_keys:
                if k in Event.SIEM_FIELDS_MAP_INTERNAL_NAME_TO_NICKNAME:
                    uniquekeys.add(Event.SIEM_FIELDS_MAP_INTERNAL_NAME_TO_NICKNAME[k])
                else: uniquekeys.add(k)
            self.fields=list(uniquekeys)
        else: 
            self.fields=Event.DEFAULTS_EVENT_FIELDS
        #log.debug(&#39;{}\nFIELDS : {}&#39;.format(locals(), self.fields))

        #Setting limit according to config or limit argument
        #TODO Try to load queries with a limit of 10k and get result as chucks of 500 with starPost nbRows
        #   and compare efficiency
        self.limit=int(limit)
        
        # Save order
        self.order=order
            
        #TODO : find a solution not to use this
        #callign super().filters=filters #https://bugs.python.org/issue14965
        super(self.__class__, self.__class__).filters.__set__(self, filters)

        #Type cast all items in the list &#34;data&#34; to events type objects
        #Casting all data to Event objects, better way to do it ?
        collections.UserList.__init__(self, [Event(adict=item) for item in self.data if isinstance(item, (dict, NitroDict))])

    @property
    def order(self):
        &#34;&#34;&#34;
        The `order` is a `tuple (direction, field)`.  
        Default value is `(DESCENDING, LastTime)`.  
        &#34;&#34;&#34;
        return((self._order_direction, self._order_field))

    @order.setter
    def order(self, order):
        if order:
            try:
                if order[0] not in self.POSSBILE_ROW_ORDER :
                    raise AttributeError(&#39;Order direction must be in &#39;+str(self.POSSBILE_ROW_ORDER))

                self._order_direction = order[0]
                self._order_field = order[1]
            except IndexError:
                raise ValueError(&#39;Order must be tuple (direction, field).&#39;)
        else:
            self._order_direction = &#39;DESCENDING&#39;
            self._order_field = &#39;LastTime&#39;

    @property
    def filters(self):
        &#34;&#34;&#34;
        Returns SIEM formatted filters for the query structured from `msiempy.event.GroupFilter` and/or `msiempy.event.FieldFilter`
        See `msiempy.core.query.FilteredQueryList.filters`.
        &#34;&#34;&#34;
        return([dict(f) for f in self._filters])

    def add_filter(self, afilter):
        &#34;&#34;&#34;
        Add a filter to the query.  
        Argument must be a `tuple(field, [values])` or `(field, value)` or `msiempy.event.GroupFilter` or `msiempy.event.FieldFilter`.  
        &#34;&#34;&#34;
        if isinstance(afilter, tuple) :
            self._filters.append(FieldFilter(afilter[0], afilter[1]))

        elif isinstance(afilter, (GroupFilter, FieldFilter, dict)) :
            self._filters.append(afilter)

        else :
            raise TypeError(&#34;Sorry, filters must be either a tuple a GroupFilter, a FieldFilter or a dict. Not {}&#34;.format(afilter))

    def clear_filters(self):
        &#34;&#34;&#34;
        Replace all filters by a non filtering rule.  
        Acts like there is not filters.  
        &#34;&#34;&#34; 
        self._filters=[{
            &#34;type&#34;: &#34;EsmFieldFilter&#34;,
            &#34;field&#34;: {&#34;name&#34;: &#39;SrcIP&#39;},
            &#34;operator&#34;: &#39;IN&#39;,
            &#34;values&#34;: [{&#39;type&#39;:&#39;EsmBasicValue&#39;, &#39;value&#39;:&#39;0.0.0.0/0&#39;}]
            }]


    def qry_load_data(self, retry=1, wait_timeout_sec=120):
        &#34;&#34;&#34;
        Helper method to execute the query and load the data :  
            -&gt; Submit the query  
            -&gt; Wait the query to be executed  
            -&gt; Get and parse the events  

        Arguments:

        - `retry` (`int`): number of time the query can be failed and retried.
            Retries only when &#39;ResultUnavailable&#39;,&#39;UnknownList&#39; or &#39;JobEngine_GetQueryResults_QueryNotFound_Unrecoverable&#39; errors.  
        - `wait_timeout_sec` (`int`): wait timeout in seconds

        Returns : `tuple` : (( `msiempy.event.EventManager`, Query completed? `True/False` ))

        Raises `msiempy.core.session.NitroError` if any unhandled errors.  
        Raises `TimeoutError` if wait_timeout_sec counter gets to 0.  
        &#34;&#34;&#34;
        try:
            query_infos=dict()

            #Queries api calls are very different if the time range is custom.
            if self.time_range == &#39;CUSTOM&#39; :
                query_infos=self.nitro.request(
                    &#39;event_query_custom_time&#39;,
                    time_range=self.time_range,
                    start_time=self.start_time,
                    end_time=self.end_time,
                    order_direction=self._order_direction,
                    order_field=self._order_field,
                    fields=format_fields_for_query(self.fields),
                    filters=self.filters,
                    limit=self.limit,
                    offset=0,
                    includeTotal=False
                    )

            else :
                query_infos=self.nitro.request(
                    &#39;event_query&#39;,
                    time_range=self.time_range,
                    order_direction=self._order_direction,
                    order_field=self._order_field,
                    fields=format_fields_for_query(self.fields),
                    filters=self.filters,
                    limit=self.limit,
                    offset=0,
                    includeTotal=False
                    )
            
            log.debug(&#34;Waiting for EsmRunningQuery object : &#34;+str(query_infos))
        
            self._wait_for(query_infos[&#39;resultID&#39;], wait_timeout_sec)
            events_raw=self._get_events(query_infos[&#39;resultID&#39;])

        except (NitroError, TimeoutError) as error :
            # if (retry &gt;0 and ( any(match in str(error) for match in [
            #         &#39;ResultUnavailable&#39;,
            #         &#39;ERROR_JEC_ResponseNotAvailable&#39;,
            #         &#39;UnknownList&#39;,
            #         &#39;JobEngine_GetQueryResults_QueryNotFound_Unrecoverable&#39;]) 
            #     or isinstance(error, TimeoutError)) ):
            if retry &gt; 0:
                log.warning(&#39;Retring qry_load_data() after error: &#39;+str(error))
                time.sleep(1)
                return self.qry_load_data(retry=retry-1)
            else: raise

        return((events_raw,len(events_raw)&lt;self.limit))

    def load_data(self, workers=10, slots=10, delta=None, max_query_depth=0, **kwargs):
        &#34;&#34;&#34;
        Load the data into the list.  
        Split the query in defferents time slots if the query apprears not to be completed.  
        Wraps around `msiempy.event.EventManager.qry_load_data`.    

        Note: Only the first query is loaded asynchronously.

        Arguments:  
    
        - `workers` : numbre of parrallels tasks, should be equal or less than the number of slots.  
        - `slots` : number of time slots the query can be divided. The loading bar is 
            divided according to the number of slots  
        - `delta` : exemple : &#39;6h30m&#39;, the query will be firstly divided in chuncks according to the time delta read
            with dateutil.  
        - `max_query_depth` : maximum number of reccursive divisions the query before to . 
        Meaning, if EventManager query `limit=500`, `slots=5 `and `max_query_depth=3`, then the maximum capacity of 
        the list is `(500*5)*(500*5)*(500*5)` = `15625000000`.  Only works for certain time ranges.  
        - `retry` (`int`): number of time the query can be failed and retried
        - `wait_timeout_sec` (`int`): wait timeout in seconds

        Returns : `msiempy.event.EventManager`
        &#34;&#34;&#34;

        items, completed = self.qry_load_data()

        if not completed :
            #If not completed the query is split and items aren&#39;t actually used

            if max_query_depth &gt; 0 :
                #log.info(&#34;The query data couldn&#39;t be loaded in one request, separating it in sub-queries...&#34;)

                if self.time_range != &#39;CUSTOM&#39;: #can raise a NotImplementedError if unsupported time_range
                    start, end = timerange_gettimes(self.time_range)
                else :
                    start, end = self.start_time, self.end_time

                if self.__parent__ == None and isinstance(delta, str) :
                    #if it&#39;s the first query and delta is speficied, cut the time_range in slots according to the delta
                    times=divide_times(start, end, delta=parse_timedelta(delta))
                    
                else : 
                    times=divide_times(start, end, slots=slots)

                if workers &gt; len(times) :
                    log.warning(&#34;The numbre of slots is smaller than the number of workers, only &#34;+str(len(times))+&#34; asynch workers will be used when you could use up to &#34;+str(workers)+&#34;. Number of slots should be greater than the number of workers for better performance.&#34;)
                
                sub_queries=list()

                for time in times : #reversed(times) :
                    #Divide the query in sub queries
                    sub_query = EventManager(fields=self.fields, 
                        order=self.order, 
                        limit=self.limit,
                        filters=self._filters,
                        time_range=&#39;CUSTOM&#39;,
                        start_time=time[0].isoformat(),
                        end_time=time[1].isoformat(),

                         __parent__=self
                        )
                    
                    sub_queries.append(sub_query)
            
                results = self.perform(EventManager.load_data, sub_queries, 
                    #The sub query is asynch only when it&#39;s the first query (root parent)
                    asynch=self.__parent__==None,
                    progress=self.__parent__==None, 
                    message=&#39;Loading data from &#39;+start+&#39; to &#39;+end+&#39;. In {} slots&#39;.format(len(times)),
                    func_args=dict(slots=slots, max_query_depth=max_query_depth-1),
                    workers=workers)

                #Flatten the list of lists in a list
                items=[item for sublist in results for item in sublist]
                
            else :
                if not self.__root_parent__.not_completed :
                    log.warning(&#34;The query is not complete... Try to divide in more slots or increase the limit&#34;)
                    self.__root_parent__.not_completed=True
        
        events=[Event(adict=item) for item in items]
        self.data=events
        return(self)

    def _wait_for(self, resultID, wait_timeout_sec, sleep_time=0.2):
        &#34;&#34;&#34;
        Internal method called by qry_load_data
        Wait and sleep - for `sleep_time` duration in seconds -
            until the query is completed or retry countdown arrives at zero.    
        
        Return: `True`  

        Raises: 

        - `msiempy.NitroError`: &#39;ResultUnavailable&#39; error some times...
        - `TimeoutError`: Query wait timeout
        &#34;&#34;&#34;

        begin=datetime.now()
        timeout_delta=timedelta(seconds=wait_timeout_sec)

        log.debug(&#34;Waiting for the query to be executed on the SIEM...&#34;)
        
        while datetime.now()-timeout_delta &lt; begin :
            status = self.nitro.request(&#39;query_status&#39;, resultID=resultID)
            if status[&#39;complete&#39;] is True :
                return True
            else :
                time.sleep(sleep_time)
        raise TimeoutError(&#34;Query wait timeout. resultID={}, sleep_time={}, wait_timeout_sec={}&#34;.format(
            resultID, sleep_time, wait_timeout_sec))

    def _get_events(self, resultID, startPos=0, numRows=None):
        &#34;&#34;&#34;
        Internal method that will get the query events, 
            called by qry_load_data
        by default, numRows correspond to limit
        &#34;&#34;&#34;
        
        if not numRows :
            numRows=self.limit
                
        result=self.nitro.request(&#39;query_result&#39;,
            startPos=startPos,
            numRows=numRows,
            resultID=resultID)

        #Calls a utils function to parse the [columns][rows]
        #   to format into list of dict
        #log.debug(&#34;Parsing colums : &#34;+str(result[&#39;columns&#39;]))
        #log.debug(&#34;Parsing rows : &#34;+str(result[&#39;rows&#39;]))
        if len(result[&#39;columns&#39;]) != len(set([column[&#39;name&#39;] for column in result[&#39;columns&#39;]])) :
            log.error(&#34;You requested duplicated fields, the parsed fields/values results will be missmatched !&#34;)
        events=parse_query_result(result[&#39;columns&#39;], result[&#39;rows&#39;])
        #log.debug(&#34;Events parsed : &#34;+str(events))
        return events

    @property
    def __root_parent__(self):
        &#34;&#34;&#34;
        Internal method that return the first query of the query tree
        &#34;&#34;&#34;
        if self.__parent__==None:
            return self
        else :
            return self.__parent__.__root_parent__

    def get_possible_fields(self):
        &#34;&#34;&#34;
        Return the list of possible fields that you can request in a query.  
        The list is loaded from the SIEM.  
        &#34;&#34;&#34;
        return self.nitro.request(&#39;get_possible_fields&#39;, type=self._TYPE, groupType=self._GROUPTYPE)

    def get_possible_filters(self):
        &#34;&#34;&#34;
        Return the list of possible fields that you can use as a filter in a query.  
        The list is loaded from the SIEM.  
        &#34;&#34;&#34;
        return(self.nitro.request(&#39;get_possible_filters&#39;))

class Event(NitroDict):
    &#34;&#34;&#34;
    Dict-Like object.   

    Event interface.
    This object handles events objects created with `msiempy.event.EventManager` (From the `qryGetResults` api call) 
        and events objects created with `msiempy.alarm.AlarmManager` (From `ipsGetAlertData` api call or `notifyGetTriggeredNotificationDetail` depending of the value of `load_data(events_details=True/False)` ) .  

    Common keys for alert data events (When loading from ID or with `AlarmManager.load_data(events_details=False)` :  

    - `ruleName`
    - `srcIp`
    - `destIp`
    - `protocol`
    - `lastTime`
    - `subtype`
    - `destPort`
    - `destMac`
    - `srcMac`
    - `srcPort`
    - `deviceName`
    - `sigId`
    - `normId`
    - `srcUser`
    - `destUser`
    - `normMessage`
    - `normDesc`
    - `host`
    - `domain`
    - `ipsId`

    Common keys for triggered alarms events (When `AlarmManager.load_data(events_details=False)`):  
    - `ruleMessage`  
    - `eventId`  
    - `severity`  
    - `eventCount`  
    - `sourceIp`  
    - `destIp`  
    - `protocol`  
    - `lastTime`  
    - `eventSubType`  

    Common keys for query events (When using `EventManager`):  

    - `Rule.msg`  
    - `Alert.LastTime`  
    - `Alert.IPSIDAlertID`  
    - and any other...  

    You can request more fields by passing a list of fields to the `msiempy.event.EventManager` object. 
    `msiempy.event.Event.REGULAR_EVENT_FIELDS` offer a base list of regular fields that may be useful.
    See msiempy/static JSON files to browse complete list : https://github.com/mfesiem/msiempy/blob/master/static/all_fields.json  
    You can also use this script to dinamically print the available fields and filters : https://github.com/mfesiem/msiempy/blob/master/samples/dump_all_fields.py  

    Arguments:

    - `adict`: Event parameters  
    - `id`: The event `IPSIDAlertID` to instanciate. Will load informations

    **For query events**: We tried our best effort to match SIEM returned fields with initially requested fields.  Prefixes `Alert.`, `Rule.`, etc are optionnal, autocompletion is computed in any case.    
    `__getitem__`, `__contains__`, `__setitem__` and `__delitem__` method have been rewrote in order to offer more straight-forward `dict` usage.
    For exemple, if the SIEM returns results with keys like  `Alert.65613`, `Alert.BIN(7)` or `Alert.SrcIP`: you&#39;ll be able to use `Event` dict with your initial 
    queried keys like `Event[&#39;Web_Doamin&#39;] `, `Event[&#39;UserIDSrc&#39;]` or `Event[&#39;SrcIP&#39;]`. (You can still use internal keys if you want).   

    Exemple:  

        

    &#34;&#34;&#34;
   
    FIELDS_TABLES=[
        &#34;Alert&#34;,
        &#34;Rule&#34;,
        &#34;ADGroup&#34;,
        &#34;Action&#34;,
        &#34;Asset&#34;,
        &#34;AssetGroup&#34;,
        &#34;AssetThreat&#34;,
        &#34;CaseMgt&#34;,
        &#34;CaseOrg&#34;,
        &#34;CaseStatus&#34;,
        &#34;Class&#34;,
        &#34;Connection&#34;,
        &#34;DataEnrichment&#34;,
        &#34;GeoLoc_ASNGeoDst&#34;,
        &#34;GeoLoc_ASNGeoSrc&#34;,
        &#34;IOC&#34;,
        &#34;IPS&#34;,
        &#34;IPSCheck&#34;,
        &#34;NDDeviceInterface_NDDevIFDst&#34;,
        &#34;NDDeviceInterface_NDDevIFSrc&#34;,
        &#34;NDDevice_NDDevIDDst&#34;,
        &#34;NDDevice_NDDevIDSrc&#34;,
        &#34;OS&#34;,
        &#34;Rule_NDSNormSigID&#34;,
        &#34;Tag&#34;,
        &#34;TagAsset&#34;,
        &#34;ThirdPartyType&#34;,
        &#34;Threat&#34;,
        &#34;ThreatVendor&#34;,
        &#34;TriggeredAlarm&#34;,
        &#34;Users&#34;,
        &#34;Vulnerability&#34;,
        &#34;Zone_ZoneDst&#34;,
        &#34;Zone_ZoneSrc&#34;,
        ]
    &#34;&#34;&#34;List of internal fields table : `Rule`,`Alert`,etc.
    &#34;&#34;&#34;

    # Minimal default query fields
    DEFAULTS_EVENT_FIELDS=[&#34;Rule.msg&#34;, &#34;LastTime&#34;, &#34;IPSIDAlertID&#34;]
    &#34;&#34;&#34;Always present when using `msiempy.event.EventManager` querying :  
        `Rule.msg`  
        `Alert.LastTime`  
        `Alert.IPSIDAlertID`
    &#34;&#34;&#34;
    # Regular query fields
    REGULAR_EVENT_FIELDS=[
        &#34;Rule.msg&#34;,
        &#34;Alert.SrcIP&#34;,
        &#34;Alert.DstIP&#34;, 
        &#34;Alert.SrcMac&#34;,
        &#34;Alert.DstMac&#34;,
        &#34;Rule.NormID&#34;,
        &#34;HostID&#34;,
        &#34;UserIDSrc&#34;,
        &#34;ObjectID&#34;,
        &#34;Alert.Severity&#34;,
        &#34;Alert.LastTime&#34;,
        &#34;Alert.DSIDSigID&#34;,
        &#34;Alert.IPSIDAlertID&#34;]
    &#34;&#34;&#34;
    List of regular event fields.  

    `Rule.msg`  
    `Alert.SrcIP`  
    `Alert.DstIP`   
    `Alert.SrcMac`  
    `Alert.DstMac`  
    `Rule.NormID`  
    `HostID`  
    `UserIDSrc`  
    `ObjectID`  
    `Alert.Severity`  
    `Alert.LastTime`  
    `Alert.DSIDSigID`  
    `Alert.IPSIDAlertID` 
    &#34;&#34;&#34;
    
    SIEM_FIELDS_MAP_INTERNAL_NAME_TO_NICKNAME = {
    &#39;Alert.105250817&#39;: &#39;DNS - Response_Code_Name&#39;,
    &#39;Alert.122028033&#39;: &#39;DNS - Query&#39;,
    &#39;Alert.196609&#39;: &#39;Queue_ID&#39;,
    &#39;Alert.21364737&#39;: &#39;DNS - Class&#39;,
    &#39;Alert.21364738&#39;: &#39;Registry - Key&#39;,
    &#39;Alert.21364739&#39;: &#39;Old_Reputation - GTI_File&#39;,
    &#39;Alert.21364740&#39;: &#39;New_Reputation - GTI_File&#39;,
    &#39;Alert.262145&#39;: &#39;Response_Time&#39;,
    &#39;Alert.262146&#39;: &#39;NAT_Details&#39;,
    &#39;Alert.262152&#39;: &#39;PID&#39;,
    &#39;Alert.262153&#39;: &#39;Grid_Master_IP&#39;,
    &#39;Alert.262154&#39;: &#39;Device_IP&#39;,
    &#39;Alert.262155&#39;: &#39;Device_Port&#39;,
    &#39;Alert.262156&#39;: &#39;External_EventID&#39;,
    &#39;Alert.262157&#39;: &#39;Spam_Score&#39;,
    &#39;Alert.262158&#39;: &#39;External_SubEventID&#39;,
    &#39;Alert.262159&#39;: &#39;File_Hash&#39;,
    &#39;Alert.262160&#39;: &#39;Handle_ID&#39;,
    &#39;Alert.262161&#39;: &#39;Instance_GUID&#39;,
    &#39;Alert.262162&#39;: &#39;Agent_GUID&#39;,
    &#39;Alert.262163&#39;: &#39;UUID&#39;,
    &#39;Alert.262164&#39;: &#39;Reputation&#39;,
    &#39;Alert.262165&#39;: &#39;DAT_Version&#39;,
    &#39;Alert.262166&#39;: &#39;Server_ID&#39;,
    &#39;Alert.262167&#39;: &#39;Policy_ID&#39;,
    &#39;Alert.262168&#39;: &#39;Handheld_ID&#39;,
    &#39;Alert.262169&#39;: &#39;Database_GUID&#39;,
    &#39;Alert.262170&#39;: &#39;Analyzer_DAT_Version&#39;,
    &#39;Alert.262171&#39;: &#39;Reputation_Score&#39;,
    &#39;Alert.262172&#39;: &#39;Parent_File_Hash&#39;,
    &#39;Alert.262173&#39;: &#39;Incident_ID&#39;,
    &#39;Alert.262174&#39;: &#39;Victim_IP&#39;,
    &#39;Alert.262175&#39;: &#39;Attacker_IP&#39;,
    &#39;Alert.262176&#39;: &#39;Object_GUID&#39;,
    &#39;Alert.262177&#39;: &#39;Reputation_Server_IP&#39;,
    &#39;Alert.262178&#39;: &#39;DNS_Server_IP&#39;,
    &#39;Alert.262179&#39;: &#39;Device_Confidence&#39;,
    &#39;Alert.38141953&#39;: &#39;DNS - Class_Name&#39;,
    &#39;Alert.38141954&#39;: &#39;Registry - Value&#39;,
    &#39;Alert.38141955&#39;: &#39;Old_Reputation - TIE_File&#39;,
    &#39;Alert.38141956&#39;: &#39;New_Reputation - TIE_File&#39;,
    &#39;Alert.4259841&#39;: &#39;URL&#39;,
    &#39;Alert.4259842&#39;: &#39;Message_Text&#39;,
    &#39;Alert.4259843&#39;: &#39;Filename&#39;,
    &#39;Alert.4259844&#39;: &#39;From&#39;,
    &#39;Alert.4259845&#39;: &#39;To&#39;,
    &#39;Alert.4259846&#39;: &#39;Cc&#39;,
    &#39;Alert.4259847&#39;: &#39;Bcc&#39;,
    &#39;Alert.4259848&#39;: &#39;Subject&#39;,
    &#39;Alert.4259849&#39;: &#39;User_Agent&#39;,
    &#39;Alert.4259850&#39;: &#39;Cookie&#39;,
    &#39;Alert.4259851&#39;: &#39;Referer&#39;,
    &#39;Alert.4259852&#39;: &#39;Destination_Filename&#39;,
    &#39;Alert.4259853&#39;: &#39;Client_Version&#39;,
    &#39;Alert.4259854&#39;: &#39;Job_Name&#39;,
    &#39;Alert.4259855&#39;: &#39;Language&#39;,
    &#39;Alert.4259856&#39;: &#39;SWF_URL&#39;,
    &#39;Alert.4259857&#39;: &#39;TC_URL&#39;,
    &#39;Alert.4259858&#39;: &#39;RTMP_Application&#39;,
    &#39;Alert.4259859&#39;: &#39;Version&#39;,
    &#39;Alert.4259860&#39;: &#39;Local_User_Name&#39;,
    &#39;Alert.4259867&#39;: &#39;DNS_Name&#39;,
    &#39;Alert.4259868&#39;: &#39;SNMP_Item&#39;,
    &#39;Alert.4259869&#39;: &#39;Sensor_UUID&#39;,
    &#39;Alert.4259870&#39;: &#39;Process_Name&#39;,
    &#39;Alert.4259871&#39;: &#39;Source_Context&#39;,
    &#39;Alert.4259872&#39;: &#39;Target_Context&#39;,
    &#39;Alert.4259873&#39;: &#39;Description&#39;,
    &#39;Alert.4259874&#39;: &#39;SQL_Statement&#39;,
    &#39;Alert.4259875&#39;: &#39;From_Address&#39;,
    &#39;Alert.4259876&#39;: &#39;To_Address&#39;,
    &#39;Alert.4259877&#39;: &#39;File_Path&#39;,
    &#39;Alert.4259878&#39;: &#39;Target_Process_Name&#39;,
    &#39;Alert.4259879&#39;: &#39;Privileges&#39;,
    &#39;Alert.4259880&#39;: &#39;Search_Query&#39;,
    &#39;Alert.4259881&#39;: &#39;PCAP_Name&#39;,
    &#39;Alert.4259882&#39;: &#39;Vulnerability_References&#39;,
    &#39;Alert.4259883&#39;: &#39;Access_Privileges&#39;,
    &#39;Alert.4259884&#39;: &#39;Old_Value&#39;,
    &#39;Alert.4259885&#39;: &#39;New_Value&#39;,
    &#39;Alert.4259886&#39;: &#39;Device_URL&#39;,
    &#39;Alert.4259887&#39;: &#39;Engine_List&#39;,
    &#39;Alert.4456449&#39;: &#39;Num_Copies&#39;,
    &#39;Alert.4456450&#39;: &#39;Start_Page&#39;,
    &#39;Alert.4456451&#39;: &#39;End_Page&#39;,
    &#39;Alert.4456457&#39;: &#39;NTP_Offset_To_Monitor&#39;,
    &#39;Alert.4456458&#39;: &#39;Confidence&#39;,
    &#39;Alert.4456459&#39;: &#39;Hops&#39;,
    &#39;Alert.4456460&#39;: &#39;Priority&#39;,
    &#39;Alert.54919169&#39;: &#39;DNS - Type&#39;,
    &#39;Alert.54919171&#39;: &#39;Old_Reputation - ATD_File&#39;,
    &#39;Alert.54919172&#39;: &#39;New_Reputation - ATD_File&#39;,
    &#39;Alert.65537&#39;: &#39;Signature_Name&#39;,
    &#39;Alert.65538&#39;: &#39;Threat_Name&#39;,
    &#39;Alert.65539&#39;: &#39;Destination_Hostname&#39;,
    &#39;Alert.65540&#39;: &#39;Category&#39;,
    &#39;Alert.65541&#39;: &#39;Source_Zone&#39;,
    &#39;Alert.65542&#39;: &#39;Destination_Zone&#39;,
    &#39;Alert.65543&#39;: &#39;Target_Class&#39;,
    &#39;Alert.65544&#39;: &#39;Policy_Name&#39;,
    &#39;Alert.65545&#39;: &#39;Event_Class&#39;,
    &#39;Alert.65546&#39;: &#39;Request_Type&#39;,
    &#39;Alert.65547&#39;: &#39;Message_ID&#39;,
    &#39;Alert.65548&#39;: &#39;Mail_ID&#39;,
    &#39;Alert.65549&#39;: &#39;Recipient_ID&#39;,
    &#39;Alert.65550&#39;: &#39;Delivery_ID&#39;,
    &#39;Alert.65551&#39;: &#39;Creator_Name&#39;,
    &#39;Alert.65552&#39;: &#39;External_Application&#39;,
    &#39;Alert.65553&#39;: &#39;External_DB2_Server&#39;,
    &#39;Alert.65554&#39;: &#39;Table_Name&#39;,
    &#39;Alert.65555&#39;: &#39;Access_Resource&#39;,
    &#39;Alert.65556&#39;: &#39;Catalog_Name&#39;,
    &#39;Alert.65557&#39;: &#39;DB2_Plan_Name&#39;,
    &#39;Alert.65558&#39;: &#39;File_Type&#39;,
    &#39;Alert.65559&#39;: &#39;FTP_Command&#39;,
    &#39;Alert.65560&#39;: &#39;Job_Type&#39;,
    &#39;Alert.65561&#39;: &#39;Logical_Unit_Name&#39;,
    &#39;Alert.65562&#39;: &#39;LPAR_DB2_Subsystem&#39;,
    &#39;Alert.65563&#39;: &#39;Step_Count&#39;,
    &#39;Alert.65564&#39;: &#39;Step_Name&#39;,
    &#39;Alert.65565&#39;: &#39;Volume_ID&#39;,
    &#39;Alert.65566&#39;: &#39;Source_UserID&#39;,
    &#39;Alert.65567&#39;: &#39;Destination_UserID&#39;,
    &#39;Alert.65568&#39;: &#39;Mainframe_Job_Name&#39;,
    &#39;Alert.65569&#39;: &#39;Database_ID&#39;,
    &#39;Alert.65570&#39;: &#39;Malware_Insp_Action&#39;,
    &#39;Alert.65571&#39;: &#39;Malware_Insp_Result&#39;,
    &#39;Alert.65572&#39;: &#39;Source_Network&#39;,
    &#39;Alert.65573&#39;: &#39;Destination_Network&#39;,
    &#39;Alert.65574&#39;: &#39;Incoming_ID&#39;,
    &#39;Alert.65575&#39;: &#39;External_Hostname&#39;,
    &#39;Alert.65576&#39;: &#39;Area&#39;,
    &#39;Alert.65577&#39;: &#39;Facility&#39;,
    &#39;Alert.65578&#39;: &#39;Privileged_User&#39;,
    &#39;Alert.65579&#39;: &#39;Operating_System&#39;,
    &#39;Alert.65580&#39;: &#39;Logon_Type&#39;,
    &#39;Alert.65581&#39;: &#39;Management_Server&#39;,
    &#39;Alert.65582&#39;: &#39;External_SessionID&#39;,
    &#39;Alert.65583&#39;: &#39;Source_Logon_ID&#39;,
    &#39;Alert.65584&#39;: &#39;Destination_Logon_ID&#39;,
    &#39;Alert.65585&#39;: &#39;Session_Status&#39;,
    &#39;Alert.65586&#39;: &#39;URL_Category&#39;,
    &#39;Alert.65587&#39;: &#39;Caller_Process&#39;,
    &#39;Alert.65588&#39;: &#39;Registry_Key&#39;,
    &#39;Alert.65589&#39;: &#39;Registry_Value&#39;,
    &#39;Alert.65590&#39;: &#39;Mailbox&#39;,
    &#39;Alert.65591&#39;: &#39;Directory&#39;,
    &#39;Alert.65592&#39;: &#39;Destination_Directory&#39;,
    &#39;Alert.65593&#39;: &#39;SQL_Command&#39;,
    &#39;Alert.65594&#39;: &#39;Device_Action&#39;,
    &#39;Alert.65595&#39;: &#39;Threat_Category&#39;,
    &#39;Alert.65596&#39;: &#39;Threat_Handled&#39;,
    &#39;Alert.65597&#39;: &#39;Reason&#39;,
    &#39;Alert.65599&#39;: &#39;Detection_Method&#39;,
    &#39;Alert.65600&#39;: &#39;Virtual_Machine_Name&#39;,
    &#39;Alert.65601&#39;: &#39;Virtual_Machine_ID&#39;,
    &#39;Alert.65602&#39;: &#39;Datacenter_ID&#39;,
    &#39;Alert.65603&#39;: &#39;Datacenter_Name&#39;,
    &#39;Alert.65604&#39;: &#39;Interface_Dest&#39;,
    &#39;Alert.65605&#39;: &#39;Organizational_Unit&#39;,
    &#39;Alert.65606&#39;: &#39;External_Device_Type&#39;,
    &#39;Alert.65607&#39;: &#39;External_Device_ID&#39;,
    &#39;Alert.65608&#39;: &#39;External_Device_Name&#39;,
    &#39;Alert.65609&#39;: &#39;Service_Name&#39;,
    &#39;Alert.65610&#39;: &#39;Reputation_Name&#39;,
    &#39;Alert.65611&#39;: &#39;Status&#39;,
    &#39;Alert.65612&#39;: &#39;Sub_Status&#39;,
    &#39;Alert.65613&#39;: &#39;Web_Domain&#39;,
    &#39;Alert.65614&#39;: &#39;Group_Name&#39;,
    &#39;Alert.65615&#39;: &#39;App_Layer_Protocol&#39;,
    &#39;Alert.65616&#39;: &#39;Rule_Name&#39;,
    &#39;Alert.65617&#39;: &#39;Security_ID&#39;,
    &#39;Alert.65618&#39;: &#39;Authentication_Type&#39;,
    &#39;Alert.65619&#39;: &#39;SHA1&#39;,
    &#39;Alert.65620&#39;: &#39;File_ID&#39;,
    &#39;Alert.65621&#39;: &#39;Attribute_Type&#39;,
    &#39;Alert.65622&#39;: &#39;Access_Mask&#39;,
    &#39;Alert.65623&#39;: &#39;VPN_Feature_Name&#39;,
    &#39;Alert.65624&#39;: &#39;Hash&#39;,
    &#39;Alert.65625&#39;: &#39;Hash_Type&#39;,
    &#39;Alert.65627&#39;: &#39;Subcategory&#39;,
    &#39;Alert.65628&#39;: &#39;CnC_Host&#39;,
    &#39;Alert.65629&#39;: &#39;Share_Name&#39;,
    &#39;Alert.65630&#39;: &#39;SHA256&#39;,
    &#39;Alert.71696385&#39;: &#39;DNS - Type_Name&#39;,
    &#39;Alert.71696387&#39;: &#39;Old_Reputation - GTI_Cert&#39;,
    &#39;Alert.71696388&#39;: &#39;New_Reputation - GTI_Cert&#39;,
    &#39;Alert.88473601&#39;: &#39;DNS - Response_Code&#39;,
    &#39;Alert.88473603&#39;: &#39;Old_Reputation - TIE_Cert&#39;,
    &#39;Alert.88473604&#39;: &#39;New_Reputation - TIE_Cert&#39;,
    &#39;Alert.ASNGeoDst&#39;: &#39;ASNGeoDst&#39;,
    &#39;Alert.ASNGeoSrc&#39;: &#39;ASNGeoSrc&#39;,
    &#39;Alert.Action&#39;: &#39;Action&#39;,
    &#39;Alert.AlertID&#39;: &#39;AlertID&#39;,
    &#39;Alert.AppIDCat&#39;: &#39;AppIDCat&#39;,
    &#39;Alert.AvgSeverity&#39;: &#39;AvgSeverity&#39;,
    &#39;Alert.BIN(1)&#39;: &#39;AppID&#39;,
    &#39;Alert.BIN(10)&#39;: &#39;Object_Type&#39;,
    &#39;Alert.BIN(11)&#39;: &#39;Method&#39;,
    &#39;Alert.BIN(12)&#39;: &#39;File_Operation&#39;,
    &#39;Alert.BIN(13)&#39;: &#39;File_Operation_Succeeded&#39;,
    &#39;Alert.BIN(14)&#39;: &#39;User_Nickname&#39;,
    &#39;Alert.BIN(15)&#39;: &#39;Contact_Name&#39;,
    &#39;Alert.BIN(16)&#39;: &#39;Contact_Nickname&#39;,
    &#39;Alert.BIN(17)&#39;: &#39;DNS_Type&#39;,
    &#39;Alert.BIN(18)&#39;: &#39;DNS_Class&#39;,
    &#39;Alert.BIN(19)&#39;: &#39;Query_Response&#39;,
    &#39;Alert.BIN(2)&#39;: &#39;CommandID&#39;,
    &#39;Alert.BIN(20)&#39;: &#39;Authoritative_Answer&#39;,
    &#39;Alert.BIN(21)&#39;: &#39;SNMP_Operation&#39;,
    &#39;Alert.BIN(22)&#39;: &#39;SNMP_Item_Type&#39;,
    &#39;Alert.BIN(23)&#39;: &#39;SNMP_Version&#39;,
    &#39;Alert.BIN(24)&#39;: &#39;SNMP_Error_Code&#39;,
    &#39;Alert.BIN(25)&#39;: &#39;NTP_Client_Mode&#39;,
    &#39;Alert.BIN(26)&#39;: &#39;NTP_Server_Mode&#39;,
    &#39;Alert.BIN(27)&#39;: &#39;NTP_Request&#39;,
    &#39;Alert.BIN(28)&#39;: &#39;NTP_Opcode&#39;,
    &#39;Alert.BIN(29)&#39;: &#39;Interface&#39;,
    &#39;Alert.BIN(3)&#39;: &#39;DomainID&#39;,
    &#39;Alert.BIN(30)&#39;: &#39;Direction&#39;,
    &#39;Alert.BIN(31)&#39;: &#39;Sensor_Name&#39;,
    &#39;Alert.BIN(32)&#39;: &#39;Sensor_Type&#39;,
    &#39;Alert.BIN(33)&#39;: &#39;Response_Code&#39;,
    &#39;Alert.BIN(34)&#39;: &#39;Return_Code&#39;,
    &#39;Alert.BIN(4)&#39;: &#39;HostID&#39;,
    &#39;Alert.BIN(5)&#39;: &#39;ObjectID&#39;,
    &#39;Alert.BIN(6)&#39;: &#39;UserIDDst&#39;,
    &#39;Alert.BIN(7)&#39;: &#39;UserIDSrc&#39;,
    &#39;Alert.BIN(8)&#39;: &#39;Database_Name&#39;,
    &#39;Alert.BIN(9)&#39;: &#39;Application_Protocol&#39;,
    &#39;Alert.CommandIDCat&#39;: &#39;CommandIDCat&#39;,
    &#39;Alert.DSID&#39;: &#39;DSID&#39;,
    &#39;Alert.DSIDSigID&#39;: &#39;DSIDSigID&#39;,
    &#39;Alert.DomainIDCat&#39;: &#39;DomainIDCat&#39;,
    &#39;Alert.DstIP&#39;: &#39;DstIP&#39;,
    &#39;Alert.DstMac&#39;: &#39;DstMac&#39;,
    &#39;Alert.DstPort&#39;: &#39;DstPort&#39;,
    &#39;Alert.EventCount&#39;: &#39;EventCount&#39;,
    &#39;Alert.FirstTime&#39;: &#39;FirstTime&#39;,
    &#39;Alert.Flow&#39;: &#39;Flow&#39;,
    &#39;Alert.FlowID&#39;: &#39;FlowID&#39;,
    &#39;Alert.GUIDDst&#39;: &#39;GUIDDst&#39;,
    &#39;Alert.GUIDSrc&#39;: &#39;GUIDSrc&#39;,
    &#39;Alert.HostIDCat&#39;: &#39;HostIDCat&#39;,
    &#39;Alert.IPSID&#39;: &#39;IPSID&#39;,
    &#39;Alert.IPSIDAlertID&#39;: &#39;IPSIDAlertID&#39;,
    &#39;Alert.LastTime&#39;: &#39;LastTime&#39;,
    &#39;Alert.LastTime_usec&#39;: &#39;LastTime_usec&#39;,
    &#39;Alert.ObjectIDCat&#39;: &#39;ObjectIDCat&#39;,
    &#39;Alert.Protocol&#39;: &#39;Protocol&#39;,
    &#39;Alert.RemCaseID&#39;: &#39;RemCaseID&#39;,
    &#39;Alert.RemOpenTicketTime&#39;: &#39;RemOpenTicketTime&#39;,
    &#39;Alert.Reviewed&#39;: &#39;Reviewed&#39;,
    &#39;Alert.Sequence&#39;: &#39;Sequence&#39;,
    &#39;Alert.SessionID&#39;: &#39;SessionID&#39;,
    &#39;Alert.Severity&#39;: &#39;Severity&#39;,
    &#39;Alert.SigID&#39;: &#39;SigID&#39;,
    &#39;Alert.SrcIP&#39;: &#39;SrcIP&#39;,
    &#39;Alert.SrcMac&#39;: &#39;SrcMac&#39;,
    &#39;Alert.SrcPort&#39;: &#39;SrcPort&#39;,
    &#39;Alert.Trusted&#39;: &#39;Trusted&#39;,
    &#39;Alert.UserFld10Cat&#39;: &#39;UserFld10Cat&#39;,
    &#39;Alert.UserFld21Cat&#39;: &#39;UserFld21Cat&#39;,
    &#39;Alert.UserFld22Cat&#39;: &#39;UserFld22Cat&#39;,
    &#39;Alert.UserFld23Cat&#39;: &#39;UserFld23Cat&#39;,
    &#39;Alert.UserFld24Cat&#39;: &#39;UserFld24Cat&#39;,
    &#39;Alert.UserFld25Cat&#39;: &#39;UserFld25Cat&#39;,
    &#39;Alert.UserFld26Cat&#39;: &#39;UserFld26Cat&#39;,
    &#39;Alert.UserFld27Cat&#39;: &#39;UserFld27Cat&#39;,
    &#39;Alert.UserFld8Cat&#39;: &#39;UserFld8Cat&#39;,
    &#39;Alert.UserFld9Cat&#39;: &#39;UserFld9Cat&#39;,
    &#39;Alert.UserIDDstCat&#39;: &#39;UserIDDstCat&#39;,
    &#39;Alert.UserIDSrcCat&#39;: &#39;UserIDSrcCat&#39;,
    &#39;Alert.VLan&#39;: &#39;VLan&#39;,
    &#39;Alert.WriteTime&#39;: &#39;WriteTime&#39;,
    &#39;Alert.ZoneDst&#39;: &#39;ZoneDst&#39;,
    &#39;Alert.ZoneSrc&#39;: &#39;ZoneSrc&#39;}
    &#34;&#34;&#34;
    Fields name mapping.  
    &#34;&#34;&#34;

    # NICKNAME TO INTERNAL NAMES
    SIEM_FIELDS_MAP_NICKNAME_TO_INTERNAL_NAME={&#39;ASNGeoDst&#39;: &#39;Alert.ASNGeoDst&#39;,
    &#39;ASNGeoSrc&#39;: &#39;Alert.ASNGeoSrc&#39;,
    &#39;Access_Mask&#39;: &#39;Alert.65622&#39;,
    &#39;Access_Privileges&#39;: &#39;Alert.4259883&#39;,
    &#39;Access_Resource&#39;: &#39;Alert.65555&#39;,
    &#39;Action&#39;: &#39;Alert.Action&#39;,
    &#39;Action.Name&#39;: &#39;Action.Name&#39;,
    &#39;Agent_GUID&#39;: &#39;Alert.262162&#39;,
    &#39;AlertID&#39;: &#39;Alert.AlertID&#39;,
    &#39;Analyzer_DAT_Version&#39;: &#39;Alert.262170&#39;,
    &#39;AppID&#39;: &#39;Alert.BIN(1)&#39;,
    &#39;AppIDCat&#39;: &#39;Alert.AppIDCat&#39;,
    &#39;App_Layer_Protocol&#39;: &#39;Alert.65615&#39;,
    &#39;Application_Protocol&#39;: &#39;Alert.BIN(9)&#39;,
    &#39;Area&#39;: &#39;Alert.65576&#39;,
    &#39;Attacker_IP&#39;: &#39;Alert.262175&#39;,
    &#39;Attribute_Type&#39;: &#39;Alert.65621&#39;,
    &#39;Authentication_Type&#39;: &#39;Alert.65618&#39;,
    &#39;Authoritative_Answer&#39;: &#39;Alert.BIN(20)&#39;,
    &#39;AvgSeverity&#39;: &#39;Alert.AvgSeverity&#39;,
    &#39;Bcc&#39;: &#39;Alert.4259847&#39;,
    &#39;Caller_Process&#39;: &#39;Alert.65587&#39;,
    &#39;Catalog_Name&#39;: &#39;Alert.65556&#39;,
    &#39;Category&#39;: &#39;Alert.65540&#39;,
    &#39;Cc&#39;: &#39;Alert.4259846&#39;,
    &#39;Class.Name&#39;: &#39;Class.Name&#39;,
    &#39;Class.Priority&#39;: &#39;Class.Priority&#39;,
    &#39;Client_Version&#39;: &#39;Alert.4259853&#39;,
    &#39;CnC_Host&#39;: &#39;Alert.65628&#39;,
    &#39;CommandID&#39;: &#39;Alert.BIN(2)&#39;,
    &#39;CommandIDCat&#39;: &#39;Alert.CommandIDCat&#39;,
    &#39;Confidence&#39;: &#39;Alert.4456458&#39;,
    &#39;Contact_Name&#39;: &#39;Alert.BIN(15)&#39;,
    &#39;Contact_Nickname&#39;: &#39;Alert.BIN(16)&#39;,
    &#39;Cookie&#39;: &#39;Alert.4259850&#39;,
    &#39;Creator_Name&#39;: &#39;Alert.65551&#39;,
    &#39;DAT_Version&#39;: &#39;Alert.262165&#39;,
    &#39;DB2_Plan_Name&#39;: &#39;Alert.65557&#39;,
    &#39;DNS - Class&#39;: &#39;Alert.21364737&#39;,
    &#39;DNS - Class_Name&#39;: &#39;Alert.38141953&#39;,
    &#39;DNS - Query&#39;: &#39;Alert.122028033&#39;,
    &#39;DNS - Response_Code&#39;: &#39;Alert.88473601&#39;,
    &#39;DNS - Response_Code_Name&#39;: &#39;Alert.105250817&#39;,
    &#39;DNS - Type&#39;: &#39;Alert.54919169&#39;,
    &#39;DNS - Type_Name&#39;: &#39;Alert.71696385&#39;,
    &#39;DNS_Class&#39;: &#39;Alert.BIN(18)&#39;,
    &#39;DNS_Name&#39;: &#39;Alert.4259867&#39;,
    &#39;DNS_Server_IP&#39;: &#39;Alert.262178&#39;,
    &#39;DNS_Type&#39;: &#39;Alert.BIN(17)&#39;,
    &#39;DSID&#39;: &#39;Alert.DSID&#39;,
    &#39;DSIDSigID&#39;: &#39;Alert.DSIDSigID&#39;,
    &#39;Database_GUID&#39;: &#39;Alert.262169&#39;,
    &#39;Database_ID&#39;: &#39;Alert.65569&#39;,
    &#39;Database_Name&#39;: &#39;Alert.BIN(8)&#39;,
    &#39;Datacenter_ID&#39;: &#39;Alert.65602&#39;,
    &#39;Datacenter_Name&#39;: &#39;Alert.65603&#39;,
    &#39;Delivery_ID&#39;: &#39;Alert.65550&#39;,
    &#39;Description&#39;: &#39;Alert.4259873&#39;,
    &#39;Destination_Directory&#39;: &#39;Alert.65592&#39;,
    &#39;Destination_Filename&#39;: &#39;Alert.4259852&#39;,
    &#39;Destination_Hostname&#39;: &#39;Alert.65539&#39;,
    &#39;Destination_Logon_ID&#39;: &#39;Alert.65584&#39;,
    &#39;Destination_Network&#39;: &#39;Alert.65573&#39;,
    &#39;Destination_UserID&#39;: &#39;Alert.65567&#39;,
    &#39;Destination_Zone&#39;: &#39;Alert.65542&#39;,
    &#39;Detection_Method&#39;: &#39;Alert.65599&#39;,
    &#39;Device_Action&#39;: &#39;Alert.65594&#39;,
    &#39;Device_Confidence&#39;: &#39;Alert.262179&#39;,
    &#39;Device_IP&#39;: &#39;Alert.262154&#39;,
    &#39;Device_Port&#39;: &#39;Alert.262155&#39;,
    &#39;Device_URL&#39;: &#39;Alert.4259886&#39;,
    &#39;Direction&#39;: &#39;Alert.BIN(30)&#39;,
    &#39;Directory&#39;: &#39;Alert.65591&#39;,
    &#39;DomainID&#39;: &#39;Alert.BIN(3)&#39;,
    &#39;DomainIDCat&#39;: &#39;Alert.DomainIDCat&#39;,
    &#39;DstIP&#39;: &#39;Alert.DstIP&#39;,
    &#39;DstMac&#39;: &#39;Alert.DstMac&#39;,
    &#39;DstPort&#39;: &#39;Alert.DstPort&#39;,
    &#39;End_Page&#39;: &#39;Alert.4456451&#39;,
    &#39;Engine_List&#39;: &#39;Alert.4259887&#39;,
    &#39;EventCount&#39;: &#39;Alert.EventCount&#39;,
    &#39;Event_Class&#39;: &#39;Alert.65545&#39;,
    &#39;External_Application&#39;: &#39;Alert.65552&#39;,
    &#39;External_DB2_Server&#39;: &#39;Alert.65553&#39;,
    &#39;External_Device_ID&#39;: &#39;Alert.65607&#39;,
    &#39;External_Device_Name&#39;: &#39;Alert.65608&#39;,
    &#39;External_Device_Type&#39;: &#39;Alert.65606&#39;,
    &#39;External_EventID&#39;: &#39;Alert.262156&#39;,
    &#39;External_Hostname&#39;: &#39;Alert.65575&#39;,
    &#39;External_SessionID&#39;: &#39;Alert.65582&#39;,
    &#39;External_SubEventID&#39;: &#39;Alert.262158&#39;,
    &#39;FTP_Command&#39;: &#39;Alert.65559&#39;,
    &#39;Facility&#39;: &#39;Alert.65577&#39;,
    &#39;File_Hash&#39;: &#39;Alert.262159&#39;,
    &#39;File_ID&#39;: &#39;Alert.65620&#39;,
    &#39;File_Operation&#39;: &#39;Alert.BIN(12)&#39;,
    &#39;File_Operation_Succeeded&#39;: &#39;Alert.BIN(13)&#39;,
    &#39;File_Path&#39;: &#39;Alert.4259877&#39;,
    &#39;File_Type&#39;: &#39;Alert.65558&#39;,
    &#39;Filename&#39;: &#39;Alert.4259843&#39;,
    &#39;FirstTime&#39;: &#39;Alert.FirstTime&#39;,
    &#39;Flow&#39;: &#39;Alert.Flow&#39;,
    &#39;FlowID&#39;: &#39;Alert.FlowID&#39;,
    &#39;From&#39;: &#39;Alert.4259844&#39;,
    &#39;From_Address&#39;: &#39;Alert.4259875&#39;,
    &#39;GUIDDst&#39;: &#39;Alert.GUIDDst&#39;,
    &#39;GUIDSrc&#39;: &#39;Alert.GUIDSrc&#39;,
    &#39;GeoLoc_ASNGeoDst.Latitude&#39;: &#39;GeoLoc_ASNGeoDst.Latitude&#39;, # This is useless
    &#39;GeoLoc_ASNGeoDst.Longitude&#39;: &#39;GeoLoc_ASNGeoDst.Longitude&#39;, # This is useless
    &#39;GeoLoc_ASNGeoDst.Msg&#39;: &#39;GeoLoc_ASNGeoDst.Msg&#39;, # This is useless
    &#39;GeoLoc_ASNGeoDst.XCoord&#39;: &#39;GeoLoc_ASNGeoDst.XCoord&#39;, # This is useless
    &#39;GeoLoc_ASNGeoDst.YCoord&#39;: &#39;GeoLoc_ASNGeoDst.YCoord&#39;, # This is useless
    &#39;GeoLoc_ASNGeoSrc.Latitude&#39;: &#39;GeoLoc_ASNGeoSrc.Latitude&#39;,  # This is useless
    &#39;GeoLoc_ASNGeoSrc.Longitude&#39;: &#39;GeoLoc_ASNGeoSrc.Longitude&#39;,  # This is useless
    &#39;GeoLoc_ASNGeoSrc.Msg&#39;: &#39;GeoLoc_ASNGeoSrc.Msg&#39;,  # This is useless
    &#39;GeoLoc_ASNGeoSrc.XCoord&#39;: &#39;GeoLoc_ASNGeoSrc.XCoord&#39;,  # This is useless
    &#39;GeoLoc_ASNGeoSrc.YCoord&#39;: &#39;GeoLoc_ASNGeoSrc.YCoord&#39;,  # This is useless
    &#39;Grid_Master_IP&#39;: &#39;Alert.262153&#39;,
    &#39;Group_Name&#39;: &#39;Alert.65614&#39;,
    &#39;Handheld_ID&#39;: &#39;Alert.262168&#39;,
    &#39;Handle_ID&#39;: &#39;Alert.262160&#39;,
    &#39;Hash&#39;: &#39;Alert.65624&#39;,
    &#39;Hash_Type&#39;: &#39;Alert.65625&#39;,
    &#39;Hops&#39;: &#39;Alert.4456459&#39;,
    &#39;HostID&#39;: &#39;Alert.BIN(4)&#39;,
    &#39;HostIDCat&#39;: &#39;Alert.HostIDCat&#39;,
    &#39;IPS.Name&#39;: &#39;IPS.Name&#39;,
    &#39;IPSID&#39;: &#39;Alert.IPSID&#39;,
    &#39;IPSIDAlertID&#39;: &#39;Alert.IPSIDAlertID&#39;,
    &#39;Incident_ID&#39;: &#39;Alert.262173&#39;,
    &#39;Incoming_ID&#39;: &#39;Alert.65574&#39;,
    &#39;Instance_GUID&#39;: &#39;Alert.262161&#39;,
    &#39;Interface&#39;: &#39;Alert.BIN(29)&#39;,
    &#39;Interface_Dest&#39;: &#39;Alert.65604&#39;,
    &#39;Job_Name&#39;: &#39;Alert.4259854&#39;,
    &#39;Job_Type&#39;: &#39;Alert.65560&#39;,
    &#39;LPAR_DB2_Subsystem&#39;: &#39;Alert.65562&#39;,
    &#39;Language&#39;: &#39;Alert.4259855&#39;,
    &#39;LastTime&#39;: &#39;Alert.LastTime&#39;,
    &#39;LastTime_usec&#39;: &#39;Alert.LastTime_usec&#39;,
    &#39;Local_User_Name&#39;: &#39;Alert.4259860&#39;,
    &#39;Logical_Unit_Name&#39;: &#39;Alert.65561&#39;,
    &#39;Logon_Type&#39;: &#39;Alert.65580&#39;,
    &#39;Mail_ID&#39;: &#39;Alert.65548&#39;,
    &#39;Mailbox&#39;: &#39;Alert.65590&#39;,
    &#39;Mainframe_Job_Name&#39;: &#39;Alert.65568&#39;,
    &#39;Malware_Insp_Action&#39;: &#39;Alert.65570&#39;,
    &#39;Malware_Insp_Result&#39;: &#39;Alert.65571&#39;,
    &#39;Management_Server&#39;: &#39;Alert.65581&#39;,
    &#39;Message_ID&#39;: &#39;Alert.65547&#39;,
    &#39;Message_Text&#39;: &#39;Alert.4259842&#39;,
    &#39;Method&#39;: &#39;Alert.BIN(11)&#39;,
    &#39;NAT_Details&#39;: &#39;Alert.262146&#39;,
    &#39;NTP_Client_Mode&#39;: &#39;Alert.BIN(25)&#39;,
    &#39;NTP_Offset_To_Monitor&#39;: &#39;Alert.4456457&#39;,
    &#39;NTP_Opcode&#39;: &#39;Alert.BIN(28)&#39;,
    &#39;NTP_Request&#39;: &#39;Alert.BIN(27)&#39;,
    &#39;NTP_Server_Mode&#39;: &#39;Alert.BIN(26)&#39;,
    &#39;New_Reputation - ATD_File&#39;: &#39;Alert.54919172&#39;,
    &#39;New_Reputation - GTI_Cert&#39;: &#39;Alert.71696388&#39;,
    &#39;New_Reputation - GTI_File&#39;: &#39;Alert.21364740&#39;,
    &#39;New_Reputation - TIE_Cert&#39;: &#39;Alert.88473604&#39;,
    &#39;New_Reputation - TIE_File&#39;: &#39;Alert.38141956&#39;,
    &#39;New_Value&#39;: &#39;Alert.4259885&#39;,
    &#39;Num_Copies&#39;: &#39;Alert.4456449&#39;,
    &#39;ObjectID&#39;: &#39;Alert.BIN(5)&#39;,
    &#39;ObjectIDCat&#39;: &#39;Alert.ObjectIDCat&#39;,
    &#39;Object_GUID&#39;: &#39;Alert.262176&#39;,
    &#39;Object_Type&#39;: &#39;Alert.BIN(10)&#39;,
    &#39;Old_Reputation - ATD_File&#39;: &#39;Alert.54919171&#39;,
    &#39;Old_Reputation - GTI_Cert&#39;: &#39;Alert.71696387&#39;,
    &#39;Old_Reputation - GTI_File&#39;: &#39;Alert.21364739&#39;,
    &#39;Old_Reputation - TIE_Cert&#39;: &#39;Alert.88473603&#39;,
    &#39;Old_Reputation - TIE_File&#39;: &#39;Alert.38141955&#39;,
    &#39;Old_Value&#39;: &#39;Alert.4259884&#39;,
    &#39;Operating_System&#39;: &#39;Alert.65579&#39;,
    &#39;Organizational_Unit&#39;: &#39;Alert.65605&#39;,
    &#39;PCAP_Name&#39;: &#39;Alert.4259881&#39;,
    &#39;PID&#39;: &#39;Alert.262152&#39;,
    &#39;Parent_File_Hash&#39;: &#39;Alert.262172&#39;,
    &#39;Policy_ID&#39;: &#39;Alert.262167&#39;,
    &#39;Policy_Name&#39;: &#39;Alert.65544&#39;,
    &#39;Priority&#39;: &#39;Alert.4456460&#39;,
    &#39;Privileged_User&#39;: &#39;Alert.65578&#39;,
    &#39;Privileges&#39;: &#39;Alert.4259879&#39;,
    &#39;Process_Name&#39;: &#39;Alert.4259870&#39;,
    &#39;Protocol&#39;: &#39;Alert.Protocol&#39;,
    &#39;Query_Response&#39;: &#39;Alert.BIN(19)&#39;,
    &#39;Queue_ID&#39;: &#39;Alert.196609&#39;,
    &#39;RTMP_Application&#39;: &#39;Alert.4259858&#39;,
    &#39;Reason&#39;: &#39;Alert.65597&#39;,
    &#39;Recipient_ID&#39;: &#39;Alert.65549&#39;,
    &#39;Referer&#39;: &#39;Alert.4259851&#39;,
    &#39;Registry - Key&#39;: &#39;Alert.21364738&#39;,
    &#39;Registry - Value&#39;: &#39;Alert.38141954&#39;,
    &#39;Registry_Key&#39;: &#39;Alert.65588&#39;,
    &#39;Registry_Value&#39;: &#39;Alert.65589&#39;,
    &#39;RemCaseID&#39;: &#39;Alert.RemCaseID&#39;,
    &#39;RemOpenTicketTime&#39;: &#39;Alert.RemOpenTicketTime&#39;,
    &#39;Reputation&#39;: &#39;Alert.262164&#39;,
    &#39;Reputation_Name&#39;: &#39;Alert.65610&#39;,
    &#39;Reputation_Score&#39;: &#39;Alert.262171&#39;,
    &#39;Reputation_Server_IP&#39;: &#39;Alert.262177&#39;,
    &#39;Request_Type&#39;: &#39;Alert.65546&#39;,
    &#39;Response_Code&#39;: &#39;Alert.BIN(33)&#39;,
    &#39;Response_Time&#39;: &#39;Alert.262145&#39;,
    &#39;Return_Code&#39;: &#39;Alert.BIN(34)&#39;,
    &#39;Reviewed&#39;: &#39;Alert.Reviewed&#39;,
    &#39;Rule.ID&#39;: &#39;Rule.ID&#39;,
    &#39;Rule.NormID&#39;: &#39;Rule.NormID&#39;,
    &#39;Rule.msg&#39;: &#39;Rule.msg&#39;,
    &#39;Rule_NDSNormSigID.msg&#39;: &#39;Rule_NDSNormSigID.msg&#39;,
    &#39;Rule_Name&#39;: &#39;Alert.65616&#39;,
    &#39;SHA1&#39;: &#39;Alert.65619&#39;,
    &#39;SHA256&#39;: &#39;Alert.65630&#39;,
    &#39;SNMP_Error_Code&#39;: &#39;Alert.BIN(24)&#39;,
    &#39;SNMP_Item&#39;: &#39;Alert.4259868&#39;,
    &#39;SNMP_Item_Type&#39;: &#39;Alert.BIN(22)&#39;,
    &#39;SNMP_Operation&#39;: &#39;Alert.BIN(21)&#39;,
    &#39;SNMP_Version&#39;: &#39;Alert.BIN(23)&#39;,
    &#39;SQL_Command&#39;: &#39;Alert.65593&#39;,
    &#39;SQL_Statement&#39;: &#39;Alert.4259874&#39;,
    &#39;SWF_URL&#39;: &#39;Alert.4259856&#39;,
    &#39;Search_Query&#39;: &#39;Alert.4259880&#39;,
    &#39;Security_ID&#39;: &#39;Alert.65617&#39;,
    &#39;Sensor_Name&#39;: &#39;Alert.BIN(31)&#39;,
    &#39;Sensor_Type&#39;: &#39;Alert.BIN(32)&#39;,
    &#39;Sensor_UUID&#39;: &#39;Alert.4259869&#39;,
    &#39;Sequence&#39;: &#39;Alert.Sequence&#39;,
    &#39;Server_ID&#39;: &#39;Alert.262166&#39;,
    &#39;Service_Name&#39;: &#39;Alert.65609&#39;,
    &#39;SessionID&#39;: &#39;Alert.SessionID&#39;,
    &#39;Session_Status&#39;: &#39;Alert.65585&#39;,
    &#39;Severity&#39;: &#39;Alert.Severity&#39;,
    &#39;Share_Name&#39;: &#39;Alert.65629&#39;,
    &#39;SigID&#39;: &#39;Alert.SigID&#39;,
    &#39;Signature_Name&#39;: &#39;Alert.65537&#39;,
    &#39;Source_Context&#39;: &#39;Alert.4259871&#39;,
    &#39;Source_Logon_ID&#39;: &#39;Alert.65583&#39;,
    &#39;Source_Network&#39;: &#39;Alert.65572&#39;,
    &#39;Source_UserID&#39;: &#39;Alert.65566&#39;,
    &#39;Source_Zone&#39;: &#39;Alert.65541&#39;,
    &#39;Spam_Score&#39;: &#39;Alert.262157&#39;,
    &#39;SrcIP&#39;: &#39;Alert.SrcIP&#39;,
    &#39;SrcMac&#39;: &#39;Alert.SrcMac&#39;,
    &#39;SrcPort&#39;: &#39;Alert.SrcPort&#39;,
    &#39;Start_Page&#39;: &#39;Alert.4456450&#39;,
    &#39;Status&#39;: &#39;Alert.65611&#39;,
    &#39;Step_Count&#39;: &#39;Alert.65563&#39;,
    &#39;Step_Name&#39;: &#39;Alert.65564&#39;,
    &#39;Sub_Status&#39;: &#39;Alert.65612&#39;,
    &#39;Subcategory&#39;: &#39;Alert.65627&#39;,
    &#39;Subject&#39;: &#39;Alert.4259848&#39;,
    &#39;TC_URL&#39;: &#39;Alert.4259857&#39;,
    &#39;Table_Name&#39;: &#39;Alert.65554&#39;,
    &#39;Target_Class&#39;: &#39;Alert.65543&#39;,
    &#39;Target_Context&#39;: &#39;Alert.4259872&#39;,
    &#39;Target_Process_Name&#39;: &#39;Alert.4259878&#39;,
    &#39;ThirdPartyType.Name&#39;: &#39;ThirdPartyType.Name&#39;, # This is useless
    &#39;Threat_Category&#39;: &#39;Alert.65595&#39;,
    &#39;Threat_Handled&#39;: &#39;Alert.65596&#39;,
    &#39;Threat_Name&#39;: &#39;Alert.65538&#39;,
    &#39;To&#39;: &#39;Alert.4259845&#39;,
    &#39;To_Address&#39;: &#39;Alert.4259876&#39;,
    &#39;Trusted&#39;: &#39;Alert.Trusted&#39;,
    &#39;URL&#39;: &#39;Alert.4259841&#39;,
    &#39;URL_Category&#39;: &#39;Alert.65586&#39;,
    &#39;UUID&#39;: &#39;Alert.262163&#39;,
    &#39;UserFld10Cat&#39;: &#39;Alert.UserFld10Cat&#39;,
    &#39;UserFld21Cat&#39;: &#39;Alert.UserFld21Cat&#39;,
    &#39;UserFld22Cat&#39;: &#39;Alert.UserFld22Cat&#39;,
    &#39;UserFld23Cat&#39;: &#39;Alert.UserFld23Cat&#39;,
    &#39;UserFld24Cat&#39;: &#39;Alert.UserFld24Cat&#39;,
    &#39;UserFld25Cat&#39;: &#39;Alert.UserFld25Cat&#39;,
    &#39;UserFld26Cat&#39;: &#39;Alert.UserFld26Cat&#39;,
    &#39;UserFld27Cat&#39;: &#39;Alert.UserFld27Cat&#39;,
    &#39;UserFld8Cat&#39;: &#39;Alert.UserFld8Cat&#39;,
    &#39;UserFld9Cat&#39;: &#39;Alert.UserFld9Cat&#39;,
    &#39;UserIDDst&#39;: &#39;Alert.BIN(6)&#39;,
    &#39;UserIDDstCat&#39;: &#39;Alert.UserIDDstCat&#39;,
    &#39;UserIDSrc&#39;: &#39;Alert.BIN(7)&#39;,
    &#39;UserIDSrcCat&#39;: &#39;Alert.UserIDSrcCat&#39;,
    &#39;User_Agent&#39;: &#39;Alert.4259849&#39;,
    &#39;User_Nickname&#39;: &#39;Alert.BIN(14)&#39;,
    &#39;Users.Name&#39;: &#39;Users.Name&#39;,  # This is useless
    &#39;VLan&#39;: &#39;Alert.VLan&#39;,
    &#39;VPN_Feature_Name&#39;: &#39;Alert.65623&#39;,
    &#39;Version&#39;: &#39;Alert.4259859&#39;,
    &#39;Victim_IP&#39;: &#39;Alert.262174&#39;,
    &#39;Virtual_Machine_ID&#39;: &#39;Alert.65601&#39;,
    &#39;Virtual_Machine_Name&#39;: &#39;Alert.65600&#39;,
    &#39;Volume_ID&#39;: &#39;Alert.65565&#39;,
    &#39;Vulnerability_References&#39;: &#39;Alert.4259882&#39;,
    &#39;Web_Domain&#39;: &#39;Alert.65613&#39;,
    &#39;WriteTime&#39;: &#39;Alert.WriteTime&#39;,
    &#39;ZoneDst&#39;: &#39;Alert.ZoneDst&#39;,
    &#39;ZoneSrc&#39;: &#39;Alert.ZoneSrc&#39;,
    &#39;Zone_ZoneDst.Name&#39;: &#39;Zone_ZoneDst.Name&#39;,  # This is useless
    &#39;Zone_ZoneSrc.Name&#39;: &#39;Zone_ZoneSrc.Name&#39;}  # This is useless
    &#34;&#34;&#34;
    Fields name mapping (reversed).  
    &#34;&#34;&#34;
    def _find_key(self, key):
        if collections.UserDict.__contains__(self, key): 
            return key
        if ( key in self.SIEM_FIELDS_MAP_NICKNAME_TO_INTERNAL_NAME.keys() and 
            collections.UserDict.__contains__(self, self.SIEM_FIELDS_MAP_NICKNAME_TO_INTERNAL_NAME[key]) ): 
            return self.SIEM_FIELDS_MAP_NICKNAME_TO_INTERNAL_NAME[key]

        # Loop thought FIELDS_TABLES and try with table prefix
        # Old behaviour
        for table in self.FIELDS_TABLES :
            if collections.UserDict.__contains__(self, table+&#39;.&#39;+key): 
                return table+&#39;.&#39;+key

        raise KeyError(&#39;Dictionnary key not found : {}&#39;.format(key))

    def __getitem__(self, key):
        return collections.UserDict.__getitem__(self, self._find_key(key))
    def __delitem__(self, key):
        return collections.UserDict.__delitem__(self, self._find_key(key))
    def __contains__(self, key):
        try: return self._find_key(key)!=None
        except KeyError: return False
    def __setitem__(self, key, value):
        try: return collections.UserDict.__setitem__(self, self._find_key(key), value)
        except KeyError: return collections.UserDict.__setitem__(self, key, value)

    def get_id(self):
        &#34;&#34;&#34;
        Get the event ID.  
        Try to return `e[&#39;Alert.IPSIDAlertID&#39;]` or e[&#39;eventId&#39;]` or concatenate `e[&#39;ipsId&#39;][&#39;id&#39;]` and `e[&#39;alertId&#39;]` depending of the Event dictionnary keys.  
        &#34;&#34;&#34;
        the_id = ( self.data[&#34;Alert.IPSIDAlertID&#34;] if ( &#34;Alert.IPSIDAlertID&#34; in self.data )
            else str(self.data[&#39;ipsId&#39;][&#39;id&#39;])+&#39;|&#39;+str(self.data[&#34;alertId&#34;]) if ( &#34;alertId&#34; in self.data )
            else self.data[&#34;eventId&#34;] if ( &#34;eventId&#34; in self.data ) else None )
        if the_id:
            return the_id
        else:
            return None

    def clear_notes(self):
        &#34;&#34;&#34;
        Replace the notes by an empty string. Desctructive action.
        &#34;&#34;&#34;
        self.set_note(&#39;&#39;, no_date=True)

    def set_note(self, note, no_date=False):
        &#34;&#34;&#34;
        Set the event&#39;s note. Desctructive action.
        &#34;&#34;&#34;
        the_id = self.get_id()
        
        if isinstance(the_id, str):

            if len(note) &gt;= 4000:
                log.warning(&#34;The note is longer than 4000 characters, only the&#34; 
                            &#34;first 4000 characters will be kept. The maximum&#34; 
                            &#34;accepted by the SIEM is 4096 characters.&#34;)
                note=note[:4000]+&#39;\n\n--NOTE HAS BEEN TRUNCATED--&#39;
            
            if no_date==False:
                timestamp = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)
                note = note.replace(&#39;&#34;&#39;,&#39;\\&#34;&#39;).replace(&#39;\n&#39;,&#39;\\n&#39;)
                note = timestamp + &#39; - &#39; + note
            
            self.nitro.request(&#34;add_note_to_event_int&#34;, 
                id=the_id,
                note=note)
        else :
            log.error(&#34;Couldn&#39;t set event&#39;s note, the event ID hasn&#39;t been found. Event: {}&#34;.format(self))
        
    def data_from_id(self, id, use_query=False, extra_fields=[]):
        &#34;&#34;&#34;
        Load event&#39;s data.  

        Arguments:   

        - `id` : The event ID. (i.e. : `144128388087414784|747122896`)  
        - `use_query` : Uses the query module to retreive common event data. Only works with SIEM 11.2 or greater.    
        Default behaviour will call `ipsGetAlertData` to retreive the complete event definition.  
        - `extra_fields` : Only when `use_query=True`. Additionnal event fields to load in the query.  
        &#34;&#34;&#34;
        
        if use_query == True :
            f = FieldFilter(&#39;IPSIDAlertID&#39;, id, operator=&#39;EQUALS&#39;)
            e = EventManager(
                time_range=&#39;CUSTOM&#39;,
                start_time=datetime.now()-timedelta(days=365),
                end_time=datetime.now()+timedelta(days=1),
                filters=[f],
                fields=extra_fields,
                limit=2)
            try:
                e.load_data()
            except NitroError:
                log.error(&#34;Query failed, can&#39;t load event&#39;s data from id with 1 year timerange, looking at the last 45 days only...&#34;)
                e.start_time=datetime.now()-timedelta(days=45)
                e.load_data()

            if len(e) == 1 :
                return e[0]
            else :
                raise NitroError(&#39;Could not load event : &#39;+str(id)+&#39; from query :&#39;+str(e.__dict__)+&#39;. Try with use_query=False.&#39;)

        elif use_query == False :
            return self.nitro.request(&#39;get_alert_data&#39;, id=id)

    def refresh(self): 
        &#34;&#34;&#34;Re-load event&#39;s data&#34;&#34;&#34;
        if &#39;Alert.IPSIDAlertID&#39; in self.data.keys() :
            # ensure to re-use the query module if that&#39;s the case
            self.data.update(self.data_from_id(self.data[&#39;Alert.IPSIDAlertID&#39;], 
                use_query=True, extra_fields=self.data.keys()))
        else :
            the_id = self.get_id()
            self.data.update(self.data_from_id(the_id))
   
class _QueryFilter(collections.UserDict): 
    &#34;&#34;&#34;Base class for all SIEM query objects in order to dump the filter as dict.
    &#34;&#34;&#34;

class GroupFilter(_QueryFilter):
    &#34;&#34;&#34;
        Based on EsmFilterGroup. See SIEM api doc.
        Used to dump groups of filters in the right format.

        Arguments :  

        - `filters` : a list of filters. Filters can be `msiempy.event.FieldFilter` or `msiempy.event.GroupFilter`    
        - `logic` : &#39;AND&#39; or &#39;OR&#39;  
    &#34;&#34;&#34;

    def __init__(self, filters, logic=&#39;AND&#39;) :
        super().__init__()
        
        #Declaring attributes
        self.data={
            &#34;type&#34;: &#34;EsmFilterGroup&#34;,
            &#34;filters&#34;: [dict(f) for f in filters],
            &#34;logic&#34;:logic
            }

class FieldFilter(_QueryFilter):
    &#34;&#34;&#34;
    Based on EsmFieldFilter SIEM api doc.  

    This class is automatically used when instanciating `EventManager` objects to dump filters in the right `dict` format if tuples are gave as the `filters` argument like:  

    ```
    e = EventManager(time_range=&#39;LAST_MINUTE&#39;, filters=[ (&#39;SrcIP&#39;, [&#39;10.5.0.0/16&#39;]) ])
    ```

    Default operator is `&#34;IN&#34;`.  
    
    To change the operator, create a `FieldFilter`:  
    Exemple to filter by Signature ID.  

    ```
    e = EventManager(time_range=&#39;LAST_24_HOURS&#39;, filters=[ FieldFilter(&#39;DSIDSigID&#39;, [&#34;49190-4294967295&#34;], operator=&#39;EQUALS&#39;) ])
    ```

    *Make sure the filter name is valid by checking the result of `msiempy.event.EventManager.get_possible_filters` or use the provided script in the sample folder*

    Arguments:

        - `name` : field name as string. Field name property. Example : `SrcIP`. See full list here: https://github.com/mfesiem/msiempy/blob/master/static/all_filters.json
        - `values` : list of values the field is going to be tested againts with the specified orperator.  
        - `orperator` : `IN`,
        `NOT_IN`,
        `GREATER_THAN`,
        `LESS_THAN`,
        `GREATER_OR_EQUALS_THAN`,
        `LESS_OR_EQUALS_THAN`,
        `NUMERIC_EQUALS`,
        `NUMERIC_NOT_EQUALS`,
        `DOES_NOT_EQUAL`,
        `EQUALS`,
        `CONTAINS`,
        `DOES_NOT_CONTAIN`,
        `REGEX`.  
    &#34;&#34;&#34;

    # Declaring static value containing all the possibles
    # event fields usable in filters should be loaded once, when instanciating a FieldFilter

    # Basically [ item.get(&#39;name&#39;) for item in EventManager().get_possible_filters() ]
    DOCUMENTED_FILTERS = [
        &#34;IPSIDAlertID&#34;, # IPSIDAlertID has been manually added to this list
        &#39;AppID&#39;,
        &#39;CommandID&#39;,
        &#39;DomainID&#39;,
        &#39;HostID&#39;,
        &#39;ObjectID&#39;,
        &#39;UserIDDst&#39;,
        &#39;UserIDSrc&#39;,
        &#39;URL&#39;,
        &#39;Database_Name&#39;,
        &#39;Message_Text&#39;,
        &#39;Response_Time&#39;,
        &#39;Application_Protocol&#39;,
        &#39;Object_Type&#39;,
        &#39;Filename&#39;,
        &#39;From&#39;,
        &#39;To&#39;,
        &#39;Cc&#39;,
        &#39;Bcc&#39;,
        &#39;Subject&#39;,
        &#39;Method&#39;,
        &#39;User_Agent&#39;,
        &#39;Cookie&#39;,
        &#39;Referer&#39;,
        &#39;File_Operation&#39;,
        &#39;File_Operation_Succeeded&#39;,
        &#39;Destination_Filename&#39;,
        &#39;User_Nickname&#39;,
        &#39;Contact_Name&#39;,
        &#39;Contact_Nickname&#39;,
        &#39;Client_Version&#39;,
        &#39;Job_Name&#39;,
        &#39;Language&#39;,
        &#39;SWF_URL&#39;,
        &#39;TC_URL&#39;,
        &#39;RTMP_Application&#39;,
        &#39;Version&#39;,
        &#39;Local_User_Name&#39;,
        &#39;NAT_Details&#39;,
        &#39;Network_Layer&#39;,
        &#39;Transport_Layer&#39;,
        &#39;Session_Layer&#39;,
        &#39;Application_Layer&#39;,
        &#39;HTTP_Layer&#39;,
        &#39;HTTP_Req_URL&#39;,
        &#39;HTTP_Req_Cookie&#39;,
        &#39;HTTP_Req_Referer&#39;,
        &#39;HTTP_Req_Host&#39;,
        &#39;HTTP_Req_Method&#39;,
        &#39;HTTP_User_Agent&#39;,
        &#39;DNS_Name&#39;,
        &#39;DNS_Type&#39;,
        &#39;DNS_Class&#39;,
        &#39;Query_Response&#39;,
        &#39;Authoritative_Answer&#39;,
        &#39;SNMP_Operation&#39;,
        &#39;SNMP_Item_Type&#39;,
        &#39;SNMP_Version&#39;,
        &#39;SNMP_Error_Code&#39;,
        &#39;NTP_Client_Mode&#39;,
        &#39;NTP_Server_Mode&#39;,
        &#39;NTP_Request&#39;,
        &#39;NTP_Opcode&#39;,
        &#39;SNMP_Item&#39;,
        &#39;Interface&#39;,
        &#39;Direction&#39;,
        &#39;Sensor_Name&#39;,
        &#39;Sensor_UUID&#39;,
        &#39;Sensor_Type&#39;,
        &#39;Signature_Name&#39;,
        &#39;Threat_Name&#39;,
        &#39;Destination_Hostname&#39;,
        &#39;Category&#39;,
        &#39;Process_Name&#39;,
        &#39;Grid_Master_IP&#39;,
        &#39;Response_Code&#39;,
        &#39;Device_Port&#39;,
        &#39;Device_IP&#39;,
        &#39;PID&#39;,
        &#39;Target_Context&#39;,
        &#39;Source_Context&#39;,
        &#39;Target_Class&#39;,
        &#39;Policy_Name&#39;,
        &#39;Destination_Zone&#39;,
        &#39;Source_Zone&#39;,
        &#39;Queue_ID&#39;,
        &#39;Delivery_ID&#39;,
        &#39;Recipient_ID&#39;,
        &#39;Spam_Score&#39;,
        &#39;Mail_ID&#39;,
        &#39;To_Address&#39;,
        &#39;From_Address&#39;,
        &#39;Message_ID&#39;,
        &#39;Request_Type&#39;,
        &#39;SQL_Statement&#39;,
        &#39;External_EventID&#39;,
        &#39;Event_Class&#39;,
        &#39;Description&#39;,
        &#39;File_Hash&#39;,
        &#39;Mainframe_Job_Name&#39;,
        &#39;External_SubEventID&#39;,
        &#39;Destination_UserID&#39;,
        &#39;Source_UserID&#39;,
        &#39;Volume_ID&#39;,
        &#39;Step_Name&#39;,
        &#39;Step_Count&#39;,
        &#39;LPAR_DB2_Subsystem&#39;,
        &#39;Logical_Unit_Name&#39;,
        &#39;Job_Type&#39;,
        &#39;FTP_Command&#39;,
        &#39;File_Type&#39;,
        &#39;DB2_Plan_Name&#39;,
        &#39;Catalog_Name&#39;,
        &#39;Access_Resource&#39;,
        &#39;Table_Name&#39;,
        &#39;External_DB2_Server&#39;,
        &#39;External_Application&#39;,
        &#39;Creator_Name&#39;,
        &#39;Return_Code&#39;,
        &#39;Database_ID&#39;,
        &#39;Incoming_ID&#39;,
        &#39;Handle_ID&#39;,
        &#39;Destination_Network&#39;,
        &#39;Source_Network&#39;,
        &#39;Malware_Insp_Result&#39;,
        &#39;Malware_Insp_Action&#39;,
        &#39;External_Hostname&#39;,
        &#39;Privileged_User&#39;,
        &#39;Facility&#39;,
        &#39;Area&#39;,
        &#39;Instance_GUID&#39;,
        &#39;Logon_Type&#39;,
        &#39;Operating_System&#39;,
        &#39;File_Path&#39;,
        &#39;Agent_GUID&#39;,
        &#39;Reputation&#39;,
        &#39;URL_Category&#39;,
        &#39;Session_Status&#39;,
        &#39;Destination_Logon_ID&#39;,
        &#39;Source_Logon_ID&#39;,
        &#39;UUID&#39;,
        &#39;External_SessionID&#39;,
        &#39;Management_Server&#39;,
        &#39;Detection_Method&#39;,
        &#39;Target_Process_Name&#39;,
        &#39;Analyzer_DAT_Version&#39;,
        &#39;Forwarding_Status&#39;,
        &#39;Reason&#39;,
        &#39;Threat_Handled&#39;,
        &#39;Threat_Category&#39;,
        &#39;Device_Action&#39;,
        &#39;Database_GUID&#39;,
        &#39;SQL_Command&#39;,
        &#39;Destination_Directory&#39;,
        &#39;Directory&#39;,
        &#39;Mailbox&#39;,
        &#39;Handheld_ID&#39;,
        &#39;Policy_ID&#39;,
        &#39;Server_ID&#39;,
        &#39;Registry_Value&#39;,
        &#39;Registry_Key&#39;,
        &#39;Caller_Process&#39;,
        &#39;DAT_Version&#39;,
        &#39;Interface_Dest&#39;,
        &#39;Datacenter_Name&#39;,
        &#39;Datacenter_ID&#39;,
        &#39;Virtual_Machine_ID&#39;,
        &#39;Virtual_Machine_Name&#39;,
        &#39;PCAP_Name&#39;,
        &#39;Search_Query&#39;,
        &#39;Service_Name&#39;,
        &#39;External_Device_Name&#39;,
        &#39;External_Device_ID&#39;,
        &#39;External_Device_Type&#39;,
        &#39;Organizational_Unit&#39;,
        &#39;Privileges&#39;,
        &#39;Reputation_Name&#39;,
        &#39;Vulnerability_References&#39;,
        &#39;Web_Domain&#39;,
        &#39;Sub_Status&#39;,
        &#39;Status&#39;,
        &#39;Access_Privileges&#39;,
        &#39;Rule_Name&#39;,
        &#39;App_Layer_Protocol&#39;,
        &#39;Group_Name&#39;,
        &#39;Authentication_Type&#39;,
        &#39;New_Value&#39;,
        &#39;Old_Value&#39;,
        &#39;Security_ID&#39;,
        &#39;SHA1&#39;,
        &#39;Reputation_Score&#39;,
        &#39;Parent_File_Hash&#39;,
        &#39;File_ID&#39;,
        &#39;Engine_List&#39;,
        &#39;Device_URL&#39;,
        &#39;Attacker_IP&#39;,
        &#39;Victim_IP&#39;,
        &#39;Incident_ID&#39;,
        &#39;Attribute_Type&#39;,
        &#39;Access_Mask&#39;,
        &#39;Object_GUID&#39;,
        &#39;VPN_Feature_Name&#39;,
        &#39;Reputation_Server_IP&#39;,
        &#39;DNS_Server_IP&#39;,
        &#39;Hash_Type&#39;,
        &#39;Hash&#39;,
        &#39;Subcategory&#39;,
        &#39;Wireless_SSID&#39;,
        &#39;Share_Name&#39;,
        &#39;CnC_Host&#39;,
        &#39;Device_Confidence&#39;,
        &#39;SHA256&#39;,
        &#39;DSIDSigID&#39;,
        &#39;ZoneSrc&#39;,
        &#39;Action&#39;,
        &#39;ASNGeoDst&#39;,
        &#39;FirstTime&#39;,
        &#39;SrcPort&#39;,
        &#39;AvgSeverity&#39;,
        &#39;DSID&#39;,
        &#39;DstPort&#39;,
        &#39;SrcIP&#39;,
        &#39;ZoneDst&#39;,
        &#39;SigID&#39;,
        &#39;GUIDSrc&#39;,
        &#39;GUIDDst&#39;,
        &#39;DstIP&#39;,
        &#39;ID&#39;,
        &#39;Protocol&#39;,
        &#39;NormID&#39;,
        &#39;SrcMac&#39;,
        &#39;SessionID&#39;,
        &#39;ASNGeoSrc&#39;,
        &#39;DstMac&#39;,
        &#39;LastTime&#39;]
    &#34;&#34;&#34; List fo documented filter names, show a warning if trying to filter on a unknown filter name &#34;&#34;&#34;

    def __init__(self, name, values, operator=&#39;IN&#39;) :
        super().__init__()

        #Declaring attributes
        self._operator=str()
        self._values=list()
        
        self.operator = operator
        self.values = values

        self.name = name
        &#34;&#34;&#34;
        Name of the field
        &#34;&#34;&#34;

        self.data={
            &#34;type&#34;: &#34;EsmFieldFilter&#34;,
            &#34;field&#34;: {&#34;name&#34;: self.name},
            &#34;operator&#34;: self.operator,
            &#34;values&#34;: self.values
            }
        
        # check the name against the list of possible filters and log warning if not present.  
        if name not in FieldFilter.DOCUMENTED_FILTERS :
            log.warning(&#34;You&#39;re using an undocumented filter name: &#39;{name}&#39;.  &#34;.format(name=name))
    
    POSSIBLE_OPERATORS=[&#39;IN&#39;,
        &#39;NOT_IN&#39;,
        &#39;GREATER_THAN&#39;,
        &#39;LESS_THAN&#39;,
        &#39;GREATER_OR_EQUALS_THAN&#39;,
        &#39;LESS_OR_EQUALS_THAN&#39;,
        &#39;NUMERIC_EQUALS&#39;,
        &#39;NUMERIC_NOT_EQUALS&#39;,
        &#39;DOES_NOT_EQUAL&#39;,
        &#39;EQUALS&#39;,
        &#39;CONTAINS&#39;,
        &#39;DOES_NOT_CONTAIN&#39;,
        &#39;REGEX&#39;]
    &#34;&#34;&#34;List of possibles operators&#34;&#34;&#34;

    POSSIBLE_VALUE_TYPES=[
            {&#39;type&#39;:&#39;EsmWatchlistValue&#39;,    &#39;key&#39;:&#39;watchlist&#39;},
            {&#39;type&#39;:&#39;EsmVariableValue&#39;,     &#39;key&#39;:&#39;variable&#39;},
            {&#39;type&#39;:&#39;EsmBasicValue&#39;,        &#39;key&#39;:&#39;value&#39;},
            {&#39;type&#39;:&#39;EsmCompoundValue&#39;,     &#39;key&#39;:&#39;values&#39;}]
    &#34;&#34;&#34;
    List of possible value type. See `msiempy.event.FieldFilter.add_value`.
    &#34;&#34;&#34;

    @property
    def operator(self):
        &#34;&#34;&#34;Filter operator.  
        Throws `AttributeError` if trying to set an unknown operator.  
        &#34;&#34;&#34;
        return (self._operator)
    
    @operator.setter
    def operator(self, operator):
        if operator in self.POSSIBLE_OPERATORS :
            self._operator = operator
        else:
            raise AttributeError(&#34;Illegal value for the filter operator: &#34;+str(operator)+&#34;. The operator must be in &#34;+str(self.POSSIBLE_OPERATORS))

    @property
    def values(self):
        &#34;&#34;&#34;List of values of the filter.  
        Setter iterate trough the list and call : 

        - `msiempy.event.FieldFilter.add_value()` if value is a `dict`
        - `msiempy.event.FieldFilter.add_basic_value()` if value type is `int`, `float` or `str`.

        Values will always be added to the filter. To remove values, handle directly the `_values` property.

        Example :  
            `filter = FieldFilter(name=&#39;DstIP&#39;,values=[{&#39;type&#39;:&#39;EsmWatchlistValue&#39;, &#39;watchlist&#39;:42}], operator=&#39;IN&#39;)`
        &#34;&#34;&#34;
        return (self._values)

    @values.setter  
    def values(self, values):
        if isinstance(values, list): 

            for val in values :
                if isinstance(val, dict):
                    self.add_value(**val)

                elif isinstance(val, (int, float, str)) :
                    self.add_basic_value(val)

                else:
                    raise TypeError(&#34;Invalid filter type, must be a list, int, float or str&#34;)
        
        elif isinstance(values, dict):
            self.add_value(**values)

        elif isinstance(values, (int, float, str)) :
            self.add_basic_value(values)
        
        else :
            raise TypeError(&#34;Invalid filter type, must be a list, int, float or str&#34;)
        
    def add_value(self, type=None, **kwargs):
        &#34;&#34;&#34;
        Add a new value to the filter.  
        
        Arguments (`**kwargs` depends on the value `type`):  

        - `type` (`str`) : Type of the value    

        Dynamic arguments:  
        
        - `value` (`str`) : If `type` is `EsmBasicValue`  
        - `watchlist` (`int`) : if `type` is `EsmWatchlistValue`    
        - `variable` (`int`) if `type` is `EsmVariableValue`    
        - `values` (`list`) if `type` is `EsmCompoundValue`  
        
        Raises : `KeyError` or `AttributeError` if you don&#39;t respect the correct type/key/value combo.  
        Note : Filtering query with other type of filter than `EsmBasicValue` is not tested.
        &#34;&#34;&#34;
        try:
            type_template=None
            
            #Look for the type of the object ex EsmBasicValue
            # it&#39; used to know the type and name of value parameter we should receive next
            for possible_value_type in self.POSSIBLE_VALUE_TYPES :
                if possible_value_type[&#39;type&#39;] == type :
                    type_template=possible_value_type
                    if type != &#39;EsmBasicValue&#39; :
                        log.warning(&#34;Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.&#34;)                            
                    break

            #Error throwing
            if type_template != None :
                if type_template[&#39;key&#39;] in kwargs :
                    
                    # Adds a new value to a fields filter
                    # Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.
                    value = kwargs[type_template[&#39;key&#39;]]
                    if type == &#39;EsmBasicValue&#39; :
                        value=str(value)
                        #log.debug(&#39;Adding a basic value to filter (&#39;+self.text+&#39;) : &#39;+value)
                    self._values.append({&#39;type&#39;:type, type_template[&#39;key&#39;]:value})
                    #log.debug(&#39;The value was appended to the list: &#39;+str(self))
                    
                #Error throwing
                else: raise KeyError (&#39;The valid key value argument is not present&#39;)
            else: raise KeyError (&#39;Impossible filter&#39;)
        except KeyError as err:
            raise AttributeError(&#34;You must provide a valid named Arguments containing the type and values for this filter. The type/keys must be in &#34;+str(self.POSSIBLE_VALUE_TYPES)+&#34;Can&#39;t be type=&#34;+str(type)+&#39; &#39;+str(kwargs)+&#34;. Additionnal indicator :&#34;+str(err) )

    def add_basic_value(self, value):
        &#34;&#34;&#34;
        Wrapper arround `add_value` method to simply add a `EsmBasicValue`.
        &#34;&#34;&#34;
        self.add_value(type=&#39;EsmBasicValue&#39;, value=value)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="msiempy.event.EventManager"><code class="flex name class">
<span>class <span class="ident">EventManager</span></span>
<span>(</span><span>*args, fields=None, order=None, limit=500, filters=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>List-Like object.<br>
Interface to query and manage events.<br>
Inherits from <code><a title="msiempy.core.query.FilteredQueryList" href="core/query.html#msiempy.core.query.FilteredQueryList">FilteredQueryList</a></code>.
</p>
<p>Arguments:
</p>
<ul>
<li><code>fields</code> : list of strings representing all fields you want to apprear in the Events records.
Get the list of possible fields by calling <code><a title="msiempy.event.EventManager.get_possible_fields" href="#msiempy.event.EventManager.get_possible_fields">EventManager.get_possible_fields()</a></code> method or see <code><a title="msiempy.event.Event" href="#msiempy.event.Event">Event</a></code>.
Some default fields will be present. </li>
<li><code>order</code> : <code>tuple ((direction, field))</code>. Direction can be 'ASCENDING' or 'DESCENDING'.</li>
<li><code>limit</code> : max number of rows per query.</li>
<li><code>filters</code> : list of filters. A filter can be a <code>tuple(field, [values])</code> or it can be a <code><a title="msiempy.event.FieldFilter" href="#msiempy.event.FieldFilter">FieldFilter</a></code> or <code><a title="msiempy.event.GroupFilter" href="#msiempy.event.GroupFilter">GroupFilter</a></code> if you wish to use advanced filtering.</li>
<li><code>time_range</code> : Query time range. String representation of a time range. Not need to specify 'CUSTOM' if <code>start_time</code> and <code>end_time</code> are set.
</li>
<li><code>start_time</code> : Query start time, can be a <code>string</code> or a <code>datetime</code> object. Parsed with <code>dateutil</code>.
</li>
<li><code>end_time</code> : Query end time, can be a <code>string</code> or a <code>datetime</code> object. Parsed with <code>dateutil</code>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L21-L380" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class EventManager(FilteredQueryList):
    &#34;&#34;&#34;
    List-Like object.  
    Interface to query and manage events.  
    Inherits from `msiempy.core.query.FilteredQueryList`.  

    Arguments:  

    - `fields` : list of strings representing all fields you want to apprear in the Events records.
        Get the list of possible fields by calling `msiempy.event.EventManager.get_possible_fields()` method or see `msiempy.event.Event`.
        Some default fields will be present. 
    - `order` : `tuple ((direction, field))`. Direction can be &#39;ASCENDING&#39; or &#39;DESCENDING&#39;.
    - `limit` : max number of rows per query.
    - `filters` : list of filters. A filter can be a `tuple(field, [values])` or it can be a `msiempy.event.FieldFilter` or `msiempy.event.GroupFilter` if you wish to use advanced filtering.
    - `time_range` : Query time range. String representation of a time range. Not need to specify &#39;CUSTOM&#39; if `start_time` and `end_time` are set.  
    - `start_time` : Query start time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  
    - `end_time` : Query end time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  
    &#34;&#34;&#34; 

    #Constants
    #TODO Try grouped queries !
    _TYPE=&#39;EVENT&#39;
    &#34;&#34;&#34;`EVENT`: Flow query or other are not implemented&#34;&#34;&#34;
    _GROUPTYPE=&#39;NO_GROUP&#39;
    &#34;&#34;&#34;`NO_GROUP`: Grouped query is not implemented&#34;&#34;&#34;
    POSSBILE_ROW_ORDER=[
            &#39;ASCENDING&#39;,
            &#39;DESCENDING&#39;
    ]
    &#34;&#34;&#34;`ASCENDING` or `DESCENDING`&#34;&#34;&#34;

    def __init__(self, *args, fields=None, 
        order=None, limit=500, filters=None, 
        __parent__=None, **kwargs):
        #Calling super constructor : time_range set etc...
        super().__init__(*args, **kwargs)

        #Store the query parent 
        self.__parent__=__parent__

        #Declaring attributes
        self._filters=list()
        
        #Setting the default fields Adds the specified fields, make sure there is no duplicates and delete TABLE identifiers
        if fields and len(fields)&gt;0: 
            all_keys=Event.DEFAULTS_EVENT_FIELDS+list(fields)
            uniquekeys=set()
            for k in all_keys:
                if k in Event.SIEM_FIELDS_MAP_INTERNAL_NAME_TO_NICKNAME:
                    uniquekeys.add(Event.SIEM_FIELDS_MAP_INTERNAL_NAME_TO_NICKNAME[k])
                else: uniquekeys.add(k)
            self.fields=list(uniquekeys)
        else: 
            self.fields=Event.DEFAULTS_EVENT_FIELDS
        #log.debug(&#39;{}\nFIELDS : {}&#39;.format(locals(), self.fields))

        #Setting limit according to config or limit argument
        #TODO Try to load queries with a limit of 10k and get result as chucks of 500 with starPost nbRows
        #   and compare efficiency
        self.limit=int(limit)
        
        # Save order
        self.order=order
            
        #TODO : find a solution not to use this
        #callign super().filters=filters #https://bugs.python.org/issue14965
        super(self.__class__, self.__class__).filters.__set__(self, filters)

        #Type cast all items in the list &#34;data&#34; to events type objects
        #Casting all data to Event objects, better way to do it ?
        collections.UserList.__init__(self, [Event(adict=item) for item in self.data if isinstance(item, (dict, NitroDict))])

    @property
    def order(self):
        &#34;&#34;&#34;
        The `order` is a `tuple (direction, field)`.  
        Default value is `(DESCENDING, LastTime)`.  
        &#34;&#34;&#34;
        return((self._order_direction, self._order_field))

    @order.setter
    def order(self, order):
        if order:
            try:
                if order[0] not in self.POSSBILE_ROW_ORDER :
                    raise AttributeError(&#39;Order direction must be in &#39;+str(self.POSSBILE_ROW_ORDER))

                self._order_direction = order[0]
                self._order_field = order[1]
            except IndexError:
                raise ValueError(&#39;Order must be tuple (direction, field).&#39;)
        else:
            self._order_direction = &#39;DESCENDING&#39;
            self._order_field = &#39;LastTime&#39;

    @property
    def filters(self):
        &#34;&#34;&#34;
        Returns SIEM formatted filters for the query structured from `msiempy.event.GroupFilter` and/or `msiempy.event.FieldFilter`
        See `msiempy.core.query.FilteredQueryList.filters`.
        &#34;&#34;&#34;
        return([dict(f) for f in self._filters])

    def add_filter(self, afilter):
        &#34;&#34;&#34;
        Add a filter to the query.  
        Argument must be a `tuple(field, [values])` or `(field, value)` or `msiempy.event.GroupFilter` or `msiempy.event.FieldFilter`.  
        &#34;&#34;&#34;
        if isinstance(afilter, tuple) :
            self._filters.append(FieldFilter(afilter[0], afilter[1]))

        elif isinstance(afilter, (GroupFilter, FieldFilter, dict)) :
            self._filters.append(afilter)

        else :
            raise TypeError(&#34;Sorry, filters must be either a tuple a GroupFilter, a FieldFilter or a dict. Not {}&#34;.format(afilter))

    def clear_filters(self):
        &#34;&#34;&#34;
        Replace all filters by a non filtering rule.  
        Acts like there is not filters.  
        &#34;&#34;&#34; 
        self._filters=[{
            &#34;type&#34;: &#34;EsmFieldFilter&#34;,
            &#34;field&#34;: {&#34;name&#34;: &#39;SrcIP&#39;},
            &#34;operator&#34;: &#39;IN&#39;,
            &#34;values&#34;: [{&#39;type&#39;:&#39;EsmBasicValue&#39;, &#39;value&#39;:&#39;0.0.0.0/0&#39;}]
            }]


    def qry_load_data(self, retry=1, wait_timeout_sec=120):
        &#34;&#34;&#34;
        Helper method to execute the query and load the data :  
            -&gt; Submit the query  
            -&gt; Wait the query to be executed  
            -&gt; Get and parse the events  

        Arguments:

        - `retry` (`int`): number of time the query can be failed and retried.
            Retries only when &#39;ResultUnavailable&#39;,&#39;UnknownList&#39; or &#39;JobEngine_GetQueryResults_QueryNotFound_Unrecoverable&#39; errors.  
        - `wait_timeout_sec` (`int`): wait timeout in seconds

        Returns : `tuple` : (( `msiempy.event.EventManager`, Query completed? `True/False` ))

        Raises `msiempy.core.session.NitroError` if any unhandled errors.  
        Raises `TimeoutError` if wait_timeout_sec counter gets to 0.  
        &#34;&#34;&#34;
        try:
            query_infos=dict()

            #Queries api calls are very different if the time range is custom.
            if self.time_range == &#39;CUSTOM&#39; :
                query_infos=self.nitro.request(
                    &#39;event_query_custom_time&#39;,
                    time_range=self.time_range,
                    start_time=self.start_time,
                    end_time=self.end_time,
                    order_direction=self._order_direction,
                    order_field=self._order_field,
                    fields=format_fields_for_query(self.fields),
                    filters=self.filters,
                    limit=self.limit,
                    offset=0,
                    includeTotal=False
                    )

            else :
                query_infos=self.nitro.request(
                    &#39;event_query&#39;,
                    time_range=self.time_range,
                    order_direction=self._order_direction,
                    order_field=self._order_field,
                    fields=format_fields_for_query(self.fields),
                    filters=self.filters,
                    limit=self.limit,
                    offset=0,
                    includeTotal=False
                    )
            
            log.debug(&#34;Waiting for EsmRunningQuery object : &#34;+str(query_infos))
        
            self._wait_for(query_infos[&#39;resultID&#39;], wait_timeout_sec)
            events_raw=self._get_events(query_infos[&#39;resultID&#39;])

        except (NitroError, TimeoutError) as error :
            # if (retry &gt;0 and ( any(match in str(error) for match in [
            #         &#39;ResultUnavailable&#39;,
            #         &#39;ERROR_JEC_ResponseNotAvailable&#39;,
            #         &#39;UnknownList&#39;,
            #         &#39;JobEngine_GetQueryResults_QueryNotFound_Unrecoverable&#39;]) 
            #     or isinstance(error, TimeoutError)) ):
            if retry &gt; 0:
                log.warning(&#39;Retring qry_load_data() after error: &#39;+str(error))
                time.sleep(1)
                return self.qry_load_data(retry=retry-1)
            else: raise

        return((events_raw,len(events_raw)&lt;self.limit))

    def load_data(self, workers=10, slots=10, delta=None, max_query_depth=0, **kwargs):
        &#34;&#34;&#34;
        Load the data into the list.  
        Split the query in defferents time slots if the query apprears not to be completed.  
        Wraps around `msiempy.event.EventManager.qry_load_data`.    

        Note: Only the first query is loaded asynchronously.

        Arguments:  
    
        - `workers` : numbre of parrallels tasks, should be equal or less than the number of slots.  
        - `slots` : number of time slots the query can be divided. The loading bar is 
            divided according to the number of slots  
        - `delta` : exemple : &#39;6h30m&#39;, the query will be firstly divided in chuncks according to the time delta read
            with dateutil.  
        - `max_query_depth` : maximum number of reccursive divisions the query before to . 
        Meaning, if EventManager query `limit=500`, `slots=5 `and `max_query_depth=3`, then the maximum capacity of 
        the list is `(500*5)*(500*5)*(500*5)` = `15625000000`.  Only works for certain time ranges.  
        - `retry` (`int`): number of time the query can be failed and retried
        - `wait_timeout_sec` (`int`): wait timeout in seconds

        Returns : `msiempy.event.EventManager`
        &#34;&#34;&#34;

        items, completed = self.qry_load_data()

        if not completed :
            #If not completed the query is split and items aren&#39;t actually used

            if max_query_depth &gt; 0 :
                #log.info(&#34;The query data couldn&#39;t be loaded in one request, separating it in sub-queries...&#34;)

                if self.time_range != &#39;CUSTOM&#39;: #can raise a NotImplementedError if unsupported time_range
                    start, end = timerange_gettimes(self.time_range)
                else :
                    start, end = self.start_time, self.end_time

                if self.__parent__ == None and isinstance(delta, str) :
                    #if it&#39;s the first query and delta is speficied, cut the time_range in slots according to the delta
                    times=divide_times(start, end, delta=parse_timedelta(delta))
                    
                else : 
                    times=divide_times(start, end, slots=slots)

                if workers &gt; len(times) :
                    log.warning(&#34;The numbre of slots is smaller than the number of workers, only &#34;+str(len(times))+&#34; asynch workers will be used when you could use up to &#34;+str(workers)+&#34;. Number of slots should be greater than the number of workers for better performance.&#34;)
                
                sub_queries=list()

                for time in times : #reversed(times) :
                    #Divide the query in sub queries
                    sub_query = EventManager(fields=self.fields, 
                        order=self.order, 
                        limit=self.limit,
                        filters=self._filters,
                        time_range=&#39;CUSTOM&#39;,
                        start_time=time[0].isoformat(),
                        end_time=time[1].isoformat(),

                         __parent__=self
                        )
                    
                    sub_queries.append(sub_query)
            
                results = self.perform(EventManager.load_data, sub_queries, 
                    #The sub query is asynch only when it&#39;s the first query (root parent)
                    asynch=self.__parent__==None,
                    progress=self.__parent__==None, 
                    message=&#39;Loading data from &#39;+start+&#39; to &#39;+end+&#39;. In {} slots&#39;.format(len(times)),
                    func_args=dict(slots=slots, max_query_depth=max_query_depth-1),
                    workers=workers)

                #Flatten the list of lists in a list
                items=[item for sublist in results for item in sublist]
                
            else :
                if not self.__root_parent__.not_completed :
                    log.warning(&#34;The query is not complete... Try to divide in more slots or increase the limit&#34;)
                    self.__root_parent__.not_completed=True
        
        events=[Event(adict=item) for item in items]
        self.data=events
        return(self)

    def _wait_for(self, resultID, wait_timeout_sec, sleep_time=0.2):
        &#34;&#34;&#34;
        Internal method called by qry_load_data
        Wait and sleep - for `sleep_time` duration in seconds -
            until the query is completed or retry countdown arrives at zero.    
        
        Return: `True`  

        Raises: 

        - `msiempy.NitroError`: &#39;ResultUnavailable&#39; error some times...
        - `TimeoutError`: Query wait timeout
        &#34;&#34;&#34;

        begin=datetime.now()
        timeout_delta=timedelta(seconds=wait_timeout_sec)

        log.debug(&#34;Waiting for the query to be executed on the SIEM...&#34;)
        
        while datetime.now()-timeout_delta &lt; begin :
            status = self.nitro.request(&#39;query_status&#39;, resultID=resultID)
            if status[&#39;complete&#39;] is True :
                return True
            else :
                time.sleep(sleep_time)
        raise TimeoutError(&#34;Query wait timeout. resultID={}, sleep_time={}, wait_timeout_sec={}&#34;.format(
            resultID, sleep_time, wait_timeout_sec))

    def _get_events(self, resultID, startPos=0, numRows=None):
        &#34;&#34;&#34;
        Internal method that will get the query events, 
            called by qry_load_data
        by default, numRows correspond to limit
        &#34;&#34;&#34;
        
        if not numRows :
            numRows=self.limit
                
        result=self.nitro.request(&#39;query_result&#39;,
            startPos=startPos,
            numRows=numRows,
            resultID=resultID)

        #Calls a utils function to parse the [columns][rows]
        #   to format into list of dict
        #log.debug(&#34;Parsing colums : &#34;+str(result[&#39;columns&#39;]))
        #log.debug(&#34;Parsing rows : &#34;+str(result[&#39;rows&#39;]))
        if len(result[&#39;columns&#39;]) != len(set([column[&#39;name&#39;] for column in result[&#39;columns&#39;]])) :
            log.error(&#34;You requested duplicated fields, the parsed fields/values results will be missmatched !&#34;)
        events=parse_query_result(result[&#39;columns&#39;], result[&#39;rows&#39;])
        #log.debug(&#34;Events parsed : &#34;+str(events))
        return events

    @property
    def __root_parent__(self):
        &#34;&#34;&#34;
        Internal method that return the first query of the query tree
        &#34;&#34;&#34;
        if self.__parent__==None:
            return self
        else :
            return self.__parent__.__root_parent__

    def get_possible_fields(self):
        &#34;&#34;&#34;
        Return the list of possible fields that you can request in a query.  
        The list is loaded from the SIEM.  
        &#34;&#34;&#34;
        return self.nitro.request(&#39;get_possible_fields&#39;, type=self._TYPE, groupType=self._GROUPTYPE)

    def get_possible_filters(self):
        &#34;&#34;&#34;
        Return the list of possible fields that you can use as a filter in a query.  
        The list is loaded from the SIEM.  
        &#34;&#34;&#34;
        return(self.nitro.request(&#39;get_possible_filters&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="msiempy.core.query.FilteredQueryList" href="core/query.html#msiempy.core.query.FilteredQueryList">FilteredQueryList</a></li>
<li><a title="msiempy.core.types.NitroList" href="core/types.html#msiempy.core.types.NitroList">NitroList</a></li>
<li>collections.UserList</li>
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="msiempy.core.types.NitroObject" href="core/types.html#msiempy.core.types.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.event.EventManager.POSSBILE_ROW_ORDER"><code class="name">var <span class="ident">POSSBILE_ROW_ORDER</span></code></dt>
<dd>
<div class="desc"><p><code>ASCENDING</code> or <code>DESCENDING</code></p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.event.EventManager.order"><code class="name">var <span class="ident">order</span></code></dt>
<dd>
<div class="desc"><p>The <code>order</code> is a <code>tuple (direction, field)</code>.<br>
Default value is <code>(DESCENDING, LastTime)</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L93-L99" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def order(self):
    &#34;&#34;&#34;
    The `order` is a `tuple (direction, field)`.  
    Default value is `(DESCENDING, LastTime)`.  
    &#34;&#34;&#34;
    return((self._order_direction, self._order_field))</code></pre>
</details>
</dd>
<dt id="msiempy.event.EventManager.filters"><code class="name">var <span class="ident">filters</span></code></dt>
<dd>
<div class="desc"><p>Returns SIEM formatted filters for the query structured from <code><a title="msiempy.event.GroupFilter" href="#msiempy.event.GroupFilter">GroupFilter</a></code> and/or <code><a title="msiempy.event.FieldFilter" href="#msiempy.event.FieldFilter">FieldFilter</a></code>
See <code><a title="msiempy.core.query.FilteredQueryList.filters" href="core/query.html#msiempy.core.query.FilteredQueryList.filters">FilteredQueryList.filters</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L116-L122" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def filters(self):
    &#34;&#34;&#34;
    Returns SIEM formatted filters for the query structured from `msiempy.event.GroupFilter` and/or `msiempy.event.FieldFilter`
    See `msiempy.core.query.FilteredQueryList.filters`.
    &#34;&#34;&#34;
    return([dict(f) for f in self._filters])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.event.EventManager.add_filter"><code class="name flex">
<span>def <span class="ident">add_filter</span></span>(<span>self, afilter)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a filter to the query.<br>
Argument must be a <code>tuple(field, [values])</code> or <code>(field, value)</code> or <code><a title="msiempy.event.GroupFilter" href="#msiempy.event.GroupFilter">GroupFilter</a></code> or <code><a title="msiempy.event.FieldFilter" href="#msiempy.event.FieldFilter">FieldFilter</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L124-L136" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_filter(self, afilter):
    &#34;&#34;&#34;
    Add a filter to the query.  
    Argument must be a `tuple(field, [values])` or `(field, value)` or `msiempy.event.GroupFilter` or `msiempy.event.FieldFilter`.  
    &#34;&#34;&#34;
    if isinstance(afilter, tuple) :
        self._filters.append(FieldFilter(afilter[0], afilter[1]))

    elif isinstance(afilter, (GroupFilter, FieldFilter, dict)) :
        self._filters.append(afilter)

    else :
        raise TypeError(&#34;Sorry, filters must be either a tuple a GroupFilter, a FieldFilter or a dict. Not {}&#34;.format(afilter))</code></pre>
</details>
</dd>
<dt id="msiempy.event.EventManager.clear_filters"><code class="name flex">
<span>def <span class="ident">clear_filters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace all filters by a non filtering rule.<br>
Acts like there is not filters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L138-L148" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clear_filters(self):
    &#34;&#34;&#34;
    Replace all filters by a non filtering rule.  
    Acts like there is not filters.  
    &#34;&#34;&#34; 
    self._filters=[{
        &#34;type&#34;: &#34;EsmFieldFilter&#34;,
        &#34;field&#34;: {&#34;name&#34;: &#39;SrcIP&#39;},
        &#34;operator&#34;: &#39;IN&#39;,
        &#34;values&#34;: [{&#39;type&#39;:&#39;EsmBasicValue&#39;, &#39;value&#39;:&#39;0.0.0.0/0&#39;}]
        }]</code></pre>
</details>
</dd>
<dt id="msiempy.event.EventManager.qry_load_data"><code class="name flex">
<span>def <span class="ident">qry_load_data</span></span>(<span>self, retry=1, wait_timeout_sec=120)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper method to execute the query and load the data :<br>
-&gt; Submit the query<br>
-&gt; Wait the query to be executed<br>
-&gt; Get and parse the events
</p>
<p>Arguments:</p>
<ul>
<li><code>retry</code> (<code>int</code>): number of time the query can be failed and retried.
Retries only when 'ResultUnavailable','UnknownList' or 'JobEngine_GetQueryResults_QueryNotFound_Unrecoverable' errors.
</li>
<li><code>wait_timeout_sec</code> (<code>int</code>): wait timeout in seconds</li>
</ul>
<p>Returns : <code>tuple</code> : (( <code><a title="msiempy.event.EventManager" href="#msiempy.event.EventManager">EventManager</a></code>, Query completed? <code>True/False</code> ))</p>
<p>Raises <code><a title="msiempy.core.session.NitroError" href="core/session.html#msiempy.core.session.NitroError">NitroError</a></code> if any unhandled errors.<br>
Raises <code>TimeoutError</code> if wait_timeout_sec counter gets to 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L151-L219" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def qry_load_data(self, retry=1, wait_timeout_sec=120):
    &#34;&#34;&#34;
    Helper method to execute the query and load the data :  
        -&gt; Submit the query  
        -&gt; Wait the query to be executed  
        -&gt; Get and parse the events  

    Arguments:

    - `retry` (`int`): number of time the query can be failed and retried.
        Retries only when &#39;ResultUnavailable&#39;,&#39;UnknownList&#39; or &#39;JobEngine_GetQueryResults_QueryNotFound_Unrecoverable&#39; errors.  
    - `wait_timeout_sec` (`int`): wait timeout in seconds

    Returns : `tuple` : (( `msiempy.event.EventManager`, Query completed? `True/False` ))

    Raises `msiempy.core.session.NitroError` if any unhandled errors.  
    Raises `TimeoutError` if wait_timeout_sec counter gets to 0.  
    &#34;&#34;&#34;
    try:
        query_infos=dict()

        #Queries api calls are very different if the time range is custom.
        if self.time_range == &#39;CUSTOM&#39; :
            query_infos=self.nitro.request(
                &#39;event_query_custom_time&#39;,
                time_range=self.time_range,
                start_time=self.start_time,
                end_time=self.end_time,
                order_direction=self._order_direction,
                order_field=self._order_field,
                fields=format_fields_for_query(self.fields),
                filters=self.filters,
                limit=self.limit,
                offset=0,
                includeTotal=False
                )

        else :
            query_infos=self.nitro.request(
                &#39;event_query&#39;,
                time_range=self.time_range,
                order_direction=self._order_direction,
                order_field=self._order_field,
                fields=format_fields_for_query(self.fields),
                filters=self.filters,
                limit=self.limit,
                offset=0,
                includeTotal=False
                )
        
        log.debug(&#34;Waiting for EsmRunningQuery object : &#34;+str(query_infos))
    
        self._wait_for(query_infos[&#39;resultID&#39;], wait_timeout_sec)
        events_raw=self._get_events(query_infos[&#39;resultID&#39;])

    except (NitroError, TimeoutError) as error :
        # if (retry &gt;0 and ( any(match in str(error) for match in [
        #         &#39;ResultUnavailable&#39;,
        #         &#39;ERROR_JEC_ResponseNotAvailable&#39;,
        #         &#39;UnknownList&#39;,
        #         &#39;JobEngine_GetQueryResults_QueryNotFound_Unrecoverable&#39;]) 
        #     or isinstance(error, TimeoutError)) ):
        if retry &gt; 0:
            log.warning(&#39;Retring qry_load_data() after error: &#39;+str(error))
            time.sleep(1)
            return self.qry_load_data(retry=retry-1)
        else: raise

    return((events_raw,len(events_raw)&lt;self.limit))</code></pre>
</details>
</dd>
<dt id="msiempy.event.EventManager.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self, workers=10, slots=10, delta=None, max_query_depth=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the data into the list.<br>
Split the query in defferents time slots if the query apprears not to be completed.<br>
Wraps around <code><a title="msiempy.event.EventManager.qry_load_data" href="#msiempy.event.EventManager.qry_load_data">EventManager.qry_load_data()</a></code>.
</p>
<p>Note: Only the first query is loaded asynchronously.</p>
<p>Arguments:
</p>
<ul>
<li><code>workers</code> : numbre of parrallels tasks, should be equal or less than the number of slots.
</li>
<li><code>slots</code> : number of time slots the query can be divided. The loading bar is
divided according to the number of slots
</li>
<li><code>delta</code> : exemple : '6h30m', the query will be firstly divided in chuncks according to the time delta read
with dateutil.
</li>
<li><code>max_query_depth</code> : maximum number of reccursive divisions the query before to .
Meaning, if EventManager query <code>limit=500</code>, <code>slots=5</code>and <code>max_query_depth=3</code>, then the maximum capacity of
the list is <code>(500*5)*(500*5)*(500*5)</code> = <code>15625000000</code>.
Only works for certain time ranges.
</li>
<li><code>retry</code> (<code>int</code>): number of time the query can be failed and retried</li>
<li><code>wait_timeout_sec</code> (<code>int</code>): wait timeout in seconds</li>
</ul>
<p>Returns : <code><a title="msiempy.event.EventManager" href="#msiempy.event.EventManager">EventManager</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L221-L303" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def load_data(self, workers=10, slots=10, delta=None, max_query_depth=0, **kwargs):
    &#34;&#34;&#34;
    Load the data into the list.  
    Split the query in defferents time slots if the query apprears not to be completed.  
    Wraps around `msiempy.event.EventManager.qry_load_data`.    

    Note: Only the first query is loaded asynchronously.

    Arguments:  

    - `workers` : numbre of parrallels tasks, should be equal or less than the number of slots.  
    - `slots` : number of time slots the query can be divided. The loading bar is 
        divided according to the number of slots  
    - `delta` : exemple : &#39;6h30m&#39;, the query will be firstly divided in chuncks according to the time delta read
        with dateutil.  
    - `max_query_depth` : maximum number of reccursive divisions the query before to . 
    Meaning, if EventManager query `limit=500`, `slots=5 `and `max_query_depth=3`, then the maximum capacity of 
    the list is `(500*5)*(500*5)*(500*5)` = `15625000000`.  Only works for certain time ranges.  
    - `retry` (`int`): number of time the query can be failed and retried
    - `wait_timeout_sec` (`int`): wait timeout in seconds

    Returns : `msiempy.event.EventManager`
    &#34;&#34;&#34;

    items, completed = self.qry_load_data()

    if not completed :
        #If not completed the query is split and items aren&#39;t actually used

        if max_query_depth &gt; 0 :
            #log.info(&#34;The query data couldn&#39;t be loaded in one request, separating it in sub-queries...&#34;)

            if self.time_range != &#39;CUSTOM&#39;: #can raise a NotImplementedError if unsupported time_range
                start, end = timerange_gettimes(self.time_range)
            else :
                start, end = self.start_time, self.end_time

            if self.__parent__ == None and isinstance(delta, str) :
                #if it&#39;s the first query and delta is speficied, cut the time_range in slots according to the delta
                times=divide_times(start, end, delta=parse_timedelta(delta))
                
            else : 
                times=divide_times(start, end, slots=slots)

            if workers &gt; len(times) :
                log.warning(&#34;The numbre of slots is smaller than the number of workers, only &#34;+str(len(times))+&#34; asynch workers will be used when you could use up to &#34;+str(workers)+&#34;. Number of slots should be greater than the number of workers for better performance.&#34;)
            
            sub_queries=list()

            for time in times : #reversed(times) :
                #Divide the query in sub queries
                sub_query = EventManager(fields=self.fields, 
                    order=self.order, 
                    limit=self.limit,
                    filters=self._filters,
                    time_range=&#39;CUSTOM&#39;,
                    start_time=time[0].isoformat(),
                    end_time=time[1].isoformat(),

                     __parent__=self
                    )
                
                sub_queries.append(sub_query)
        
            results = self.perform(EventManager.load_data, sub_queries, 
                #The sub query is asynch only when it&#39;s the first query (root parent)
                asynch=self.__parent__==None,
                progress=self.__parent__==None, 
                message=&#39;Loading data from &#39;+start+&#39; to &#39;+end+&#39;. In {} slots&#39;.format(len(times)),
                func_args=dict(slots=slots, max_query_depth=max_query_depth-1),
                workers=workers)

            #Flatten the list of lists in a list
            items=[item for sublist in results for item in sublist]
            
        else :
            if not self.__root_parent__.not_completed :
                log.warning(&#34;The query is not complete... Try to divide in more slots or increase the limit&#34;)
                self.__root_parent__.not_completed=True
    
    events=[Event(adict=item) for item in items]
    self.data=events
    return(self)</code></pre>
</details>
</dd>
<dt id="msiempy.event.EventManager.get_possible_fields"><code class="name flex">
<span>def <span class="ident">get_possible_fields</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of possible fields that you can request in a query.<br>
The list is loaded from the SIEM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L368-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_possible_fields(self):
    &#34;&#34;&#34;
    Return the list of possible fields that you can request in a query.  
    The list is loaded from the SIEM.  
    &#34;&#34;&#34;
    return self.nitro.request(&#39;get_possible_fields&#39;, type=self._TYPE, groupType=self._GROUPTYPE)</code></pre>
</details>
</dd>
<dt id="msiempy.event.EventManager.get_possible_filters"><code class="name flex">
<span>def <span class="ident">get_possible_filters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of possible fields that you can use as a filter in a query.<br>
The list is loaded from the SIEM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L375-L380" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_possible_filters(self):
    &#34;&#34;&#34;
    Return the list of possible fields that you can use as a filter in a query.  
    The list is loaded from the SIEM.  
    &#34;&#34;&#34;
    return(self.nitro.request(&#39;get_possible_filters&#39;))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.core.query.FilteredQueryList" href="core/query.html#msiempy.core.query.FilteredQueryList">FilteredQueryList</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.core.query.FilteredQueryList.NitroJSONEncoder" href="core/types.html#msiempy.core.types.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.end_time" href="core/query.html#msiempy.core.query.FilteredQueryList.end_time">end_time</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.get_text" href="core/types.html#msiempy.core.types.NitroList.get_text">get_text</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.json" href="core/types.html#msiempy.core.types.NitroList.json">json</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.keys" href="core/types.html#msiempy.core.types.NitroList.keys">keys</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.nitro" href="core/types.html#msiempy.core.types.NitroObject.nitro">nitro</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.perform" href="core/types.html#msiempy.core.types.NitroList.perform">perform</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.refresh" href="core/types.html#msiempy.core.types.NitroList.refresh">refresh</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.search" href="core/types.html#msiempy.core.types.NitroList.search">search</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.start_time" href="core/query.html#msiempy.core.query.FilteredQueryList.start_time">start_time</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.text" href="core/types.html#msiempy.core.types.NitroList.text">text</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.time_range" href="core/query.html#msiempy.core.query.FilteredQueryList.time_range">time_range</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="msiempy.event.Event"><code class="flex name class">
<span>class <span class="ident">Event</span></span>
<span>(</span><span>adict=None, id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Dict-Like object.
</p>
<p>Event interface.
This object handles events objects created with <code><a title="msiempy.event.EventManager" href="#msiempy.event.EventManager">EventManager</a></code> (From the <code>qryGetResults</code> api call)
and events objects created with <code><a title="msiempy.alarm.AlarmManager" href="alarm.html#msiempy.alarm.AlarmManager">AlarmManager</a></code> (From <code>ipsGetAlertData</code> api call or <code>notifyGetTriggeredNotificationDetail</code> depending of the value of <code>load_data(events_details=True/False)</code> ) .
</p>
<p>Common keys for alert data events (When loading from ID or with <code>AlarmManager.load_data(events_details=False)</code> :
</p>
<ul>
<li><code>ruleName</code></li>
<li><code>srcIp</code></li>
<li><code>destIp</code></li>
<li><code>protocol</code></li>
<li><code>lastTime</code></li>
<li><code>subtype</code></li>
<li><code>destPort</code></li>
<li><code>destMac</code></li>
<li><code>srcMac</code></li>
<li><code>srcPort</code></li>
<li><code>deviceName</code></li>
<li><code>sigId</code></li>
<li><code>normId</code></li>
<li><code>srcUser</code></li>
<li><code>destUser</code></li>
<li><code>normMessage</code></li>
<li><code>normDesc</code></li>
<li><code>host</code></li>
<li><code>domain</code></li>
<li><code>ipsId</code></li>
</ul>
<p>Common keys for triggered alarms events (When <code>AlarmManager.load_data(events_details=False)</code>):<br>
- <code>ruleMessage</code><br>
- <code>eventId</code><br>
- <code>severity</code><br>
- <code>eventCount</code><br>
- <code>sourceIp</code><br>
- <code>destIp</code><br>
- <code>protocol</code><br>
- <code>lastTime</code><br>
- <code>eventSubType</code>
</p>
<p>Common keys for query events (When using <code><a title="msiempy.event.EventManager" href="#msiempy.event.EventManager">EventManager</a></code>):
</p>
<ul>
<li><code>Rule.msg</code>
</li>
<li><code>Alert.LastTime</code>
</li>
<li><code>Alert.IPSIDAlertID</code>
</li>
<li>and any other&hellip;
</li>
</ul>
<p>You can request more fields by passing a list of fields to the <code><a title="msiempy.event.EventManager" href="#msiempy.event.EventManager">EventManager</a></code> object.
<code><a title="msiempy.event.Event.REGULAR_EVENT_FIELDS" href="#msiempy.event.Event.REGULAR_EVENT_FIELDS">Event.REGULAR_EVENT_FIELDS</a></code> offer a base list of regular fields that may be useful.
See msiempy/static JSON files to browse complete list : <a href="https://github.com/mfesiem/msiempy/blob/master/static/all_fields.json">https://github.com/mfesiem/msiempy/blob/master/static/all_fields.json</a><br>
You can also use this script to dinamically print the available fields and filters : <a href="https://github.com/mfesiem/msiempy/blob/master/samples/dump_all_fields.py">https://github.com/mfesiem/msiempy/blob/master/samples/dump_all_fields.py</a>
</p>
<p>Arguments:</p>
<ul>
<li><code>adict</code>: Event parameters
</li>
<li><code>id</code>: The event <code>IPSIDAlertID</code> to instanciate. Will load informations</li>
</ul>
<p><strong>For query events</strong>: We tried our best effort to match SIEM returned fields with initially requested fields.
Prefixes <code>Alert.</code>, <code>Rule.</code>, etc are optionnal, autocompletion is computed in any case.
<br>
<code>__getitem__</code>, <code>__contains__</code>, <code>__setitem__</code> and <code>__delitem__</code> method have been rewrote in order to offer more straight-forward <code>dict</code> usage.
For exemple, if the SIEM returns results with keys like
<code>Alert.65613</code>, <code>Alert.BIN(7)</code> or <code>Alert.SrcIP</code>: you'll be able to use <code><a title="msiempy.event.Event" href="#msiempy.event.Event">Event</a></code> dict with your initial
queried keys like <code>Event['Web_Doamin']</code>, <code>Event['UserIDSrc']</code> or <code>Event['SrcIP']</code>. (You can still use internal keys if you want).
</p>
<p>Exemple:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L382-L1230" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Event(NitroDict):
    &#34;&#34;&#34;
    Dict-Like object.   

    Event interface.
    This object handles events objects created with `msiempy.event.EventManager` (From the `qryGetResults` api call) 
        and events objects created with `msiempy.alarm.AlarmManager` (From `ipsGetAlertData` api call or `notifyGetTriggeredNotificationDetail` depending of the value of `load_data(events_details=True/False)` ) .  

    Common keys for alert data events (When loading from ID or with `AlarmManager.load_data(events_details=False)` :  

    - `ruleName`
    - `srcIp`
    - `destIp`
    - `protocol`
    - `lastTime`
    - `subtype`
    - `destPort`
    - `destMac`
    - `srcMac`
    - `srcPort`
    - `deviceName`
    - `sigId`
    - `normId`
    - `srcUser`
    - `destUser`
    - `normMessage`
    - `normDesc`
    - `host`
    - `domain`
    - `ipsId`

    Common keys for triggered alarms events (When `AlarmManager.load_data(events_details=False)`):  
    - `ruleMessage`  
    - `eventId`  
    - `severity`  
    - `eventCount`  
    - `sourceIp`  
    - `destIp`  
    - `protocol`  
    - `lastTime`  
    - `eventSubType`  

    Common keys for query events (When using `EventManager`):  

    - `Rule.msg`  
    - `Alert.LastTime`  
    - `Alert.IPSIDAlertID`  
    - and any other...  

    You can request more fields by passing a list of fields to the `msiempy.event.EventManager` object. 
    `msiempy.event.Event.REGULAR_EVENT_FIELDS` offer a base list of regular fields that may be useful.
    See msiempy/static JSON files to browse complete list : https://github.com/mfesiem/msiempy/blob/master/static/all_fields.json  
    You can also use this script to dinamically print the available fields and filters : https://github.com/mfesiem/msiempy/blob/master/samples/dump_all_fields.py  

    Arguments:

    - `adict`: Event parameters  
    - `id`: The event `IPSIDAlertID` to instanciate. Will load informations

    **For query events**: We tried our best effort to match SIEM returned fields with initially requested fields.  Prefixes `Alert.`, `Rule.`, etc are optionnal, autocompletion is computed in any case.    
    `__getitem__`, `__contains__`, `__setitem__` and `__delitem__` method have been rewrote in order to offer more straight-forward `dict` usage.
    For exemple, if the SIEM returns results with keys like  `Alert.65613`, `Alert.BIN(7)` or `Alert.SrcIP`: you&#39;ll be able to use `Event` dict with your initial 
    queried keys like `Event[&#39;Web_Doamin&#39;] `, `Event[&#39;UserIDSrc&#39;]` or `Event[&#39;SrcIP&#39;]`. (You can still use internal keys if you want).   

    Exemple:  

        

    &#34;&#34;&#34;
   
    FIELDS_TABLES=[
        &#34;Alert&#34;,
        &#34;Rule&#34;,
        &#34;ADGroup&#34;,
        &#34;Action&#34;,
        &#34;Asset&#34;,
        &#34;AssetGroup&#34;,
        &#34;AssetThreat&#34;,
        &#34;CaseMgt&#34;,
        &#34;CaseOrg&#34;,
        &#34;CaseStatus&#34;,
        &#34;Class&#34;,
        &#34;Connection&#34;,
        &#34;DataEnrichment&#34;,
        &#34;GeoLoc_ASNGeoDst&#34;,
        &#34;GeoLoc_ASNGeoSrc&#34;,
        &#34;IOC&#34;,
        &#34;IPS&#34;,
        &#34;IPSCheck&#34;,
        &#34;NDDeviceInterface_NDDevIFDst&#34;,
        &#34;NDDeviceInterface_NDDevIFSrc&#34;,
        &#34;NDDevice_NDDevIDDst&#34;,
        &#34;NDDevice_NDDevIDSrc&#34;,
        &#34;OS&#34;,
        &#34;Rule_NDSNormSigID&#34;,
        &#34;Tag&#34;,
        &#34;TagAsset&#34;,
        &#34;ThirdPartyType&#34;,
        &#34;Threat&#34;,
        &#34;ThreatVendor&#34;,
        &#34;TriggeredAlarm&#34;,
        &#34;Users&#34;,
        &#34;Vulnerability&#34;,
        &#34;Zone_ZoneDst&#34;,
        &#34;Zone_ZoneSrc&#34;,
        ]
    &#34;&#34;&#34;List of internal fields table : `Rule`,`Alert`,etc.
    &#34;&#34;&#34;

    # Minimal default query fields
    DEFAULTS_EVENT_FIELDS=[&#34;Rule.msg&#34;, &#34;LastTime&#34;, &#34;IPSIDAlertID&#34;]
    &#34;&#34;&#34;Always present when using `msiempy.event.EventManager` querying :  
        `Rule.msg`  
        `Alert.LastTime`  
        `Alert.IPSIDAlertID`
    &#34;&#34;&#34;
    # Regular query fields
    REGULAR_EVENT_FIELDS=[
        &#34;Rule.msg&#34;,
        &#34;Alert.SrcIP&#34;,
        &#34;Alert.DstIP&#34;, 
        &#34;Alert.SrcMac&#34;,
        &#34;Alert.DstMac&#34;,
        &#34;Rule.NormID&#34;,
        &#34;HostID&#34;,
        &#34;UserIDSrc&#34;,
        &#34;ObjectID&#34;,
        &#34;Alert.Severity&#34;,
        &#34;Alert.LastTime&#34;,
        &#34;Alert.DSIDSigID&#34;,
        &#34;Alert.IPSIDAlertID&#34;]
    &#34;&#34;&#34;
    List of regular event fields.  

    `Rule.msg`  
    `Alert.SrcIP`  
    `Alert.DstIP`   
    `Alert.SrcMac`  
    `Alert.DstMac`  
    `Rule.NormID`  
    `HostID`  
    `UserIDSrc`  
    `ObjectID`  
    `Alert.Severity`  
    `Alert.LastTime`  
    `Alert.DSIDSigID`  
    `Alert.IPSIDAlertID` 
    &#34;&#34;&#34;
    
    SIEM_FIELDS_MAP_INTERNAL_NAME_TO_NICKNAME = {
    &#39;Alert.105250817&#39;: &#39;DNS - Response_Code_Name&#39;,
    &#39;Alert.122028033&#39;: &#39;DNS - Query&#39;,
    &#39;Alert.196609&#39;: &#39;Queue_ID&#39;,
    &#39;Alert.21364737&#39;: &#39;DNS - Class&#39;,
    &#39;Alert.21364738&#39;: &#39;Registry - Key&#39;,
    &#39;Alert.21364739&#39;: &#39;Old_Reputation - GTI_File&#39;,
    &#39;Alert.21364740&#39;: &#39;New_Reputation - GTI_File&#39;,
    &#39;Alert.262145&#39;: &#39;Response_Time&#39;,
    &#39;Alert.262146&#39;: &#39;NAT_Details&#39;,
    &#39;Alert.262152&#39;: &#39;PID&#39;,
    &#39;Alert.262153&#39;: &#39;Grid_Master_IP&#39;,
    &#39;Alert.262154&#39;: &#39;Device_IP&#39;,
    &#39;Alert.262155&#39;: &#39;Device_Port&#39;,
    &#39;Alert.262156&#39;: &#39;External_EventID&#39;,
    &#39;Alert.262157&#39;: &#39;Spam_Score&#39;,
    &#39;Alert.262158&#39;: &#39;External_SubEventID&#39;,
    &#39;Alert.262159&#39;: &#39;File_Hash&#39;,
    &#39;Alert.262160&#39;: &#39;Handle_ID&#39;,
    &#39;Alert.262161&#39;: &#39;Instance_GUID&#39;,
    &#39;Alert.262162&#39;: &#39;Agent_GUID&#39;,
    &#39;Alert.262163&#39;: &#39;UUID&#39;,
    &#39;Alert.262164&#39;: &#39;Reputation&#39;,
    &#39;Alert.262165&#39;: &#39;DAT_Version&#39;,
    &#39;Alert.262166&#39;: &#39;Server_ID&#39;,
    &#39;Alert.262167&#39;: &#39;Policy_ID&#39;,
    &#39;Alert.262168&#39;: &#39;Handheld_ID&#39;,
    &#39;Alert.262169&#39;: &#39;Database_GUID&#39;,
    &#39;Alert.262170&#39;: &#39;Analyzer_DAT_Version&#39;,
    &#39;Alert.262171&#39;: &#39;Reputation_Score&#39;,
    &#39;Alert.262172&#39;: &#39;Parent_File_Hash&#39;,
    &#39;Alert.262173&#39;: &#39;Incident_ID&#39;,
    &#39;Alert.262174&#39;: &#39;Victim_IP&#39;,
    &#39;Alert.262175&#39;: &#39;Attacker_IP&#39;,
    &#39;Alert.262176&#39;: &#39;Object_GUID&#39;,
    &#39;Alert.262177&#39;: &#39;Reputation_Server_IP&#39;,
    &#39;Alert.262178&#39;: &#39;DNS_Server_IP&#39;,
    &#39;Alert.262179&#39;: &#39;Device_Confidence&#39;,
    &#39;Alert.38141953&#39;: &#39;DNS - Class_Name&#39;,
    &#39;Alert.38141954&#39;: &#39;Registry - Value&#39;,
    &#39;Alert.38141955&#39;: &#39;Old_Reputation - TIE_File&#39;,
    &#39;Alert.38141956&#39;: &#39;New_Reputation - TIE_File&#39;,
    &#39;Alert.4259841&#39;: &#39;URL&#39;,
    &#39;Alert.4259842&#39;: &#39;Message_Text&#39;,
    &#39;Alert.4259843&#39;: &#39;Filename&#39;,
    &#39;Alert.4259844&#39;: &#39;From&#39;,
    &#39;Alert.4259845&#39;: &#39;To&#39;,
    &#39;Alert.4259846&#39;: &#39;Cc&#39;,
    &#39;Alert.4259847&#39;: &#39;Bcc&#39;,
    &#39;Alert.4259848&#39;: &#39;Subject&#39;,
    &#39;Alert.4259849&#39;: &#39;User_Agent&#39;,
    &#39;Alert.4259850&#39;: &#39;Cookie&#39;,
    &#39;Alert.4259851&#39;: &#39;Referer&#39;,
    &#39;Alert.4259852&#39;: &#39;Destination_Filename&#39;,
    &#39;Alert.4259853&#39;: &#39;Client_Version&#39;,
    &#39;Alert.4259854&#39;: &#39;Job_Name&#39;,
    &#39;Alert.4259855&#39;: &#39;Language&#39;,
    &#39;Alert.4259856&#39;: &#39;SWF_URL&#39;,
    &#39;Alert.4259857&#39;: &#39;TC_URL&#39;,
    &#39;Alert.4259858&#39;: &#39;RTMP_Application&#39;,
    &#39;Alert.4259859&#39;: &#39;Version&#39;,
    &#39;Alert.4259860&#39;: &#39;Local_User_Name&#39;,
    &#39;Alert.4259867&#39;: &#39;DNS_Name&#39;,
    &#39;Alert.4259868&#39;: &#39;SNMP_Item&#39;,
    &#39;Alert.4259869&#39;: &#39;Sensor_UUID&#39;,
    &#39;Alert.4259870&#39;: &#39;Process_Name&#39;,
    &#39;Alert.4259871&#39;: &#39;Source_Context&#39;,
    &#39;Alert.4259872&#39;: &#39;Target_Context&#39;,
    &#39;Alert.4259873&#39;: &#39;Description&#39;,
    &#39;Alert.4259874&#39;: &#39;SQL_Statement&#39;,
    &#39;Alert.4259875&#39;: &#39;From_Address&#39;,
    &#39;Alert.4259876&#39;: &#39;To_Address&#39;,
    &#39;Alert.4259877&#39;: &#39;File_Path&#39;,
    &#39;Alert.4259878&#39;: &#39;Target_Process_Name&#39;,
    &#39;Alert.4259879&#39;: &#39;Privileges&#39;,
    &#39;Alert.4259880&#39;: &#39;Search_Query&#39;,
    &#39;Alert.4259881&#39;: &#39;PCAP_Name&#39;,
    &#39;Alert.4259882&#39;: &#39;Vulnerability_References&#39;,
    &#39;Alert.4259883&#39;: &#39;Access_Privileges&#39;,
    &#39;Alert.4259884&#39;: &#39;Old_Value&#39;,
    &#39;Alert.4259885&#39;: &#39;New_Value&#39;,
    &#39;Alert.4259886&#39;: &#39;Device_URL&#39;,
    &#39;Alert.4259887&#39;: &#39;Engine_List&#39;,
    &#39;Alert.4456449&#39;: &#39;Num_Copies&#39;,
    &#39;Alert.4456450&#39;: &#39;Start_Page&#39;,
    &#39;Alert.4456451&#39;: &#39;End_Page&#39;,
    &#39;Alert.4456457&#39;: &#39;NTP_Offset_To_Monitor&#39;,
    &#39;Alert.4456458&#39;: &#39;Confidence&#39;,
    &#39;Alert.4456459&#39;: &#39;Hops&#39;,
    &#39;Alert.4456460&#39;: &#39;Priority&#39;,
    &#39;Alert.54919169&#39;: &#39;DNS - Type&#39;,
    &#39;Alert.54919171&#39;: &#39;Old_Reputation - ATD_File&#39;,
    &#39;Alert.54919172&#39;: &#39;New_Reputation - ATD_File&#39;,
    &#39;Alert.65537&#39;: &#39;Signature_Name&#39;,
    &#39;Alert.65538&#39;: &#39;Threat_Name&#39;,
    &#39;Alert.65539&#39;: &#39;Destination_Hostname&#39;,
    &#39;Alert.65540&#39;: &#39;Category&#39;,
    &#39;Alert.65541&#39;: &#39;Source_Zone&#39;,
    &#39;Alert.65542&#39;: &#39;Destination_Zone&#39;,
    &#39;Alert.65543&#39;: &#39;Target_Class&#39;,
    &#39;Alert.65544&#39;: &#39;Policy_Name&#39;,
    &#39;Alert.65545&#39;: &#39;Event_Class&#39;,
    &#39;Alert.65546&#39;: &#39;Request_Type&#39;,
    &#39;Alert.65547&#39;: &#39;Message_ID&#39;,
    &#39;Alert.65548&#39;: &#39;Mail_ID&#39;,
    &#39;Alert.65549&#39;: &#39;Recipient_ID&#39;,
    &#39;Alert.65550&#39;: &#39;Delivery_ID&#39;,
    &#39;Alert.65551&#39;: &#39;Creator_Name&#39;,
    &#39;Alert.65552&#39;: &#39;External_Application&#39;,
    &#39;Alert.65553&#39;: &#39;External_DB2_Server&#39;,
    &#39;Alert.65554&#39;: &#39;Table_Name&#39;,
    &#39;Alert.65555&#39;: &#39;Access_Resource&#39;,
    &#39;Alert.65556&#39;: &#39;Catalog_Name&#39;,
    &#39;Alert.65557&#39;: &#39;DB2_Plan_Name&#39;,
    &#39;Alert.65558&#39;: &#39;File_Type&#39;,
    &#39;Alert.65559&#39;: &#39;FTP_Command&#39;,
    &#39;Alert.65560&#39;: &#39;Job_Type&#39;,
    &#39;Alert.65561&#39;: &#39;Logical_Unit_Name&#39;,
    &#39;Alert.65562&#39;: &#39;LPAR_DB2_Subsystem&#39;,
    &#39;Alert.65563&#39;: &#39;Step_Count&#39;,
    &#39;Alert.65564&#39;: &#39;Step_Name&#39;,
    &#39;Alert.65565&#39;: &#39;Volume_ID&#39;,
    &#39;Alert.65566&#39;: &#39;Source_UserID&#39;,
    &#39;Alert.65567&#39;: &#39;Destination_UserID&#39;,
    &#39;Alert.65568&#39;: &#39;Mainframe_Job_Name&#39;,
    &#39;Alert.65569&#39;: &#39;Database_ID&#39;,
    &#39;Alert.65570&#39;: &#39;Malware_Insp_Action&#39;,
    &#39;Alert.65571&#39;: &#39;Malware_Insp_Result&#39;,
    &#39;Alert.65572&#39;: &#39;Source_Network&#39;,
    &#39;Alert.65573&#39;: &#39;Destination_Network&#39;,
    &#39;Alert.65574&#39;: &#39;Incoming_ID&#39;,
    &#39;Alert.65575&#39;: &#39;External_Hostname&#39;,
    &#39;Alert.65576&#39;: &#39;Area&#39;,
    &#39;Alert.65577&#39;: &#39;Facility&#39;,
    &#39;Alert.65578&#39;: &#39;Privileged_User&#39;,
    &#39;Alert.65579&#39;: &#39;Operating_System&#39;,
    &#39;Alert.65580&#39;: &#39;Logon_Type&#39;,
    &#39;Alert.65581&#39;: &#39;Management_Server&#39;,
    &#39;Alert.65582&#39;: &#39;External_SessionID&#39;,
    &#39;Alert.65583&#39;: &#39;Source_Logon_ID&#39;,
    &#39;Alert.65584&#39;: &#39;Destination_Logon_ID&#39;,
    &#39;Alert.65585&#39;: &#39;Session_Status&#39;,
    &#39;Alert.65586&#39;: &#39;URL_Category&#39;,
    &#39;Alert.65587&#39;: &#39;Caller_Process&#39;,
    &#39;Alert.65588&#39;: &#39;Registry_Key&#39;,
    &#39;Alert.65589&#39;: &#39;Registry_Value&#39;,
    &#39;Alert.65590&#39;: &#39;Mailbox&#39;,
    &#39;Alert.65591&#39;: &#39;Directory&#39;,
    &#39;Alert.65592&#39;: &#39;Destination_Directory&#39;,
    &#39;Alert.65593&#39;: &#39;SQL_Command&#39;,
    &#39;Alert.65594&#39;: &#39;Device_Action&#39;,
    &#39;Alert.65595&#39;: &#39;Threat_Category&#39;,
    &#39;Alert.65596&#39;: &#39;Threat_Handled&#39;,
    &#39;Alert.65597&#39;: &#39;Reason&#39;,
    &#39;Alert.65599&#39;: &#39;Detection_Method&#39;,
    &#39;Alert.65600&#39;: &#39;Virtual_Machine_Name&#39;,
    &#39;Alert.65601&#39;: &#39;Virtual_Machine_ID&#39;,
    &#39;Alert.65602&#39;: &#39;Datacenter_ID&#39;,
    &#39;Alert.65603&#39;: &#39;Datacenter_Name&#39;,
    &#39;Alert.65604&#39;: &#39;Interface_Dest&#39;,
    &#39;Alert.65605&#39;: &#39;Organizational_Unit&#39;,
    &#39;Alert.65606&#39;: &#39;External_Device_Type&#39;,
    &#39;Alert.65607&#39;: &#39;External_Device_ID&#39;,
    &#39;Alert.65608&#39;: &#39;External_Device_Name&#39;,
    &#39;Alert.65609&#39;: &#39;Service_Name&#39;,
    &#39;Alert.65610&#39;: &#39;Reputation_Name&#39;,
    &#39;Alert.65611&#39;: &#39;Status&#39;,
    &#39;Alert.65612&#39;: &#39;Sub_Status&#39;,
    &#39;Alert.65613&#39;: &#39;Web_Domain&#39;,
    &#39;Alert.65614&#39;: &#39;Group_Name&#39;,
    &#39;Alert.65615&#39;: &#39;App_Layer_Protocol&#39;,
    &#39;Alert.65616&#39;: &#39;Rule_Name&#39;,
    &#39;Alert.65617&#39;: &#39;Security_ID&#39;,
    &#39;Alert.65618&#39;: &#39;Authentication_Type&#39;,
    &#39;Alert.65619&#39;: &#39;SHA1&#39;,
    &#39;Alert.65620&#39;: &#39;File_ID&#39;,
    &#39;Alert.65621&#39;: &#39;Attribute_Type&#39;,
    &#39;Alert.65622&#39;: &#39;Access_Mask&#39;,
    &#39;Alert.65623&#39;: &#39;VPN_Feature_Name&#39;,
    &#39;Alert.65624&#39;: &#39;Hash&#39;,
    &#39;Alert.65625&#39;: &#39;Hash_Type&#39;,
    &#39;Alert.65627&#39;: &#39;Subcategory&#39;,
    &#39;Alert.65628&#39;: &#39;CnC_Host&#39;,
    &#39;Alert.65629&#39;: &#39;Share_Name&#39;,
    &#39;Alert.65630&#39;: &#39;SHA256&#39;,
    &#39;Alert.71696385&#39;: &#39;DNS - Type_Name&#39;,
    &#39;Alert.71696387&#39;: &#39;Old_Reputation - GTI_Cert&#39;,
    &#39;Alert.71696388&#39;: &#39;New_Reputation - GTI_Cert&#39;,
    &#39;Alert.88473601&#39;: &#39;DNS - Response_Code&#39;,
    &#39;Alert.88473603&#39;: &#39;Old_Reputation - TIE_Cert&#39;,
    &#39;Alert.88473604&#39;: &#39;New_Reputation - TIE_Cert&#39;,
    &#39;Alert.ASNGeoDst&#39;: &#39;ASNGeoDst&#39;,
    &#39;Alert.ASNGeoSrc&#39;: &#39;ASNGeoSrc&#39;,
    &#39;Alert.Action&#39;: &#39;Action&#39;,
    &#39;Alert.AlertID&#39;: &#39;AlertID&#39;,
    &#39;Alert.AppIDCat&#39;: &#39;AppIDCat&#39;,
    &#39;Alert.AvgSeverity&#39;: &#39;AvgSeverity&#39;,
    &#39;Alert.BIN(1)&#39;: &#39;AppID&#39;,
    &#39;Alert.BIN(10)&#39;: &#39;Object_Type&#39;,
    &#39;Alert.BIN(11)&#39;: &#39;Method&#39;,
    &#39;Alert.BIN(12)&#39;: &#39;File_Operation&#39;,
    &#39;Alert.BIN(13)&#39;: &#39;File_Operation_Succeeded&#39;,
    &#39;Alert.BIN(14)&#39;: &#39;User_Nickname&#39;,
    &#39;Alert.BIN(15)&#39;: &#39;Contact_Name&#39;,
    &#39;Alert.BIN(16)&#39;: &#39;Contact_Nickname&#39;,
    &#39;Alert.BIN(17)&#39;: &#39;DNS_Type&#39;,
    &#39;Alert.BIN(18)&#39;: &#39;DNS_Class&#39;,
    &#39;Alert.BIN(19)&#39;: &#39;Query_Response&#39;,
    &#39;Alert.BIN(2)&#39;: &#39;CommandID&#39;,
    &#39;Alert.BIN(20)&#39;: &#39;Authoritative_Answer&#39;,
    &#39;Alert.BIN(21)&#39;: &#39;SNMP_Operation&#39;,
    &#39;Alert.BIN(22)&#39;: &#39;SNMP_Item_Type&#39;,
    &#39;Alert.BIN(23)&#39;: &#39;SNMP_Version&#39;,
    &#39;Alert.BIN(24)&#39;: &#39;SNMP_Error_Code&#39;,
    &#39;Alert.BIN(25)&#39;: &#39;NTP_Client_Mode&#39;,
    &#39;Alert.BIN(26)&#39;: &#39;NTP_Server_Mode&#39;,
    &#39;Alert.BIN(27)&#39;: &#39;NTP_Request&#39;,
    &#39;Alert.BIN(28)&#39;: &#39;NTP_Opcode&#39;,
    &#39;Alert.BIN(29)&#39;: &#39;Interface&#39;,
    &#39;Alert.BIN(3)&#39;: &#39;DomainID&#39;,
    &#39;Alert.BIN(30)&#39;: &#39;Direction&#39;,
    &#39;Alert.BIN(31)&#39;: &#39;Sensor_Name&#39;,
    &#39;Alert.BIN(32)&#39;: &#39;Sensor_Type&#39;,
    &#39;Alert.BIN(33)&#39;: &#39;Response_Code&#39;,
    &#39;Alert.BIN(34)&#39;: &#39;Return_Code&#39;,
    &#39;Alert.BIN(4)&#39;: &#39;HostID&#39;,
    &#39;Alert.BIN(5)&#39;: &#39;ObjectID&#39;,
    &#39;Alert.BIN(6)&#39;: &#39;UserIDDst&#39;,
    &#39;Alert.BIN(7)&#39;: &#39;UserIDSrc&#39;,
    &#39;Alert.BIN(8)&#39;: &#39;Database_Name&#39;,
    &#39;Alert.BIN(9)&#39;: &#39;Application_Protocol&#39;,
    &#39;Alert.CommandIDCat&#39;: &#39;CommandIDCat&#39;,
    &#39;Alert.DSID&#39;: &#39;DSID&#39;,
    &#39;Alert.DSIDSigID&#39;: &#39;DSIDSigID&#39;,
    &#39;Alert.DomainIDCat&#39;: &#39;DomainIDCat&#39;,
    &#39;Alert.DstIP&#39;: &#39;DstIP&#39;,
    &#39;Alert.DstMac&#39;: &#39;DstMac&#39;,
    &#39;Alert.DstPort&#39;: &#39;DstPort&#39;,
    &#39;Alert.EventCount&#39;: &#39;EventCount&#39;,
    &#39;Alert.FirstTime&#39;: &#39;FirstTime&#39;,
    &#39;Alert.Flow&#39;: &#39;Flow&#39;,
    &#39;Alert.FlowID&#39;: &#39;FlowID&#39;,
    &#39;Alert.GUIDDst&#39;: &#39;GUIDDst&#39;,
    &#39;Alert.GUIDSrc&#39;: &#39;GUIDSrc&#39;,
    &#39;Alert.HostIDCat&#39;: &#39;HostIDCat&#39;,
    &#39;Alert.IPSID&#39;: &#39;IPSID&#39;,
    &#39;Alert.IPSIDAlertID&#39;: &#39;IPSIDAlertID&#39;,
    &#39;Alert.LastTime&#39;: &#39;LastTime&#39;,
    &#39;Alert.LastTime_usec&#39;: &#39;LastTime_usec&#39;,
    &#39;Alert.ObjectIDCat&#39;: &#39;ObjectIDCat&#39;,
    &#39;Alert.Protocol&#39;: &#39;Protocol&#39;,
    &#39;Alert.RemCaseID&#39;: &#39;RemCaseID&#39;,
    &#39;Alert.RemOpenTicketTime&#39;: &#39;RemOpenTicketTime&#39;,
    &#39;Alert.Reviewed&#39;: &#39;Reviewed&#39;,
    &#39;Alert.Sequence&#39;: &#39;Sequence&#39;,
    &#39;Alert.SessionID&#39;: &#39;SessionID&#39;,
    &#39;Alert.Severity&#39;: &#39;Severity&#39;,
    &#39;Alert.SigID&#39;: &#39;SigID&#39;,
    &#39;Alert.SrcIP&#39;: &#39;SrcIP&#39;,
    &#39;Alert.SrcMac&#39;: &#39;SrcMac&#39;,
    &#39;Alert.SrcPort&#39;: &#39;SrcPort&#39;,
    &#39;Alert.Trusted&#39;: &#39;Trusted&#39;,
    &#39;Alert.UserFld10Cat&#39;: &#39;UserFld10Cat&#39;,
    &#39;Alert.UserFld21Cat&#39;: &#39;UserFld21Cat&#39;,
    &#39;Alert.UserFld22Cat&#39;: &#39;UserFld22Cat&#39;,
    &#39;Alert.UserFld23Cat&#39;: &#39;UserFld23Cat&#39;,
    &#39;Alert.UserFld24Cat&#39;: &#39;UserFld24Cat&#39;,
    &#39;Alert.UserFld25Cat&#39;: &#39;UserFld25Cat&#39;,
    &#39;Alert.UserFld26Cat&#39;: &#39;UserFld26Cat&#39;,
    &#39;Alert.UserFld27Cat&#39;: &#39;UserFld27Cat&#39;,
    &#39;Alert.UserFld8Cat&#39;: &#39;UserFld8Cat&#39;,
    &#39;Alert.UserFld9Cat&#39;: &#39;UserFld9Cat&#39;,
    &#39;Alert.UserIDDstCat&#39;: &#39;UserIDDstCat&#39;,
    &#39;Alert.UserIDSrcCat&#39;: &#39;UserIDSrcCat&#39;,
    &#39;Alert.VLan&#39;: &#39;VLan&#39;,
    &#39;Alert.WriteTime&#39;: &#39;WriteTime&#39;,
    &#39;Alert.ZoneDst&#39;: &#39;ZoneDst&#39;,
    &#39;Alert.ZoneSrc&#39;: &#39;ZoneSrc&#39;}
    &#34;&#34;&#34;
    Fields name mapping.  
    &#34;&#34;&#34;

    # NICKNAME TO INTERNAL NAMES
    SIEM_FIELDS_MAP_NICKNAME_TO_INTERNAL_NAME={&#39;ASNGeoDst&#39;: &#39;Alert.ASNGeoDst&#39;,
    &#39;ASNGeoSrc&#39;: &#39;Alert.ASNGeoSrc&#39;,
    &#39;Access_Mask&#39;: &#39;Alert.65622&#39;,
    &#39;Access_Privileges&#39;: &#39;Alert.4259883&#39;,
    &#39;Access_Resource&#39;: &#39;Alert.65555&#39;,
    &#39;Action&#39;: &#39;Alert.Action&#39;,
    &#39;Action.Name&#39;: &#39;Action.Name&#39;,
    &#39;Agent_GUID&#39;: &#39;Alert.262162&#39;,
    &#39;AlertID&#39;: &#39;Alert.AlertID&#39;,
    &#39;Analyzer_DAT_Version&#39;: &#39;Alert.262170&#39;,
    &#39;AppID&#39;: &#39;Alert.BIN(1)&#39;,
    &#39;AppIDCat&#39;: &#39;Alert.AppIDCat&#39;,
    &#39;App_Layer_Protocol&#39;: &#39;Alert.65615&#39;,
    &#39;Application_Protocol&#39;: &#39;Alert.BIN(9)&#39;,
    &#39;Area&#39;: &#39;Alert.65576&#39;,
    &#39;Attacker_IP&#39;: &#39;Alert.262175&#39;,
    &#39;Attribute_Type&#39;: &#39;Alert.65621&#39;,
    &#39;Authentication_Type&#39;: &#39;Alert.65618&#39;,
    &#39;Authoritative_Answer&#39;: &#39;Alert.BIN(20)&#39;,
    &#39;AvgSeverity&#39;: &#39;Alert.AvgSeverity&#39;,
    &#39;Bcc&#39;: &#39;Alert.4259847&#39;,
    &#39;Caller_Process&#39;: &#39;Alert.65587&#39;,
    &#39;Catalog_Name&#39;: &#39;Alert.65556&#39;,
    &#39;Category&#39;: &#39;Alert.65540&#39;,
    &#39;Cc&#39;: &#39;Alert.4259846&#39;,
    &#39;Class.Name&#39;: &#39;Class.Name&#39;,
    &#39;Class.Priority&#39;: &#39;Class.Priority&#39;,
    &#39;Client_Version&#39;: &#39;Alert.4259853&#39;,
    &#39;CnC_Host&#39;: &#39;Alert.65628&#39;,
    &#39;CommandID&#39;: &#39;Alert.BIN(2)&#39;,
    &#39;CommandIDCat&#39;: &#39;Alert.CommandIDCat&#39;,
    &#39;Confidence&#39;: &#39;Alert.4456458&#39;,
    &#39;Contact_Name&#39;: &#39;Alert.BIN(15)&#39;,
    &#39;Contact_Nickname&#39;: &#39;Alert.BIN(16)&#39;,
    &#39;Cookie&#39;: &#39;Alert.4259850&#39;,
    &#39;Creator_Name&#39;: &#39;Alert.65551&#39;,
    &#39;DAT_Version&#39;: &#39;Alert.262165&#39;,
    &#39;DB2_Plan_Name&#39;: &#39;Alert.65557&#39;,
    &#39;DNS - Class&#39;: &#39;Alert.21364737&#39;,
    &#39;DNS - Class_Name&#39;: &#39;Alert.38141953&#39;,
    &#39;DNS - Query&#39;: &#39;Alert.122028033&#39;,
    &#39;DNS - Response_Code&#39;: &#39;Alert.88473601&#39;,
    &#39;DNS - Response_Code_Name&#39;: &#39;Alert.105250817&#39;,
    &#39;DNS - Type&#39;: &#39;Alert.54919169&#39;,
    &#39;DNS - Type_Name&#39;: &#39;Alert.71696385&#39;,
    &#39;DNS_Class&#39;: &#39;Alert.BIN(18)&#39;,
    &#39;DNS_Name&#39;: &#39;Alert.4259867&#39;,
    &#39;DNS_Server_IP&#39;: &#39;Alert.262178&#39;,
    &#39;DNS_Type&#39;: &#39;Alert.BIN(17)&#39;,
    &#39;DSID&#39;: &#39;Alert.DSID&#39;,
    &#39;DSIDSigID&#39;: &#39;Alert.DSIDSigID&#39;,
    &#39;Database_GUID&#39;: &#39;Alert.262169&#39;,
    &#39;Database_ID&#39;: &#39;Alert.65569&#39;,
    &#39;Database_Name&#39;: &#39;Alert.BIN(8)&#39;,
    &#39;Datacenter_ID&#39;: &#39;Alert.65602&#39;,
    &#39;Datacenter_Name&#39;: &#39;Alert.65603&#39;,
    &#39;Delivery_ID&#39;: &#39;Alert.65550&#39;,
    &#39;Description&#39;: &#39;Alert.4259873&#39;,
    &#39;Destination_Directory&#39;: &#39;Alert.65592&#39;,
    &#39;Destination_Filename&#39;: &#39;Alert.4259852&#39;,
    &#39;Destination_Hostname&#39;: &#39;Alert.65539&#39;,
    &#39;Destination_Logon_ID&#39;: &#39;Alert.65584&#39;,
    &#39;Destination_Network&#39;: &#39;Alert.65573&#39;,
    &#39;Destination_UserID&#39;: &#39;Alert.65567&#39;,
    &#39;Destination_Zone&#39;: &#39;Alert.65542&#39;,
    &#39;Detection_Method&#39;: &#39;Alert.65599&#39;,
    &#39;Device_Action&#39;: &#39;Alert.65594&#39;,
    &#39;Device_Confidence&#39;: &#39;Alert.262179&#39;,
    &#39;Device_IP&#39;: &#39;Alert.262154&#39;,
    &#39;Device_Port&#39;: &#39;Alert.262155&#39;,
    &#39;Device_URL&#39;: &#39;Alert.4259886&#39;,
    &#39;Direction&#39;: &#39;Alert.BIN(30)&#39;,
    &#39;Directory&#39;: &#39;Alert.65591&#39;,
    &#39;DomainID&#39;: &#39;Alert.BIN(3)&#39;,
    &#39;DomainIDCat&#39;: &#39;Alert.DomainIDCat&#39;,
    &#39;DstIP&#39;: &#39;Alert.DstIP&#39;,
    &#39;DstMac&#39;: &#39;Alert.DstMac&#39;,
    &#39;DstPort&#39;: &#39;Alert.DstPort&#39;,
    &#39;End_Page&#39;: &#39;Alert.4456451&#39;,
    &#39;Engine_List&#39;: &#39;Alert.4259887&#39;,
    &#39;EventCount&#39;: &#39;Alert.EventCount&#39;,
    &#39;Event_Class&#39;: &#39;Alert.65545&#39;,
    &#39;External_Application&#39;: &#39;Alert.65552&#39;,
    &#39;External_DB2_Server&#39;: &#39;Alert.65553&#39;,
    &#39;External_Device_ID&#39;: &#39;Alert.65607&#39;,
    &#39;External_Device_Name&#39;: &#39;Alert.65608&#39;,
    &#39;External_Device_Type&#39;: &#39;Alert.65606&#39;,
    &#39;External_EventID&#39;: &#39;Alert.262156&#39;,
    &#39;External_Hostname&#39;: &#39;Alert.65575&#39;,
    &#39;External_SessionID&#39;: &#39;Alert.65582&#39;,
    &#39;External_SubEventID&#39;: &#39;Alert.262158&#39;,
    &#39;FTP_Command&#39;: &#39;Alert.65559&#39;,
    &#39;Facility&#39;: &#39;Alert.65577&#39;,
    &#39;File_Hash&#39;: &#39;Alert.262159&#39;,
    &#39;File_ID&#39;: &#39;Alert.65620&#39;,
    &#39;File_Operation&#39;: &#39;Alert.BIN(12)&#39;,
    &#39;File_Operation_Succeeded&#39;: &#39;Alert.BIN(13)&#39;,
    &#39;File_Path&#39;: &#39;Alert.4259877&#39;,
    &#39;File_Type&#39;: &#39;Alert.65558&#39;,
    &#39;Filename&#39;: &#39;Alert.4259843&#39;,
    &#39;FirstTime&#39;: &#39;Alert.FirstTime&#39;,
    &#39;Flow&#39;: &#39;Alert.Flow&#39;,
    &#39;FlowID&#39;: &#39;Alert.FlowID&#39;,
    &#39;From&#39;: &#39;Alert.4259844&#39;,
    &#39;From_Address&#39;: &#39;Alert.4259875&#39;,
    &#39;GUIDDst&#39;: &#39;Alert.GUIDDst&#39;,
    &#39;GUIDSrc&#39;: &#39;Alert.GUIDSrc&#39;,
    &#39;GeoLoc_ASNGeoDst.Latitude&#39;: &#39;GeoLoc_ASNGeoDst.Latitude&#39;, # This is useless
    &#39;GeoLoc_ASNGeoDst.Longitude&#39;: &#39;GeoLoc_ASNGeoDst.Longitude&#39;, # This is useless
    &#39;GeoLoc_ASNGeoDst.Msg&#39;: &#39;GeoLoc_ASNGeoDst.Msg&#39;, # This is useless
    &#39;GeoLoc_ASNGeoDst.XCoord&#39;: &#39;GeoLoc_ASNGeoDst.XCoord&#39;, # This is useless
    &#39;GeoLoc_ASNGeoDst.YCoord&#39;: &#39;GeoLoc_ASNGeoDst.YCoord&#39;, # This is useless
    &#39;GeoLoc_ASNGeoSrc.Latitude&#39;: &#39;GeoLoc_ASNGeoSrc.Latitude&#39;,  # This is useless
    &#39;GeoLoc_ASNGeoSrc.Longitude&#39;: &#39;GeoLoc_ASNGeoSrc.Longitude&#39;,  # This is useless
    &#39;GeoLoc_ASNGeoSrc.Msg&#39;: &#39;GeoLoc_ASNGeoSrc.Msg&#39;,  # This is useless
    &#39;GeoLoc_ASNGeoSrc.XCoord&#39;: &#39;GeoLoc_ASNGeoSrc.XCoord&#39;,  # This is useless
    &#39;GeoLoc_ASNGeoSrc.YCoord&#39;: &#39;GeoLoc_ASNGeoSrc.YCoord&#39;,  # This is useless
    &#39;Grid_Master_IP&#39;: &#39;Alert.262153&#39;,
    &#39;Group_Name&#39;: &#39;Alert.65614&#39;,
    &#39;Handheld_ID&#39;: &#39;Alert.262168&#39;,
    &#39;Handle_ID&#39;: &#39;Alert.262160&#39;,
    &#39;Hash&#39;: &#39;Alert.65624&#39;,
    &#39;Hash_Type&#39;: &#39;Alert.65625&#39;,
    &#39;Hops&#39;: &#39;Alert.4456459&#39;,
    &#39;HostID&#39;: &#39;Alert.BIN(4)&#39;,
    &#39;HostIDCat&#39;: &#39;Alert.HostIDCat&#39;,
    &#39;IPS.Name&#39;: &#39;IPS.Name&#39;,
    &#39;IPSID&#39;: &#39;Alert.IPSID&#39;,
    &#39;IPSIDAlertID&#39;: &#39;Alert.IPSIDAlertID&#39;,
    &#39;Incident_ID&#39;: &#39;Alert.262173&#39;,
    &#39;Incoming_ID&#39;: &#39;Alert.65574&#39;,
    &#39;Instance_GUID&#39;: &#39;Alert.262161&#39;,
    &#39;Interface&#39;: &#39;Alert.BIN(29)&#39;,
    &#39;Interface_Dest&#39;: &#39;Alert.65604&#39;,
    &#39;Job_Name&#39;: &#39;Alert.4259854&#39;,
    &#39;Job_Type&#39;: &#39;Alert.65560&#39;,
    &#39;LPAR_DB2_Subsystem&#39;: &#39;Alert.65562&#39;,
    &#39;Language&#39;: &#39;Alert.4259855&#39;,
    &#39;LastTime&#39;: &#39;Alert.LastTime&#39;,
    &#39;LastTime_usec&#39;: &#39;Alert.LastTime_usec&#39;,
    &#39;Local_User_Name&#39;: &#39;Alert.4259860&#39;,
    &#39;Logical_Unit_Name&#39;: &#39;Alert.65561&#39;,
    &#39;Logon_Type&#39;: &#39;Alert.65580&#39;,
    &#39;Mail_ID&#39;: &#39;Alert.65548&#39;,
    &#39;Mailbox&#39;: &#39;Alert.65590&#39;,
    &#39;Mainframe_Job_Name&#39;: &#39;Alert.65568&#39;,
    &#39;Malware_Insp_Action&#39;: &#39;Alert.65570&#39;,
    &#39;Malware_Insp_Result&#39;: &#39;Alert.65571&#39;,
    &#39;Management_Server&#39;: &#39;Alert.65581&#39;,
    &#39;Message_ID&#39;: &#39;Alert.65547&#39;,
    &#39;Message_Text&#39;: &#39;Alert.4259842&#39;,
    &#39;Method&#39;: &#39;Alert.BIN(11)&#39;,
    &#39;NAT_Details&#39;: &#39;Alert.262146&#39;,
    &#39;NTP_Client_Mode&#39;: &#39;Alert.BIN(25)&#39;,
    &#39;NTP_Offset_To_Monitor&#39;: &#39;Alert.4456457&#39;,
    &#39;NTP_Opcode&#39;: &#39;Alert.BIN(28)&#39;,
    &#39;NTP_Request&#39;: &#39;Alert.BIN(27)&#39;,
    &#39;NTP_Server_Mode&#39;: &#39;Alert.BIN(26)&#39;,
    &#39;New_Reputation - ATD_File&#39;: &#39;Alert.54919172&#39;,
    &#39;New_Reputation - GTI_Cert&#39;: &#39;Alert.71696388&#39;,
    &#39;New_Reputation - GTI_File&#39;: &#39;Alert.21364740&#39;,
    &#39;New_Reputation - TIE_Cert&#39;: &#39;Alert.88473604&#39;,
    &#39;New_Reputation - TIE_File&#39;: &#39;Alert.38141956&#39;,
    &#39;New_Value&#39;: &#39;Alert.4259885&#39;,
    &#39;Num_Copies&#39;: &#39;Alert.4456449&#39;,
    &#39;ObjectID&#39;: &#39;Alert.BIN(5)&#39;,
    &#39;ObjectIDCat&#39;: &#39;Alert.ObjectIDCat&#39;,
    &#39;Object_GUID&#39;: &#39;Alert.262176&#39;,
    &#39;Object_Type&#39;: &#39;Alert.BIN(10)&#39;,
    &#39;Old_Reputation - ATD_File&#39;: &#39;Alert.54919171&#39;,
    &#39;Old_Reputation - GTI_Cert&#39;: &#39;Alert.71696387&#39;,
    &#39;Old_Reputation - GTI_File&#39;: &#39;Alert.21364739&#39;,
    &#39;Old_Reputation - TIE_Cert&#39;: &#39;Alert.88473603&#39;,
    &#39;Old_Reputation - TIE_File&#39;: &#39;Alert.38141955&#39;,
    &#39;Old_Value&#39;: &#39;Alert.4259884&#39;,
    &#39;Operating_System&#39;: &#39;Alert.65579&#39;,
    &#39;Organizational_Unit&#39;: &#39;Alert.65605&#39;,
    &#39;PCAP_Name&#39;: &#39;Alert.4259881&#39;,
    &#39;PID&#39;: &#39;Alert.262152&#39;,
    &#39;Parent_File_Hash&#39;: &#39;Alert.262172&#39;,
    &#39;Policy_ID&#39;: &#39;Alert.262167&#39;,
    &#39;Policy_Name&#39;: &#39;Alert.65544&#39;,
    &#39;Priority&#39;: &#39;Alert.4456460&#39;,
    &#39;Privileged_User&#39;: &#39;Alert.65578&#39;,
    &#39;Privileges&#39;: &#39;Alert.4259879&#39;,
    &#39;Process_Name&#39;: &#39;Alert.4259870&#39;,
    &#39;Protocol&#39;: &#39;Alert.Protocol&#39;,
    &#39;Query_Response&#39;: &#39;Alert.BIN(19)&#39;,
    &#39;Queue_ID&#39;: &#39;Alert.196609&#39;,
    &#39;RTMP_Application&#39;: &#39;Alert.4259858&#39;,
    &#39;Reason&#39;: &#39;Alert.65597&#39;,
    &#39;Recipient_ID&#39;: &#39;Alert.65549&#39;,
    &#39;Referer&#39;: &#39;Alert.4259851&#39;,
    &#39;Registry - Key&#39;: &#39;Alert.21364738&#39;,
    &#39;Registry - Value&#39;: &#39;Alert.38141954&#39;,
    &#39;Registry_Key&#39;: &#39;Alert.65588&#39;,
    &#39;Registry_Value&#39;: &#39;Alert.65589&#39;,
    &#39;RemCaseID&#39;: &#39;Alert.RemCaseID&#39;,
    &#39;RemOpenTicketTime&#39;: &#39;Alert.RemOpenTicketTime&#39;,
    &#39;Reputation&#39;: &#39;Alert.262164&#39;,
    &#39;Reputation_Name&#39;: &#39;Alert.65610&#39;,
    &#39;Reputation_Score&#39;: &#39;Alert.262171&#39;,
    &#39;Reputation_Server_IP&#39;: &#39;Alert.262177&#39;,
    &#39;Request_Type&#39;: &#39;Alert.65546&#39;,
    &#39;Response_Code&#39;: &#39;Alert.BIN(33)&#39;,
    &#39;Response_Time&#39;: &#39;Alert.262145&#39;,
    &#39;Return_Code&#39;: &#39;Alert.BIN(34)&#39;,
    &#39;Reviewed&#39;: &#39;Alert.Reviewed&#39;,
    &#39;Rule.ID&#39;: &#39;Rule.ID&#39;,
    &#39;Rule.NormID&#39;: &#39;Rule.NormID&#39;,
    &#39;Rule.msg&#39;: &#39;Rule.msg&#39;,
    &#39;Rule_NDSNormSigID.msg&#39;: &#39;Rule_NDSNormSigID.msg&#39;,
    &#39;Rule_Name&#39;: &#39;Alert.65616&#39;,
    &#39;SHA1&#39;: &#39;Alert.65619&#39;,
    &#39;SHA256&#39;: &#39;Alert.65630&#39;,
    &#39;SNMP_Error_Code&#39;: &#39;Alert.BIN(24)&#39;,
    &#39;SNMP_Item&#39;: &#39;Alert.4259868&#39;,
    &#39;SNMP_Item_Type&#39;: &#39;Alert.BIN(22)&#39;,
    &#39;SNMP_Operation&#39;: &#39;Alert.BIN(21)&#39;,
    &#39;SNMP_Version&#39;: &#39;Alert.BIN(23)&#39;,
    &#39;SQL_Command&#39;: &#39;Alert.65593&#39;,
    &#39;SQL_Statement&#39;: &#39;Alert.4259874&#39;,
    &#39;SWF_URL&#39;: &#39;Alert.4259856&#39;,
    &#39;Search_Query&#39;: &#39;Alert.4259880&#39;,
    &#39;Security_ID&#39;: &#39;Alert.65617&#39;,
    &#39;Sensor_Name&#39;: &#39;Alert.BIN(31)&#39;,
    &#39;Sensor_Type&#39;: &#39;Alert.BIN(32)&#39;,
    &#39;Sensor_UUID&#39;: &#39;Alert.4259869&#39;,
    &#39;Sequence&#39;: &#39;Alert.Sequence&#39;,
    &#39;Server_ID&#39;: &#39;Alert.262166&#39;,
    &#39;Service_Name&#39;: &#39;Alert.65609&#39;,
    &#39;SessionID&#39;: &#39;Alert.SessionID&#39;,
    &#39;Session_Status&#39;: &#39;Alert.65585&#39;,
    &#39;Severity&#39;: &#39;Alert.Severity&#39;,
    &#39;Share_Name&#39;: &#39;Alert.65629&#39;,
    &#39;SigID&#39;: &#39;Alert.SigID&#39;,
    &#39;Signature_Name&#39;: &#39;Alert.65537&#39;,
    &#39;Source_Context&#39;: &#39;Alert.4259871&#39;,
    &#39;Source_Logon_ID&#39;: &#39;Alert.65583&#39;,
    &#39;Source_Network&#39;: &#39;Alert.65572&#39;,
    &#39;Source_UserID&#39;: &#39;Alert.65566&#39;,
    &#39;Source_Zone&#39;: &#39;Alert.65541&#39;,
    &#39;Spam_Score&#39;: &#39;Alert.262157&#39;,
    &#39;SrcIP&#39;: &#39;Alert.SrcIP&#39;,
    &#39;SrcMac&#39;: &#39;Alert.SrcMac&#39;,
    &#39;SrcPort&#39;: &#39;Alert.SrcPort&#39;,
    &#39;Start_Page&#39;: &#39;Alert.4456450&#39;,
    &#39;Status&#39;: &#39;Alert.65611&#39;,
    &#39;Step_Count&#39;: &#39;Alert.65563&#39;,
    &#39;Step_Name&#39;: &#39;Alert.65564&#39;,
    &#39;Sub_Status&#39;: &#39;Alert.65612&#39;,
    &#39;Subcategory&#39;: &#39;Alert.65627&#39;,
    &#39;Subject&#39;: &#39;Alert.4259848&#39;,
    &#39;TC_URL&#39;: &#39;Alert.4259857&#39;,
    &#39;Table_Name&#39;: &#39;Alert.65554&#39;,
    &#39;Target_Class&#39;: &#39;Alert.65543&#39;,
    &#39;Target_Context&#39;: &#39;Alert.4259872&#39;,
    &#39;Target_Process_Name&#39;: &#39;Alert.4259878&#39;,
    &#39;ThirdPartyType.Name&#39;: &#39;ThirdPartyType.Name&#39;, # This is useless
    &#39;Threat_Category&#39;: &#39;Alert.65595&#39;,
    &#39;Threat_Handled&#39;: &#39;Alert.65596&#39;,
    &#39;Threat_Name&#39;: &#39;Alert.65538&#39;,
    &#39;To&#39;: &#39;Alert.4259845&#39;,
    &#39;To_Address&#39;: &#39;Alert.4259876&#39;,
    &#39;Trusted&#39;: &#39;Alert.Trusted&#39;,
    &#39;URL&#39;: &#39;Alert.4259841&#39;,
    &#39;URL_Category&#39;: &#39;Alert.65586&#39;,
    &#39;UUID&#39;: &#39;Alert.262163&#39;,
    &#39;UserFld10Cat&#39;: &#39;Alert.UserFld10Cat&#39;,
    &#39;UserFld21Cat&#39;: &#39;Alert.UserFld21Cat&#39;,
    &#39;UserFld22Cat&#39;: &#39;Alert.UserFld22Cat&#39;,
    &#39;UserFld23Cat&#39;: &#39;Alert.UserFld23Cat&#39;,
    &#39;UserFld24Cat&#39;: &#39;Alert.UserFld24Cat&#39;,
    &#39;UserFld25Cat&#39;: &#39;Alert.UserFld25Cat&#39;,
    &#39;UserFld26Cat&#39;: &#39;Alert.UserFld26Cat&#39;,
    &#39;UserFld27Cat&#39;: &#39;Alert.UserFld27Cat&#39;,
    &#39;UserFld8Cat&#39;: &#39;Alert.UserFld8Cat&#39;,
    &#39;UserFld9Cat&#39;: &#39;Alert.UserFld9Cat&#39;,
    &#39;UserIDDst&#39;: &#39;Alert.BIN(6)&#39;,
    &#39;UserIDDstCat&#39;: &#39;Alert.UserIDDstCat&#39;,
    &#39;UserIDSrc&#39;: &#39;Alert.BIN(7)&#39;,
    &#39;UserIDSrcCat&#39;: &#39;Alert.UserIDSrcCat&#39;,
    &#39;User_Agent&#39;: &#39;Alert.4259849&#39;,
    &#39;User_Nickname&#39;: &#39;Alert.BIN(14)&#39;,
    &#39;Users.Name&#39;: &#39;Users.Name&#39;,  # This is useless
    &#39;VLan&#39;: &#39;Alert.VLan&#39;,
    &#39;VPN_Feature_Name&#39;: &#39;Alert.65623&#39;,
    &#39;Version&#39;: &#39;Alert.4259859&#39;,
    &#39;Victim_IP&#39;: &#39;Alert.262174&#39;,
    &#39;Virtual_Machine_ID&#39;: &#39;Alert.65601&#39;,
    &#39;Virtual_Machine_Name&#39;: &#39;Alert.65600&#39;,
    &#39;Volume_ID&#39;: &#39;Alert.65565&#39;,
    &#39;Vulnerability_References&#39;: &#39;Alert.4259882&#39;,
    &#39;Web_Domain&#39;: &#39;Alert.65613&#39;,
    &#39;WriteTime&#39;: &#39;Alert.WriteTime&#39;,
    &#39;ZoneDst&#39;: &#39;Alert.ZoneDst&#39;,
    &#39;ZoneSrc&#39;: &#39;Alert.ZoneSrc&#39;,
    &#39;Zone_ZoneDst.Name&#39;: &#39;Zone_ZoneDst.Name&#39;,  # This is useless
    &#39;Zone_ZoneSrc.Name&#39;: &#39;Zone_ZoneSrc.Name&#39;}  # This is useless
    &#34;&#34;&#34;
    Fields name mapping (reversed).  
    &#34;&#34;&#34;
    def _find_key(self, key):
        if collections.UserDict.__contains__(self, key): 
            return key
        if ( key in self.SIEM_FIELDS_MAP_NICKNAME_TO_INTERNAL_NAME.keys() and 
            collections.UserDict.__contains__(self, self.SIEM_FIELDS_MAP_NICKNAME_TO_INTERNAL_NAME[key]) ): 
            return self.SIEM_FIELDS_MAP_NICKNAME_TO_INTERNAL_NAME[key]

        # Loop thought FIELDS_TABLES and try with table prefix
        # Old behaviour
        for table in self.FIELDS_TABLES :
            if collections.UserDict.__contains__(self, table+&#39;.&#39;+key): 
                return table+&#39;.&#39;+key

        raise KeyError(&#39;Dictionnary key not found : {}&#39;.format(key))

    def __getitem__(self, key):
        return collections.UserDict.__getitem__(self, self._find_key(key))
    def __delitem__(self, key):
        return collections.UserDict.__delitem__(self, self._find_key(key))
    def __contains__(self, key):
        try: return self._find_key(key)!=None
        except KeyError: return False
    def __setitem__(self, key, value):
        try: return collections.UserDict.__setitem__(self, self._find_key(key), value)
        except KeyError: return collections.UserDict.__setitem__(self, key, value)

    def get_id(self):
        &#34;&#34;&#34;
        Get the event ID.  
        Try to return `e[&#39;Alert.IPSIDAlertID&#39;]` or e[&#39;eventId&#39;]` or concatenate `e[&#39;ipsId&#39;][&#39;id&#39;]` and `e[&#39;alertId&#39;]` depending of the Event dictionnary keys.  
        &#34;&#34;&#34;
        the_id = ( self.data[&#34;Alert.IPSIDAlertID&#34;] if ( &#34;Alert.IPSIDAlertID&#34; in self.data )
            else str(self.data[&#39;ipsId&#39;][&#39;id&#39;])+&#39;|&#39;+str(self.data[&#34;alertId&#34;]) if ( &#34;alertId&#34; in self.data )
            else self.data[&#34;eventId&#34;] if ( &#34;eventId&#34; in self.data ) else None )
        if the_id:
            return the_id
        else:
            return None

    def clear_notes(self):
        &#34;&#34;&#34;
        Replace the notes by an empty string. Desctructive action.
        &#34;&#34;&#34;
        self.set_note(&#39;&#39;, no_date=True)

    def set_note(self, note, no_date=False):
        &#34;&#34;&#34;
        Set the event&#39;s note. Desctructive action.
        &#34;&#34;&#34;
        the_id = self.get_id()
        
        if isinstance(the_id, str):

            if len(note) &gt;= 4000:
                log.warning(&#34;The note is longer than 4000 characters, only the&#34; 
                            &#34;first 4000 characters will be kept. The maximum&#34; 
                            &#34;accepted by the SIEM is 4096 characters.&#34;)
                note=note[:4000]+&#39;\n\n--NOTE HAS BEEN TRUNCATED--&#39;
            
            if no_date==False:
                timestamp = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)
                note = note.replace(&#39;&#34;&#39;,&#39;\\&#34;&#39;).replace(&#39;\n&#39;,&#39;\\n&#39;)
                note = timestamp + &#39; - &#39; + note
            
            self.nitro.request(&#34;add_note_to_event_int&#34;, 
                id=the_id,
                note=note)
        else :
            log.error(&#34;Couldn&#39;t set event&#39;s note, the event ID hasn&#39;t been found. Event: {}&#34;.format(self))
        
    def data_from_id(self, id, use_query=False, extra_fields=[]):
        &#34;&#34;&#34;
        Load event&#39;s data.  

        Arguments:   

        - `id` : The event ID. (i.e. : `144128388087414784|747122896`)  
        - `use_query` : Uses the query module to retreive common event data. Only works with SIEM 11.2 or greater.    
        Default behaviour will call `ipsGetAlertData` to retreive the complete event definition.  
        - `extra_fields` : Only when `use_query=True`. Additionnal event fields to load in the query.  
        &#34;&#34;&#34;
        
        if use_query == True :
            f = FieldFilter(&#39;IPSIDAlertID&#39;, id, operator=&#39;EQUALS&#39;)
            e = EventManager(
                time_range=&#39;CUSTOM&#39;,
                start_time=datetime.now()-timedelta(days=365),
                end_time=datetime.now()+timedelta(days=1),
                filters=[f],
                fields=extra_fields,
                limit=2)
            try:
                e.load_data()
            except NitroError:
                log.error(&#34;Query failed, can&#39;t load event&#39;s data from id with 1 year timerange, looking at the last 45 days only...&#34;)
                e.start_time=datetime.now()-timedelta(days=45)
                e.load_data()

            if len(e) == 1 :
                return e[0]
            else :
                raise NitroError(&#39;Could not load event : &#39;+str(id)+&#39; from query :&#39;+str(e.__dict__)+&#39;. Try with use_query=False.&#39;)

        elif use_query == False :
            return self.nitro.request(&#39;get_alert_data&#39;, id=id)

    def refresh(self): 
        &#34;&#34;&#34;Re-load event&#39;s data&#34;&#34;&#34;
        if &#39;Alert.IPSIDAlertID&#39; in self.data.keys() :
            # ensure to re-use the query module if that&#39;s the case
            self.data.update(self.data_from_id(self.data[&#39;Alert.IPSIDAlertID&#39;], 
                use_query=True, extra_fields=self.data.keys()))
        else :
            the_id = self.get_id()
            self.data.update(self.data_from_id(the_id))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="msiempy.core.types.NitroDict" href="core/types.html#msiempy.core.types.NitroDict">NitroDict</a></li>
<li>collections.UserDict</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="msiempy.core.types.NitroObject" href="core/types.html#msiempy.core.types.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.event.Event.FIELDS_TABLES"><code class="name">var <span class="ident">FIELDS_TABLES</span></code></dt>
<dd>
<div class="desc"><p>List of internal fields table : <code>Rule</code>,<code>Alert</code>,etc.</p></div>
</dd>
<dt id="msiempy.event.Event.DEFAULTS_EVENT_FIELDS"><code class="name">var <span class="ident">DEFAULTS_EVENT_FIELDS</span></code></dt>
<dd>
<div class="desc"><p>Always present when using <code><a title="msiempy.event.EventManager" href="#msiempy.event.EventManager">EventManager</a></code> querying :<br>
<code>Rule.msg</code><br>
<code>Alert.LastTime</code><br>
<code>Alert.IPSIDAlertID</code></p></div>
</dd>
<dt id="msiempy.event.Event.REGULAR_EVENT_FIELDS"><code class="name">var <span class="ident">REGULAR_EVENT_FIELDS</span></code></dt>
<dd>
<div class="desc"><p>List of regular event fields.
</p>
<p><code>Rule.msg</code><br>
<code>Alert.SrcIP</code><br>
<code>Alert.DstIP</code> <br>
<code>Alert.SrcMac</code><br>
<code>Alert.DstMac</code><br>
<code>Rule.NormID</code><br>
<code>HostID</code><br>
<code>UserIDSrc</code><br>
<code>ObjectID</code><br>
<code>Alert.Severity</code><br>
<code>Alert.LastTime</code><br>
<code>Alert.DSIDSigID</code><br>
<code>Alert.IPSIDAlertID</code></p></div>
</dd>
<dt id="msiempy.event.Event.SIEM_FIELDS_MAP_INTERNAL_NAME_TO_NICKNAME"><code class="name">var <span class="ident">SIEM_FIELDS_MAP_INTERNAL_NAME_TO_NICKNAME</span></code></dt>
<dd>
<div class="desc"><p>Fields name mapping.</p></div>
</dd>
<dt id="msiempy.event.Event.SIEM_FIELDS_MAP_NICKNAME_TO_INTERNAL_NAME"><code class="name">var <span class="ident">SIEM_FIELDS_MAP_NICKNAME_TO_INTERNAL_NAME</span></code></dt>
<dd>
<div class="desc"><p>Fields name mapping (reversed).</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.event.Event.get_id"><code class="name flex">
<span>def <span class="ident">get_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the event ID.<br>
Try to return <code>e['Alert.IPSIDAlertID']</code> or e['eventId']<code> or concatenate </code>e['ipsId']['id']<code> and </code>e['alertId']` depending of the Event dictionnary keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L1142-L1153" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_id(self):
    &#34;&#34;&#34;
    Get the event ID.  
    Try to return `e[&#39;Alert.IPSIDAlertID&#39;]` or e[&#39;eventId&#39;]` or concatenate `e[&#39;ipsId&#39;][&#39;id&#39;]` and `e[&#39;alertId&#39;]` depending of the Event dictionnary keys.  
    &#34;&#34;&#34;
    the_id = ( self.data[&#34;Alert.IPSIDAlertID&#34;] if ( &#34;Alert.IPSIDAlertID&#34; in self.data )
        else str(self.data[&#39;ipsId&#39;][&#39;id&#39;])+&#39;|&#39;+str(self.data[&#34;alertId&#34;]) if ( &#34;alertId&#34; in self.data )
        else self.data[&#34;eventId&#34;] if ( &#34;eventId&#34; in self.data ) else None )
    if the_id:
        return the_id
    else:
        return None</code></pre>
</details>
</dd>
<dt id="msiempy.event.Event.clear_notes"><code class="name flex">
<span>def <span class="ident">clear_notes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace the notes by an empty string. Desctructive action.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L1155-L1159" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clear_notes(self):
    &#34;&#34;&#34;
    Replace the notes by an empty string. Desctructive action.
    &#34;&#34;&#34;
    self.set_note(&#39;&#39;, no_date=True)</code></pre>
</details>
</dd>
<dt id="msiempy.event.Event.set_note"><code class="name flex">
<span>def <span class="ident">set_note</span></span>(<span>self, note, no_date=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the event's note. Desctructive action.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L1161-L1184" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_note(self, note, no_date=False):
    &#34;&#34;&#34;
    Set the event&#39;s note. Desctructive action.
    &#34;&#34;&#34;
    the_id = self.get_id()
    
    if isinstance(the_id, str):

        if len(note) &gt;= 4000:
            log.warning(&#34;The note is longer than 4000 characters, only the&#34; 
                        &#34;first 4000 characters will be kept. The maximum&#34; 
                        &#34;accepted by the SIEM is 4096 characters.&#34;)
            note=note[:4000]+&#39;\n\n--NOTE HAS BEEN TRUNCATED--&#39;
        
        if no_date==False:
            timestamp = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)
            note = note.replace(&#39;&#34;&#39;,&#39;\\&#34;&#39;).replace(&#39;\n&#39;,&#39;\\n&#39;)
            note = timestamp + &#39; - &#39; + note
        
        self.nitro.request(&#34;add_note_to_event_int&#34;, 
            id=the_id,
            note=note)
    else :
        log.error(&#34;Couldn&#39;t set event&#39;s note, the event ID hasn&#39;t been found. Event: {}&#34;.format(self))</code></pre>
</details>
</dd>
<dt id="msiempy.event.Event.data_from_id"><code class="name flex">
<span>def <span class="ident">data_from_id</span></span>(<span>self, id, use_query=False, extra_fields=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Load event's data.
</p>
<p>Arguments:
</p>
<ul>
<li><code>id</code> : The event ID. (i.e. : <code>144128388087414784|747122896</code>)
</li>
<li><code>use_query</code> : Uses the query module to retreive common event data. Only works with SIEM 11.2 or greater.
<br>
Default behaviour will call <code>ipsGetAlertData</code> to retreive the complete event definition.
</li>
<li><code>extra_fields</code> : Only when <code>use_query=True</code>. Additionnal event fields to load in the query.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L1186-L1220" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def data_from_id(self, id, use_query=False, extra_fields=[]):
    &#34;&#34;&#34;
    Load event&#39;s data.  

    Arguments:   

    - `id` : The event ID. (i.e. : `144128388087414784|747122896`)  
    - `use_query` : Uses the query module to retreive common event data. Only works with SIEM 11.2 or greater.    
    Default behaviour will call `ipsGetAlertData` to retreive the complete event definition.  
    - `extra_fields` : Only when `use_query=True`. Additionnal event fields to load in the query.  
    &#34;&#34;&#34;
    
    if use_query == True :
        f = FieldFilter(&#39;IPSIDAlertID&#39;, id, operator=&#39;EQUALS&#39;)
        e = EventManager(
            time_range=&#39;CUSTOM&#39;,
            start_time=datetime.now()-timedelta(days=365),
            end_time=datetime.now()+timedelta(days=1),
            filters=[f],
            fields=extra_fields,
            limit=2)
        try:
            e.load_data()
        except NitroError:
            log.error(&#34;Query failed, can&#39;t load event&#39;s data from id with 1 year timerange, looking at the last 45 days only...&#34;)
            e.start_time=datetime.now()-timedelta(days=45)
            e.load_data()

        if len(e) == 1 :
            return e[0]
        else :
            raise NitroError(&#39;Could not load event : &#39;+str(id)+&#39; from query :&#39;+str(e.__dict__)+&#39;. Try with use_query=False.&#39;)

    elif use_query == False :
        return self.nitro.request(&#39;get_alert_data&#39;, id=id)</code></pre>
</details>
</dd>
<dt id="msiempy.event.Event.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-load event's data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L1222-L1230" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def refresh(self): 
    &#34;&#34;&#34;Re-load event&#39;s data&#34;&#34;&#34;
    if &#39;Alert.IPSIDAlertID&#39; in self.data.keys() :
        # ensure to re-use the query module if that&#39;s the case
        self.data.update(self.data_from_id(self.data[&#39;Alert.IPSIDAlertID&#39;], 
            use_query=True, extra_fields=self.data.keys()))
    else :
        the_id = self.get_id()
        self.data.update(self.data_from_id(the_id))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.core.types.NitroDict" href="core/types.html#msiempy.core.types.NitroDict">NitroDict</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.core.types.NitroDict.NitroJSONEncoder" href="core/types.html#msiempy.core.types.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.core.types.NitroDict.json" href="core/types.html#msiempy.core.types.NitroDict.json">json</a></code></li>
<li><code><a title="msiempy.core.types.NitroDict.nitro" href="core/types.html#msiempy.core.types.NitroObject.nitro">nitro</a></code></li>
<li><code><a title="msiempy.core.types.NitroDict.text" href="core/types.html#msiempy.core.types.NitroDict.text">text</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="msiempy.event.GroupFilter"><code class="flex name class">
<span>class <span class="ident">GroupFilter</span></span>
<span>(</span><span>filters, logic='AND')</span>
</code></dt>
<dd>
<div class="desc"><p>Based on EsmFilterGroup. See SIEM api doc.
Used to dump groups of filters in the right format.</p>
<p>Arguments :
</p>
<ul>
<li><code>filters</code> : a list of filters. Filters can be <code><a title="msiempy.event.FieldFilter" href="#msiempy.event.FieldFilter">FieldFilter</a></code> or <code><a title="msiempy.event.GroupFilter" href="#msiempy.event.GroupFilter">GroupFilter</a></code>
</li>
<li><code>logic</code> : 'AND' or 'OR'</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L1236-L1255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GroupFilter(_QueryFilter):
    &#34;&#34;&#34;
        Based on EsmFilterGroup. See SIEM api doc.
        Used to dump groups of filters in the right format.

        Arguments :  

        - `filters` : a list of filters. Filters can be `msiempy.event.FieldFilter` or `msiempy.event.GroupFilter`    
        - `logic` : &#39;AND&#39; or &#39;OR&#39;  
    &#34;&#34;&#34;

    def __init__(self, filters, logic=&#39;AND&#39;) :
        super().__init__()
        
        #Declaring attributes
        self.data={
            &#34;type&#34;: &#34;EsmFilterGroup&#34;,
            &#34;filters&#34;: [dict(f) for f in filters],
            &#34;logic&#34;:logic
            }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>msiempy.event._QueryFilter</li>
<li>collections.UserDict</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
</dd>
<dt id="msiempy.event.FieldFilter"><code class="flex name class">
<span>class <span class="ident">FieldFilter</span></span>
<span>(</span><span>name, values, operator='IN')</span>
</code></dt>
<dd>
<div class="desc"><p>Based on EsmFieldFilter SIEM api doc.
</p>
<p>This class is automatically used when instanciating <code><a title="msiempy.event.EventManager" href="#msiempy.event.EventManager">EventManager</a></code> objects to dump filters in the right <code>dict</code> format if tuples are gave as the <code>filters</code> argument like:
</p>
<pre><code>e = EventManager(time_range='LAST_MINUTE', filters=[ ('SrcIP', ['10.5.0.0/16']) ])
</code></pre>
<p>Default operator is <code>"IN"</code>.
</p>
<p>To change the operator, create a <code><a title="msiempy.event.FieldFilter" href="#msiempy.event.FieldFilter">FieldFilter</a></code>:<br>
Exemple to filter by Signature ID.
</p>
<pre><code>e = EventManager(time_range='LAST_24_HOURS', filters=[ FieldFilter('DSIDSigID', [&quot;49190-4294967295&quot;], operator='EQUALS') ])
</code></pre>
<p><em>Make sure the filter name is valid by checking the result of <code><a title="msiempy.event.EventManager.get_possible_filters" href="#msiempy.event.EventManager.get_possible_filters">EventManager.get_possible_filters()</a></code> or use the provided script in the sample folder</em></p>
<h2 id="arguments">Arguments</h2>
<ul>
<li><code>name</code> : field name as string. Field name property. Example : <code>SrcIP</code>. See full list here: <a href="https://github.com/mfesiem/msiempy/blob/master/static/all_filters.json">https://github.com/mfesiem/msiempy/blob/master/static/all_filters.json</a></li>
<li><code>values</code> : list of values the field is going to be tested againts with the specified orperator.
</li>
<li><code>orperator</code> : <code>IN</code>,
<code>NOT_IN</code>,
<code>GREATER_THAN</code>,
<code>LESS_THAN</code>,
<code>GREATER_OR_EQUALS_THAN</code>,
<code>LESS_OR_EQUALS_THAN</code>,
<code>NUMERIC_EQUALS</code>,
<code>NUMERIC_NOT_EQUALS</code>,
<code>DOES_NOT_EQUAL</code>,
<code>EQUALS</code>,
<code>CONTAINS</code>,
<code>DOES_NOT_CONTAIN</code>,
<code>REGEX</code>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L1257-L1694" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class FieldFilter(_QueryFilter):
    &#34;&#34;&#34;
    Based on EsmFieldFilter SIEM api doc.  

    This class is automatically used when instanciating `EventManager` objects to dump filters in the right `dict` format if tuples are gave as the `filters` argument like:  

    ```
    e = EventManager(time_range=&#39;LAST_MINUTE&#39;, filters=[ (&#39;SrcIP&#39;, [&#39;10.5.0.0/16&#39;]) ])
    ```

    Default operator is `&#34;IN&#34;`.  
    
    To change the operator, create a `FieldFilter`:  
    Exemple to filter by Signature ID.  

    ```
    e = EventManager(time_range=&#39;LAST_24_HOURS&#39;, filters=[ FieldFilter(&#39;DSIDSigID&#39;, [&#34;49190-4294967295&#34;], operator=&#39;EQUALS&#39;) ])
    ```

    *Make sure the filter name is valid by checking the result of `msiempy.event.EventManager.get_possible_filters` or use the provided script in the sample folder*

    Arguments:

        - `name` : field name as string. Field name property. Example : `SrcIP`. See full list here: https://github.com/mfesiem/msiempy/blob/master/static/all_filters.json
        - `values` : list of values the field is going to be tested againts with the specified orperator.  
        - `orperator` : `IN`,
        `NOT_IN`,
        `GREATER_THAN`,
        `LESS_THAN`,
        `GREATER_OR_EQUALS_THAN`,
        `LESS_OR_EQUALS_THAN`,
        `NUMERIC_EQUALS`,
        `NUMERIC_NOT_EQUALS`,
        `DOES_NOT_EQUAL`,
        `EQUALS`,
        `CONTAINS`,
        `DOES_NOT_CONTAIN`,
        `REGEX`.  
    &#34;&#34;&#34;

    # Declaring static value containing all the possibles
    # event fields usable in filters should be loaded once, when instanciating a FieldFilter

    # Basically [ item.get(&#39;name&#39;) for item in EventManager().get_possible_filters() ]
    DOCUMENTED_FILTERS = [
        &#34;IPSIDAlertID&#34;, # IPSIDAlertID has been manually added to this list
        &#39;AppID&#39;,
        &#39;CommandID&#39;,
        &#39;DomainID&#39;,
        &#39;HostID&#39;,
        &#39;ObjectID&#39;,
        &#39;UserIDDst&#39;,
        &#39;UserIDSrc&#39;,
        &#39;URL&#39;,
        &#39;Database_Name&#39;,
        &#39;Message_Text&#39;,
        &#39;Response_Time&#39;,
        &#39;Application_Protocol&#39;,
        &#39;Object_Type&#39;,
        &#39;Filename&#39;,
        &#39;From&#39;,
        &#39;To&#39;,
        &#39;Cc&#39;,
        &#39;Bcc&#39;,
        &#39;Subject&#39;,
        &#39;Method&#39;,
        &#39;User_Agent&#39;,
        &#39;Cookie&#39;,
        &#39;Referer&#39;,
        &#39;File_Operation&#39;,
        &#39;File_Operation_Succeeded&#39;,
        &#39;Destination_Filename&#39;,
        &#39;User_Nickname&#39;,
        &#39;Contact_Name&#39;,
        &#39;Contact_Nickname&#39;,
        &#39;Client_Version&#39;,
        &#39;Job_Name&#39;,
        &#39;Language&#39;,
        &#39;SWF_URL&#39;,
        &#39;TC_URL&#39;,
        &#39;RTMP_Application&#39;,
        &#39;Version&#39;,
        &#39;Local_User_Name&#39;,
        &#39;NAT_Details&#39;,
        &#39;Network_Layer&#39;,
        &#39;Transport_Layer&#39;,
        &#39;Session_Layer&#39;,
        &#39;Application_Layer&#39;,
        &#39;HTTP_Layer&#39;,
        &#39;HTTP_Req_URL&#39;,
        &#39;HTTP_Req_Cookie&#39;,
        &#39;HTTP_Req_Referer&#39;,
        &#39;HTTP_Req_Host&#39;,
        &#39;HTTP_Req_Method&#39;,
        &#39;HTTP_User_Agent&#39;,
        &#39;DNS_Name&#39;,
        &#39;DNS_Type&#39;,
        &#39;DNS_Class&#39;,
        &#39;Query_Response&#39;,
        &#39;Authoritative_Answer&#39;,
        &#39;SNMP_Operation&#39;,
        &#39;SNMP_Item_Type&#39;,
        &#39;SNMP_Version&#39;,
        &#39;SNMP_Error_Code&#39;,
        &#39;NTP_Client_Mode&#39;,
        &#39;NTP_Server_Mode&#39;,
        &#39;NTP_Request&#39;,
        &#39;NTP_Opcode&#39;,
        &#39;SNMP_Item&#39;,
        &#39;Interface&#39;,
        &#39;Direction&#39;,
        &#39;Sensor_Name&#39;,
        &#39;Sensor_UUID&#39;,
        &#39;Sensor_Type&#39;,
        &#39;Signature_Name&#39;,
        &#39;Threat_Name&#39;,
        &#39;Destination_Hostname&#39;,
        &#39;Category&#39;,
        &#39;Process_Name&#39;,
        &#39;Grid_Master_IP&#39;,
        &#39;Response_Code&#39;,
        &#39;Device_Port&#39;,
        &#39;Device_IP&#39;,
        &#39;PID&#39;,
        &#39;Target_Context&#39;,
        &#39;Source_Context&#39;,
        &#39;Target_Class&#39;,
        &#39;Policy_Name&#39;,
        &#39;Destination_Zone&#39;,
        &#39;Source_Zone&#39;,
        &#39;Queue_ID&#39;,
        &#39;Delivery_ID&#39;,
        &#39;Recipient_ID&#39;,
        &#39;Spam_Score&#39;,
        &#39;Mail_ID&#39;,
        &#39;To_Address&#39;,
        &#39;From_Address&#39;,
        &#39;Message_ID&#39;,
        &#39;Request_Type&#39;,
        &#39;SQL_Statement&#39;,
        &#39;External_EventID&#39;,
        &#39;Event_Class&#39;,
        &#39;Description&#39;,
        &#39;File_Hash&#39;,
        &#39;Mainframe_Job_Name&#39;,
        &#39;External_SubEventID&#39;,
        &#39;Destination_UserID&#39;,
        &#39;Source_UserID&#39;,
        &#39;Volume_ID&#39;,
        &#39;Step_Name&#39;,
        &#39;Step_Count&#39;,
        &#39;LPAR_DB2_Subsystem&#39;,
        &#39;Logical_Unit_Name&#39;,
        &#39;Job_Type&#39;,
        &#39;FTP_Command&#39;,
        &#39;File_Type&#39;,
        &#39;DB2_Plan_Name&#39;,
        &#39;Catalog_Name&#39;,
        &#39;Access_Resource&#39;,
        &#39;Table_Name&#39;,
        &#39;External_DB2_Server&#39;,
        &#39;External_Application&#39;,
        &#39;Creator_Name&#39;,
        &#39;Return_Code&#39;,
        &#39;Database_ID&#39;,
        &#39;Incoming_ID&#39;,
        &#39;Handle_ID&#39;,
        &#39;Destination_Network&#39;,
        &#39;Source_Network&#39;,
        &#39;Malware_Insp_Result&#39;,
        &#39;Malware_Insp_Action&#39;,
        &#39;External_Hostname&#39;,
        &#39;Privileged_User&#39;,
        &#39;Facility&#39;,
        &#39;Area&#39;,
        &#39;Instance_GUID&#39;,
        &#39;Logon_Type&#39;,
        &#39;Operating_System&#39;,
        &#39;File_Path&#39;,
        &#39;Agent_GUID&#39;,
        &#39;Reputation&#39;,
        &#39;URL_Category&#39;,
        &#39;Session_Status&#39;,
        &#39;Destination_Logon_ID&#39;,
        &#39;Source_Logon_ID&#39;,
        &#39;UUID&#39;,
        &#39;External_SessionID&#39;,
        &#39;Management_Server&#39;,
        &#39;Detection_Method&#39;,
        &#39;Target_Process_Name&#39;,
        &#39;Analyzer_DAT_Version&#39;,
        &#39;Forwarding_Status&#39;,
        &#39;Reason&#39;,
        &#39;Threat_Handled&#39;,
        &#39;Threat_Category&#39;,
        &#39;Device_Action&#39;,
        &#39;Database_GUID&#39;,
        &#39;SQL_Command&#39;,
        &#39;Destination_Directory&#39;,
        &#39;Directory&#39;,
        &#39;Mailbox&#39;,
        &#39;Handheld_ID&#39;,
        &#39;Policy_ID&#39;,
        &#39;Server_ID&#39;,
        &#39;Registry_Value&#39;,
        &#39;Registry_Key&#39;,
        &#39;Caller_Process&#39;,
        &#39;DAT_Version&#39;,
        &#39;Interface_Dest&#39;,
        &#39;Datacenter_Name&#39;,
        &#39;Datacenter_ID&#39;,
        &#39;Virtual_Machine_ID&#39;,
        &#39;Virtual_Machine_Name&#39;,
        &#39;PCAP_Name&#39;,
        &#39;Search_Query&#39;,
        &#39;Service_Name&#39;,
        &#39;External_Device_Name&#39;,
        &#39;External_Device_ID&#39;,
        &#39;External_Device_Type&#39;,
        &#39;Organizational_Unit&#39;,
        &#39;Privileges&#39;,
        &#39;Reputation_Name&#39;,
        &#39;Vulnerability_References&#39;,
        &#39;Web_Domain&#39;,
        &#39;Sub_Status&#39;,
        &#39;Status&#39;,
        &#39;Access_Privileges&#39;,
        &#39;Rule_Name&#39;,
        &#39;App_Layer_Protocol&#39;,
        &#39;Group_Name&#39;,
        &#39;Authentication_Type&#39;,
        &#39;New_Value&#39;,
        &#39;Old_Value&#39;,
        &#39;Security_ID&#39;,
        &#39;SHA1&#39;,
        &#39;Reputation_Score&#39;,
        &#39;Parent_File_Hash&#39;,
        &#39;File_ID&#39;,
        &#39;Engine_List&#39;,
        &#39;Device_URL&#39;,
        &#39;Attacker_IP&#39;,
        &#39;Victim_IP&#39;,
        &#39;Incident_ID&#39;,
        &#39;Attribute_Type&#39;,
        &#39;Access_Mask&#39;,
        &#39;Object_GUID&#39;,
        &#39;VPN_Feature_Name&#39;,
        &#39;Reputation_Server_IP&#39;,
        &#39;DNS_Server_IP&#39;,
        &#39;Hash_Type&#39;,
        &#39;Hash&#39;,
        &#39;Subcategory&#39;,
        &#39;Wireless_SSID&#39;,
        &#39;Share_Name&#39;,
        &#39;CnC_Host&#39;,
        &#39;Device_Confidence&#39;,
        &#39;SHA256&#39;,
        &#39;DSIDSigID&#39;,
        &#39;ZoneSrc&#39;,
        &#39;Action&#39;,
        &#39;ASNGeoDst&#39;,
        &#39;FirstTime&#39;,
        &#39;SrcPort&#39;,
        &#39;AvgSeverity&#39;,
        &#39;DSID&#39;,
        &#39;DstPort&#39;,
        &#39;SrcIP&#39;,
        &#39;ZoneDst&#39;,
        &#39;SigID&#39;,
        &#39;GUIDSrc&#39;,
        &#39;GUIDDst&#39;,
        &#39;DstIP&#39;,
        &#39;ID&#39;,
        &#39;Protocol&#39;,
        &#39;NormID&#39;,
        &#39;SrcMac&#39;,
        &#39;SessionID&#39;,
        &#39;ASNGeoSrc&#39;,
        &#39;DstMac&#39;,
        &#39;LastTime&#39;]
    &#34;&#34;&#34; List fo documented filter names, show a warning if trying to filter on a unknown filter name &#34;&#34;&#34;

    def __init__(self, name, values, operator=&#39;IN&#39;) :
        super().__init__()

        #Declaring attributes
        self._operator=str()
        self._values=list()
        
        self.operator = operator
        self.values = values

        self.name = name
        &#34;&#34;&#34;
        Name of the field
        &#34;&#34;&#34;

        self.data={
            &#34;type&#34;: &#34;EsmFieldFilter&#34;,
            &#34;field&#34;: {&#34;name&#34;: self.name},
            &#34;operator&#34;: self.operator,
            &#34;values&#34;: self.values
            }
        
        # check the name against the list of possible filters and log warning if not present.  
        if name not in FieldFilter.DOCUMENTED_FILTERS :
            log.warning(&#34;You&#39;re using an undocumented filter name: &#39;{name}&#39;.  &#34;.format(name=name))
    
    POSSIBLE_OPERATORS=[&#39;IN&#39;,
        &#39;NOT_IN&#39;,
        &#39;GREATER_THAN&#39;,
        &#39;LESS_THAN&#39;,
        &#39;GREATER_OR_EQUALS_THAN&#39;,
        &#39;LESS_OR_EQUALS_THAN&#39;,
        &#39;NUMERIC_EQUALS&#39;,
        &#39;NUMERIC_NOT_EQUALS&#39;,
        &#39;DOES_NOT_EQUAL&#39;,
        &#39;EQUALS&#39;,
        &#39;CONTAINS&#39;,
        &#39;DOES_NOT_CONTAIN&#39;,
        &#39;REGEX&#39;]
    &#34;&#34;&#34;List of possibles operators&#34;&#34;&#34;

    POSSIBLE_VALUE_TYPES=[
            {&#39;type&#39;:&#39;EsmWatchlistValue&#39;,    &#39;key&#39;:&#39;watchlist&#39;},
            {&#39;type&#39;:&#39;EsmVariableValue&#39;,     &#39;key&#39;:&#39;variable&#39;},
            {&#39;type&#39;:&#39;EsmBasicValue&#39;,        &#39;key&#39;:&#39;value&#39;},
            {&#39;type&#39;:&#39;EsmCompoundValue&#39;,     &#39;key&#39;:&#39;values&#39;}]
    &#34;&#34;&#34;
    List of possible value type. See `msiempy.event.FieldFilter.add_value`.
    &#34;&#34;&#34;

    @property
    def operator(self):
        &#34;&#34;&#34;Filter operator.  
        Throws `AttributeError` if trying to set an unknown operator.  
        &#34;&#34;&#34;
        return (self._operator)
    
    @operator.setter
    def operator(self, operator):
        if operator in self.POSSIBLE_OPERATORS :
            self._operator = operator
        else:
            raise AttributeError(&#34;Illegal value for the filter operator: &#34;+str(operator)+&#34;. The operator must be in &#34;+str(self.POSSIBLE_OPERATORS))

    @property
    def values(self):
        &#34;&#34;&#34;List of values of the filter.  
        Setter iterate trough the list and call : 

        - `msiempy.event.FieldFilter.add_value()` if value is a `dict`
        - `msiempy.event.FieldFilter.add_basic_value()` if value type is `int`, `float` or `str`.

        Values will always be added to the filter. To remove values, handle directly the `_values` property.

        Example :  
            `filter = FieldFilter(name=&#39;DstIP&#39;,values=[{&#39;type&#39;:&#39;EsmWatchlistValue&#39;, &#39;watchlist&#39;:42}], operator=&#39;IN&#39;)`
        &#34;&#34;&#34;
        return (self._values)

    @values.setter  
    def values(self, values):
        if isinstance(values, list): 

            for val in values :
                if isinstance(val, dict):
                    self.add_value(**val)

                elif isinstance(val, (int, float, str)) :
                    self.add_basic_value(val)

                else:
                    raise TypeError(&#34;Invalid filter type, must be a list, int, float or str&#34;)
        
        elif isinstance(values, dict):
            self.add_value(**values)

        elif isinstance(values, (int, float, str)) :
            self.add_basic_value(values)
        
        else :
            raise TypeError(&#34;Invalid filter type, must be a list, int, float or str&#34;)
        
    def add_value(self, type=None, **kwargs):
        &#34;&#34;&#34;
        Add a new value to the filter.  
        
        Arguments (`**kwargs` depends on the value `type`):  

        - `type` (`str`) : Type of the value    

        Dynamic arguments:  
        
        - `value` (`str`) : If `type` is `EsmBasicValue`  
        - `watchlist` (`int`) : if `type` is `EsmWatchlistValue`    
        - `variable` (`int`) if `type` is `EsmVariableValue`    
        - `values` (`list`) if `type` is `EsmCompoundValue`  
        
        Raises : `KeyError` or `AttributeError` if you don&#39;t respect the correct type/key/value combo.  
        Note : Filtering query with other type of filter than `EsmBasicValue` is not tested.
        &#34;&#34;&#34;
        try:
            type_template=None
            
            #Look for the type of the object ex EsmBasicValue
            # it&#39; used to know the type and name of value parameter we should receive next
            for possible_value_type in self.POSSIBLE_VALUE_TYPES :
                if possible_value_type[&#39;type&#39;] == type :
                    type_template=possible_value_type
                    if type != &#39;EsmBasicValue&#39; :
                        log.warning(&#34;Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.&#34;)                            
                    break

            #Error throwing
            if type_template != None :
                if type_template[&#39;key&#39;] in kwargs :
                    
                    # Adds a new value to a fields filter
                    # Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.
                    value = kwargs[type_template[&#39;key&#39;]]
                    if type == &#39;EsmBasicValue&#39; :
                        value=str(value)
                        #log.debug(&#39;Adding a basic value to filter (&#39;+self.text+&#39;) : &#39;+value)
                    self._values.append({&#39;type&#39;:type, type_template[&#39;key&#39;]:value})
                    #log.debug(&#39;The value was appended to the list: &#39;+str(self))
                    
                #Error throwing
                else: raise KeyError (&#39;The valid key value argument is not present&#39;)
            else: raise KeyError (&#39;Impossible filter&#39;)
        except KeyError as err:
            raise AttributeError(&#34;You must provide a valid named Arguments containing the type and values for this filter. The type/keys must be in &#34;+str(self.POSSIBLE_VALUE_TYPES)+&#34;Can&#39;t be type=&#34;+str(type)+&#39; &#39;+str(kwargs)+&#34;. Additionnal indicator :&#34;+str(err) )

    def add_basic_value(self, value):
        &#34;&#34;&#34;
        Wrapper arround `add_value` method to simply add a `EsmBasicValue`.
        &#34;&#34;&#34;
        self.add_value(type=&#39;EsmBasicValue&#39;, value=value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>msiempy.event._QueryFilter</li>
<li>collections.UserDict</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.event.FieldFilter.DOCUMENTED_FILTERS"><code class="name">var <span class="ident">DOCUMENTED_FILTERS</span></code></dt>
<dd>
<div class="desc"><p>List fo documented filter names, show a warning if trying to filter on a unknown filter name</p></div>
</dd>
<dt id="msiempy.event.FieldFilter.POSSIBLE_OPERATORS"><code class="name">var <span class="ident">POSSIBLE_OPERATORS</span></code></dt>
<dd>
<div class="desc"><p>List of possibles operators</p></div>
</dd>
<dt id="msiempy.event.FieldFilter.POSSIBLE_VALUE_TYPES"><code class="name">var <span class="ident">POSSIBLE_VALUE_TYPES</span></code></dt>
<dd>
<div class="desc"><p>List of possible value type. See <code><a title="msiempy.event.FieldFilter.add_value" href="#msiempy.event.FieldFilter.add_value">FieldFilter.add_value()</a></code>.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.event.FieldFilter.operator"><code class="name">var <span class="ident">operator</span></code></dt>
<dd>
<div class="desc"><p>Filter operator.<br>
Throws <code>AttributeError</code> if trying to set an unknown operator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L1589-L1594" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def operator(self):
    &#34;&#34;&#34;Filter operator.  
    Throws `AttributeError` if trying to set an unknown operator.  
    &#34;&#34;&#34;
    return (self._operator)</code></pre>
</details>
</dd>
<dt id="msiempy.event.FieldFilter.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<div class="desc"><p>List of values of the filter.<br>
Setter iterate trough the list and call : </p>
<ul>
<li><code><a title="msiempy.event.FieldFilter.add_value" href="#msiempy.event.FieldFilter.add_value">FieldFilter.add_value()</a></code> if value is a <code>dict</code></li>
<li><code><a title="msiempy.event.FieldFilter.add_basic_value" href="#msiempy.event.FieldFilter.add_basic_value">FieldFilter.add_basic_value()</a></code> if value type is <code>int</code>, <code>float</code> or <code>str</code>.</li>
</ul>
<p>Values will always be added to the filter. To remove values, handle directly the <code>_values</code> property.</p>
<p>Example :<br>
<code>filter = FieldFilter(name='DstIP',values=[{'type':'EsmWatchlistValue', 'watchlist':42}], operator='IN')</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L1603-L1616" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def values(self):
    &#34;&#34;&#34;List of values of the filter.  
    Setter iterate trough the list and call : 

    - `msiempy.event.FieldFilter.add_value()` if value is a `dict`
    - `msiempy.event.FieldFilter.add_basic_value()` if value type is `int`, `float` or `str`.

    Values will always be added to the filter. To remove values, handle directly the `_values` property.

    Example :  
        `filter = FieldFilter(name=&#39;DstIP&#39;,values=[{&#39;type&#39;:&#39;EsmWatchlistValue&#39;, &#39;watchlist&#39;:42}], operator=&#39;IN&#39;)`
    &#34;&#34;&#34;
    return (self._values)</code></pre>
</details>
</dd>
<dt id="msiempy.event.FieldFilter.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the field</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.event.FieldFilter.add_value"><code class="name flex">
<span>def <span class="ident">add_value</span></span>(<span>self, type=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new value to the filter.
</p>
<p>Arguments (<code>**kwargs</code> depends on the value <code>type</code>):
</p>
<ul>
<li><code>type</code> (<code>str</code>) : Type of the value
</li>
</ul>
<p>Dynamic arguments:
</p>
<ul>
<li><code>value</code> (<code>str</code>) : If <code>type</code> is <code>EsmBasicValue</code>
</li>
<li><code>watchlist</code> (<code>int</code>) : if <code>type</code> is <code>EsmWatchlistValue</code>
</li>
<li><code>variable</code> (<code>int</code>) if <code>type</code> is <code>EsmVariableValue</code>
</li>
<li><code>values</code> (<code>list</code>) if <code>type</code> is <code>EsmCompoundValue</code>
</li>
</ul>
<p>Raises : <code>KeyError</code> or <code>AttributeError</code> if you don't respect the correct type/key/value combo.<br>
Note : Filtering query with other type of filter than <code>EsmBasicValue</code> is not tested.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L1641-L1688" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_value(self, type=None, **kwargs):
    &#34;&#34;&#34;
    Add a new value to the filter.  
    
    Arguments (`**kwargs` depends on the value `type`):  

    - `type` (`str`) : Type of the value    

    Dynamic arguments:  
    
    - `value` (`str`) : If `type` is `EsmBasicValue`  
    - `watchlist` (`int`) : if `type` is `EsmWatchlistValue`    
    - `variable` (`int`) if `type` is `EsmVariableValue`    
    - `values` (`list`) if `type` is `EsmCompoundValue`  
    
    Raises : `KeyError` or `AttributeError` if you don&#39;t respect the correct type/key/value combo.  
    Note : Filtering query with other type of filter than `EsmBasicValue` is not tested.
    &#34;&#34;&#34;
    try:
        type_template=None
        
        #Look for the type of the object ex EsmBasicValue
        # it&#39; used to know the type and name of value parameter we should receive next
        for possible_value_type in self.POSSIBLE_VALUE_TYPES :
            if possible_value_type[&#39;type&#39;] == type :
                type_template=possible_value_type
                if type != &#39;EsmBasicValue&#39; :
                    log.warning(&#34;Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.&#34;)                            
                break

        #Error throwing
        if type_template != None :
            if type_template[&#39;key&#39;] in kwargs :
                
                # Adds a new value to a fields filter
                # Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.
                value = kwargs[type_template[&#39;key&#39;]]
                if type == &#39;EsmBasicValue&#39; :
                    value=str(value)
                    #log.debug(&#39;Adding a basic value to filter (&#39;+self.text+&#39;) : &#39;+value)
                self._values.append({&#39;type&#39;:type, type_template[&#39;key&#39;]:value})
                #log.debug(&#39;The value was appended to the list: &#39;+str(self))
                
            #Error throwing
            else: raise KeyError (&#39;The valid key value argument is not present&#39;)
        else: raise KeyError (&#39;Impossible filter&#39;)
    except KeyError as err:
        raise AttributeError(&#34;You must provide a valid named Arguments containing the type and values for this filter. The type/keys must be in &#34;+str(self.POSSIBLE_VALUE_TYPES)+&#34;Can&#39;t be type=&#34;+str(type)+&#39; &#39;+str(kwargs)+&#34;. Additionnal indicator :&#34;+str(err) )</code></pre>
</details>
</dd>
<dt id="msiempy.event.FieldFilter.add_basic_value"><code class="name flex">
<span>def <span class="ident">add_basic_value</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper arround <code>add_value</code> method to simply add a <code>EsmBasicValue</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/mfesiem/msiempy/blob/422ac1139632874c40ab60c97f7fdb8846229fd3/msiempy/event.py#L1690-L1694" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_basic_value(self, value):
    &#34;&#34;&#34;
    Wrapper arround `add_value` method to simply add a `EsmBasicValue`.
    &#34;&#34;&#34;
    self.add_value(type=&#39;EsmBasicValue&#39;, value=value)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="McAfee SIEM API Python wrapper" href="https://mfesiem.github.io/docs/msiempy/index.html">
<img src="https://avatars0.githubusercontent.com/u/50667087?s=200&v=4" alt=""> &nbsp; msiempy
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = 'search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="msiempy" href="index.html">msiempy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="msiempy.event.EventManager" href="#msiempy.event.EventManager">EventManager</a></code></h4>
<ul class="">
<li><code><a title="msiempy.event.EventManager.add_filter" href="#msiempy.event.EventManager.add_filter">add_filter</a></code></li>
<li><code><a title="msiempy.event.EventManager.clear_filters" href="#msiempy.event.EventManager.clear_filters">clear_filters</a></code></li>
<li><code><a title="msiempy.event.EventManager.qry_load_data" href="#msiempy.event.EventManager.qry_load_data">qry_load_data</a></code></li>
<li><code><a title="msiempy.event.EventManager.load_data" href="#msiempy.event.EventManager.load_data">load_data</a></code></li>
<li><code><a title="msiempy.event.EventManager.get_possible_fields" href="#msiempy.event.EventManager.get_possible_fields">get_possible_fields</a></code></li>
<li><code><a title="msiempy.event.EventManager.get_possible_filters" href="#msiempy.event.EventManager.get_possible_filters">get_possible_filters</a></code></li>
<li><code><a title="msiempy.event.EventManager.order" href="#msiempy.event.EventManager.order">order</a></code></li>
<li><code><a title="msiempy.event.EventManager.filters" href="#msiempy.event.EventManager.filters">filters</a></code></li>
<li><code><a title="msiempy.event.EventManager.POSSBILE_ROW_ORDER" href="#msiempy.event.EventManager.POSSBILE_ROW_ORDER">POSSBILE_ROW_ORDER</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.event.Event" href="#msiempy.event.Event">Event</a></code></h4>
<ul class="">
<li><code><a title="msiempy.event.Event.get_id" href="#msiempy.event.Event.get_id">get_id</a></code></li>
<li><code><a title="msiempy.event.Event.clear_notes" href="#msiempy.event.Event.clear_notes">clear_notes</a></code></li>
<li><code><a title="msiempy.event.Event.set_note" href="#msiempy.event.Event.set_note">set_note</a></code></li>
<li><code><a title="msiempy.event.Event.data_from_id" href="#msiempy.event.Event.data_from_id">data_from_id</a></code></li>
<li><code><a title="msiempy.event.Event.refresh" href="#msiempy.event.Event.refresh">refresh</a></code></li>
<li><code><a title="msiempy.event.Event.FIELDS_TABLES" href="#msiempy.event.Event.FIELDS_TABLES">FIELDS_TABLES</a></code></li>
<li><code><a title="msiempy.event.Event.DEFAULTS_EVENT_FIELDS" href="#msiempy.event.Event.DEFAULTS_EVENT_FIELDS">DEFAULTS_EVENT_FIELDS</a></code></li>
<li><code><a title="msiempy.event.Event.REGULAR_EVENT_FIELDS" href="#msiempy.event.Event.REGULAR_EVENT_FIELDS">REGULAR_EVENT_FIELDS</a></code></li>
<li><code><a title="msiempy.event.Event.SIEM_FIELDS_MAP_INTERNAL_NAME_TO_NICKNAME" href="#msiempy.event.Event.SIEM_FIELDS_MAP_INTERNAL_NAME_TO_NICKNAME">SIEM_FIELDS_MAP_INTERNAL_NAME_TO_NICKNAME</a></code></li>
<li><code><a title="msiempy.event.Event.SIEM_FIELDS_MAP_NICKNAME_TO_INTERNAL_NAME" href="#msiempy.event.Event.SIEM_FIELDS_MAP_NICKNAME_TO_INTERNAL_NAME">SIEM_FIELDS_MAP_NICKNAME_TO_INTERNAL_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.event.GroupFilter" href="#msiempy.event.GroupFilter">GroupFilter</a></code></h4>
</li>
<li>
<h4><code><a title="msiempy.event.FieldFilter" href="#msiempy.event.FieldFilter">FieldFilter</a></code></h4>
<ul class="">
<li><code><a title="msiempy.event.FieldFilter.add_value" href="#msiempy.event.FieldFilter.add_value">add_value</a></code></li>
<li><code><a title="msiempy.event.FieldFilter.add_basic_value" href="#msiempy.event.FieldFilter.add_basic_value">add_basic_value</a></code></li>
<li><code><a title="msiempy.event.FieldFilter.operator" href="#msiempy.event.FieldFilter.operator">operator</a></code></li>
<li><code><a title="msiempy.event.FieldFilter.values" href="#msiempy.event.FieldFilter.values">values</a></code></li>
<li><code><a title="msiempy.event.FieldFilter.name" href="#msiempy.event.FieldFilter.name">name</a></code></li>
<li><code><a title="msiempy.event.FieldFilter.DOCUMENTED_FILTERS" href="#msiempy.event.FieldFilter.DOCUMENTED_FILTERS">DOCUMENTED_FILTERS</a></code></li>
<li><code><a title="msiempy.event.FieldFilter.POSSIBLE_OPERATORS" href="#msiempy.event.FieldFilter.POSSIBLE_OPERATORS">POSSIBLE_OPERATORS</a></code></li>
<li><code><a title="msiempy.event.FieldFilter.POSSIBLE_VALUE_TYPES" href="#msiempy.event.FieldFilter.POSSIBLE_VALUE_TYPES">POSSIBLE_VALUE_TYPES</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<span>This software is licensed under the <a href="https://github.com/mfesiem/msiempy/blob/master/LICENSE">MIT License</a></span>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>msiempy.event API documentation</title>
<meta name="description" content="Provide event management." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>msiempy.event</code></h1>
</header>
<section id="section-intro">
<p>Provide event management.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Provide event management.
&#34;&#34;&#34;

import time
import json
import abc
import collections
import logging
import copy
from datetime import datetime, timedelta
log = logging.getLogger(&#39;msiempy&#39;)

from . import NitroDict, NitroError, FilteredQueryList
from .__utils__ import timerange_gettimes, parse_query_result, format_fields_for_query, divide_times, parse_timedelta

class EventManager(FilteredQueryList):
    &#34;&#34;&#34;Interface to query and manage events.  
    Inherits from `msiempy.FilteredQueryList`.

    Arguments:  

    - `fields` : list of strings representing all fields you want to apprear in the Events records.
        Get the list of possible fields by calling `msiempy.event.EventManager.get_possible_fields()` method or see `msiempy.event.Event`.
        Some default fields will be present. 
    - `order` : `tuple ((direction, field))`. Direction can be &#39;ASCENDING&#39; or &#39;DESCENDING&#39;.
    - `limit` : max number of rows per query.
    - `filters` : list of filters. A filter can be a `tuple(field, [values])` or it can be a `msiempy.event._QueryFilter` if you wish to use advanced filtering.
    - `time_range` : Query time range. String representation of a time range.  
    - `start_time` : Query starting time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  
    - `end_time` : Query endding time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  
    &#34;&#34;&#34; 

    #Constants
    #TODO Try grouped queries !
    TYPE=&#39;EVENT&#39;
    &#34;&#34;&#34;EVENT: Flow query or other are not implemented&#34;&#34;&#34;
    GROUPTYPE=&#39;NO_GROUP&#39;
    &#34;&#34;&#34;NO_GROUP: Group query is not implemented&#34;&#34;&#34;
    POSSBILE_ROW_ORDER=[
            &#39;ASCENDING&#39;,
            &#39;DESCENDING&#39;
    ]
    &#34;&#34;&#34;`ASCENDING` or `DESCENDING`&#34;&#34;&#34;

    # Declaring static value containing all the possibles
    # event fields, should be loaded once (when the session start ?)
    _possible_fields = []

    def __init__(self, *args, fields=None, 
        order=None, limit=500, filters=None, 
        __parent__=None, **kwargs):
        #Calling super constructor : time_range set etc...
        super().__init__(*args, **kwargs)

        #Store the query parent 
        self.__parent__=__parent__

        #Declaring attributes
        self._filters=list()
        
        #Setting the default fields Adds the specified fields, make sure there is no duplicates and delete TABLE identifiers
        if fields and len(fields)&gt;0: 
            self.fields=set(Event.DEFAULTS_EVENT_FIELDS+[f.split(&#39;.&#39;)[1] if &#39;.&#39; in f else f for f in list(fields)])
        else:
            self.fields=Event.DEFAULTS_EVENT_FIELDS
        #log.debug(&#39;{}\nFIELDS : {}&#39;.format(locals(), self.fields))

        #Setting limit according to config or limit argument
        #TODO Try to load queries with a limit of 10k and get result as chucks of 500 with starPost nbRows
        #   and compare efficiency
        self.limit=int(limit)
        
        self.order=order

        #TODO : find a solution not to use this
        #callign super().filters=filters #https://bugs.python.org/issue14965
        super(self.__class__, self.__class__).filters.__set__(self, filters)

        #Type cast all items in the list &#34;data&#34; to events type objects
        #Casting all data to Event objects, better way to do it ?
        collections.UserList.__init__(self, [Event(adict=item) for item in self.data if isinstance(item, (dict, NitroDict))])

    @property
    def order(self):
        &#34;&#34;&#34;
        Orders representing the what the SIEM is expecting as the &#39;order&#39;.
        The `order` must be tuple (direction, field).
        &#34;&#34;&#34;
        return((self._order_direction, self._order_field))

    @order.setter
    def order(self, order):
        if order:
            try:
                if order[0] not in self.POSSBILE_ROW_ORDER :
                    raise AttributeError(&#39;Order direction must be in &#39;+str(self.POSSBILE_ROW_ORDER))

                self._order_direction = order[0]
                self._order_field = order[1]
            except IndexError:
                raise ValueError(&#39;Order must be tuple (direction, field).&#39;)
        else:
            self._order_direction = &#39;DESCENDING&#39;
            self._order_field = &#39;LastTime&#39;
    @property
    def filters(self):
        &#34;&#34;&#34;
        JSON SIEM formatted filters for the query by calling reccursively : `msiempy.event._QueryFilter.config_dict`.
        See `msiempy.FilteredQueryList.filters`.
        &#34;&#34;&#34;
        return([dict(f) for f in self._filters])

    def add_filter(self, afilter):
        &#34;&#34;&#34;
        Concrete description of the `msiempy.FilteredQueryList` method.
        It can take a `tuple(fiels, [values])` or a `msiempy.event._QueryFilter` subclass.
        &#34;&#34;&#34;
        if isinstance(afilter, tuple) :
            self._filters.append(FieldFilter(afilter[0], afilter[1]))

        elif isinstance(afilter, _QueryFilter) :
            self._filters.append(afilter)
        
        else :
            raise NitroError(&#34;Sorry the filters must be either a tuple(fiels, [values]) or a _QueryFilter sub class.&#34;)

    def clear_filters(self):
        &#34;&#34;&#34;
        Replace all filters by a non filtering rule.
        Acts like the is not filters.
        &#34;&#34;&#34; 
        self._filters=[FieldFilter(&#39;SrcIP&#39;, [&#39;0.0.0.0/0&#39;,])]

    def get_possible_fields(self):
        &#34;&#34;&#34;
        Indicate a list of possible fields that you can request in a query.
        The list is loaded from the SIEM.
        &#34;&#34;&#34;
        return self.nitro.request(&#39;get_possible_fields&#39;, type=self.TYPE, groupType=self.GROUPTYPE)

    def qry_load_data(self, retry=2, wait_timeout_sec=120):
        &#34;&#34;&#34;
        Concrete helper method to execute the query and load the data :  
            -&gt; Submit the query  
            -&gt; Wait the query to be executed  
            -&gt; Get and parse the events  

        Arguments:

        - `retry` (`int`): number of time the query can be failed and retied
        - `wait_timeout_sec` (`int`): wait timeout in seconds

        Returns : `tuple` : (( `msiempy.event.EventManager`, Status of the query (completed?) `True/False` ))

        Can raise `msiempy.NitroError`: 

            - Query wait timeout -&gt; You might want to change the value of `wait_timeout_sec` argument !
            - Other errors
        &#34;&#34;&#34;
        query_infos=dict()

        #Queries api calls are very different if the time range is custom.
        if self.time_range == &#39;CUSTOM&#39; :
            query_infos=self.nitro.request(
                &#39;event_query_custom_time&#39;,
                time_range=self.time_range,
                start_time=self.start_time,
                end_time=self.end_time,
                order_direction=self._order_direction,
                order_field=self._order_field,
                fields=format_fields_for_query(self.fields),
                filters=self.filters,
                limit=self.limit,
                offset=0,
                includeTotal=False
                )

        else :
            query_infos=self.nitro.request(
                &#39;event_query&#39;,
                time_range=self.time_range,
                order_direction=self._order_direction,
                order_field=self._order_field,
                fields=format_fields_for_query(self.fields),
                filters=self.filters,
                limit=self.limit,
                offset=0,
                includeTotal=False
                )
        
        log.debug(&#34;Waiting for EsmRunningQuery object : &#34;+str(query_infos))
        try:
            self._wait_for(query_infos[&#39;resultID&#39;], wait_timeout_sec)
            events_raw=self._get_events(query_infos[&#39;resultID&#39;])
        except NitroError as error :
            if retry &gt;0 and any(match in str(error) for match in [&#39;ResultUnavailable&#39;,&#39;UnknownList&#39;, &#39;Query wait timeout&#39;]):
                log.warning(&#39;Retring after: &#39;+str(error))
                return self.qry_load_data(retry=retry-1)
            else: raise

        events=EventManager(alist=events_raw)
        self.data=events
        return((events,len(events)&lt;self.limit))

    def load_data(self, workers=10, slots=10, delta=None, max_query_depth=0, **kwargs):
        &#34;&#34;&#34;Load the data from the SIEM into the manager list.  
        Split the query in defferents time slots if the query apprears not to be completed.  
        Wraps around `msiempy.FilteredQueryList.qry_load_data`.    

        Note: Only the first query is loaded asynchronously.

        Arguments:  
    
        - `workers` : numbre of parrallels tasks, should be equal or less than the number of slots.  
        - `slots` : number of time slots the query can be divided. The loading bar is 
            divided according to the number of slots  
        - `delta` : exemple : &#39;6h30m&#39;, the query will be firstly divided in chuncks according to the time delta read
            with dateutil.  
        - `max_query_depth` : maximum number of supplement reccursions of division of the query times
        Meaning, if EventManager query limit=500, slots=5 and max_query_depth=3, then the maximum capacity of 
        the list is (500*5)*(500*5)*(500*5) = 15625000000
        - `retry` (`int`): number of time the query can be failed and retried
        - `wait_timeout_sec` (`int`): wait timeout in seconds


        Returns : `msiempy.event.EventManager`
        &#34;&#34;&#34;

        items, completed = self.qry_load_data()

        if not completed :
            #If not completed the query is split and items aren&#39;t actually used

            if max_query_depth &gt; 0 :
                #log.info(&#34;The query data couldn&#39;t be loaded in one request, separating it in sub-queries...&#34;)

                if self.time_range != &#39;CUSTOM&#39;: #can raise a NotImplementedError if unsupported time_range
                    start, end = timerange_gettimes(self.time_range)
                else :
                    start, end = self.start_time, self.end_time

                if self.__parent__ == None and isinstance(delta, str) :
                    #if it&#39;s the first query and delta is speficied, cut the time_range in slots according to the delta
                    times=divide_times(start, end, delta=parse_timedelta(delta))
                    
                else : 
                    times=divide_times(start, end, slots=slots)

                if workers &gt; len(times) :
                    log.warning(&#34;The numbre of slots is smaller than the number of workers, only &#34;+str(len(times))+&#34; asynch workers will be used when you could use up to &#34;+str(workers)+&#34;. Number of slots should be greater than the number of workers for better performance.&#34;)
                
                sub_queries=list()

                for time in times : #reversed(times) :
                    #Divide the query in sub queries
                    sub_query = EventManager(fields=self.fields, 
                        order=self.order, 
                        limit=self.limit,
                        filters=self._filters,
                        time_range=&#39;CUSTOM&#39;,
                        start_time=time[0].isoformat(),
                        end_time=time[1].isoformat(),

                         __parent__=self
                        )
                    
                    sub_queries.append(sub_query)
            
                results = self.perform(EventManager.load_data, sub_queries, 
                    #The sub query is asynch only when it&#39;s the first query (root parent)
                    asynch=self.__parent__==None,
                    progress=self.__parent__==None, 
                    message=&#39;Loading data from &#39;+start+&#39; to &#39;+end+&#39;. In {} slots&#39;.format(len(times)),
                    func_args=dict(slots=slots, max_query_depth=max_query_depth-1),
                    workers=workers)

                #Flatten the list of lists in a list
                items=[item for sublist in results for item in sublist]
                
            else :
                if not self.__root_parent__.not_completed :
                    log.warning(&#34;The query is not complete... Try to divide in more slots or increase the limit&#34;)
                    self.__root_parent__.not_completed=True

        self.data=items
        return(self)

    def _wait_for(self, resultID, wait_timeout_sec, sleep_time=0.2):
        &#34;&#34;&#34;
        Internal method called by qry_load_data
        Wait and sleep - for `sleep_time` duration in seconds -
            until the query is completed or retry countdown arrives at zero.    
        
        Return: `True`  

        Raises: 

        - `msiempy.NitroError`: &#39;ResultUnavailable&#39; error some times...
        - `msiempy.NitroError`: &#39;Query wait timeout&#39;
        &#34;&#34;&#34;
        # time_out=parse_timedelta(wait_timeout).total_seconds()
        # retry = wait_timeout_sec / sleep_time

        begin=datetime.now()
        timeout_delta=timedelta(seconds=wait_timeout_sec)

        log.debug(&#34;Waiting for the query to be executed on the SIEM...&#34;)
        
        while datetime.now()-timeout_delta &lt; begin :
            status = self.nitro.request(&#39;query_status&#39;, resultID=resultID)
            if status[&#39;complete&#39;] is True :
                return True
            else :
                time.sleep(sleep_time)
            # retry=retry-1
        raise NitroError(&#34;Query wait timeout. resultID={}, sleep_time={}, wait_timeout_sec={}&#34;.format(
            resultID, sleep_time, wait_timeout_sec))

    def _get_events(self, resultID, startPos=0, numRows=None):
        &#34;&#34;&#34;
        Internal method that will get the query events, 
            called by qry_load_data
        by default, numRows correspond to limit
        &#34;&#34;&#34;
        
        if not numRows :
            numRows=self.limit
                
        result=self.nitro.request(&#39;query_result&#39;,
            startPos=startPos,
            numRows=numRows,
            resultID=resultID)

        #Calls a utils function to parse the [columns][rows]
        #   to format into list of dict
        #log.debug(&#34;Parsing colums : &#34;+str(result[&#39;columns&#39;]))
        #log.debug(&#34;Parsing rows : &#34;+str(result[&#39;rows&#39;]))
        if len(result[&#39;columns&#39;]) != len(set([column[&#39;name&#39;] for column in result[&#39;columns&#39;]])) :
            log.error(&#34;You requested duplicated fields, the parsed fields/values results will be missmatched !&#34;)
        events=parse_query_result(result[&#39;columns&#39;], result[&#39;rows&#39;])
        #log.debug(&#34;Events parsed : &#34;+str(events))
        return events

    @property
    def __root_parent__(self):
        &#34;&#34;&#34;
        Internal method that return the first query of the query tree
        &#34;&#34;&#34;
        if self.__parent__==None:
            return self
        else :
            return self.__parent__.__root_parent__

    def get_possible_filters(self):
        &#34;&#34;&#34;
        Return all the fields that you can filter on in a query.
        &#34;&#34;&#34;
        return(self.nitro.request(&#39;get_possible_filters&#39;))
          
class Event(NitroDict):
    &#34;&#34;&#34;        
    Dictionary keys :  

    - `Rule.msg`  
    - `Alert.LastTime`  
    - `Alert.IPSIDAlertID`  
    - and others...  

    You can request more fields by passing a list of fields to the `msiempy.event.EventManager` object. 
    `msiempy.event.Event.REGULAR_EVENT_FIELDS` offer a base list of regular fields that may be useful.
    See msiempy/static JSON files to browse complete list : https://github.com/mfesiem/msiempy/blob/master/static/all_fields.json  
    You can also use this script to dinamically print the available fields and filters : https://github.com/mfesiem/msiempy/blob/master/samples/dump_all_fields.py  
    Prefixes `Alert.`, `Rule.`, etc are optionnal, prefix autocompletion is computed in any case within the `__getitem__` method ;)  

    Arguments:

    - `adict`: Event parameters  
    - `id`: The event `IPSIDAlertID` to instanciate. Will load informations
    &#34;&#34;&#34;
   
    FIELDS_TABLES=[
        &#34;Alert&#34;,
        &#34;Rule&#34;,
        &#34;ADGroup&#34;,
        &#34;Action&#34;,
        &#34;Asset&#34;,
        &#34;AssetGroup&#34;,
        &#34;AssetThreat&#34;,
        &#34;CaseMgt&#34;,
        &#34;CaseOrg&#34;,
        &#34;CaseStatus&#34;,
        &#34;Class&#34;,
        &#34;Connection&#34;,
        &#34;DataEnrichment&#34;,
        &#34;GeoLoc_ASNGeoDst&#34;,
        &#34;GeoLoc_ASNGeoSrc&#34;,
        &#34;IOC&#34;,
        &#34;IPS&#34;,
        &#34;IPSCheck&#34;,
        &#34;NDDeviceInterface_NDDevIFDst&#34;,
        &#34;NDDeviceInterface_NDDevIFSrc&#34;,
        &#34;NDDevice_NDDevIDDst&#34;,
        &#34;NDDevice_NDDevIDSrc&#34;,
        &#34;OS&#34;,
        &#34;Rule_NDSNormSigID&#34;,
        &#34;Tag&#34;,
        &#34;TagAsset&#34;,
        &#34;ThirdPartyType&#34;,
        &#34;Threat&#34;,
        &#34;ThreatVendor&#34;,
        &#34;TriggeredAlarm&#34;,
        &#34;Users&#34;,
        &#34;Vulnerability&#34;,
        &#34;Zone_ZoneDst&#34;,
        &#34;Zone_ZoneSrc&#34;,
        ]
    &#34;&#34;&#34;List of internal fields table : `Rule`,`Alert`,etc.
    &#34;&#34;&#34;

    # Minimal default query fields
    DEFAULTS_EVENT_FIELDS=[&#34;msg&#34;, &#34;LastTime&#34;,&#34;IPSIDAlertID&#34;]
    &#34;&#34;&#34;Always present when using `msiempy.event.EventManager` querying :  
        `Rule.msg`  
        `Alert.LastTime`  
        `Alert.IPSIDAlertID`
    &#34;&#34;&#34;
    # Regular query fields
    REGULAR_EVENT_FIELDS=[
        &#34;Rule.msg&#34;,
        &#34;Alert.SrcIP&#34;,
        &#34;Alert.DstIP&#34;, 
        &#34;Alert.SrcMac&#34;,
        &#34;Alert.DstMac&#34;,
        &#34;Rule.NormID&#34;,
        &#34;HostID&#34;,
        &#34;UserIDSrc&#34;,
        &#34;ObjectID&#34;,
        &#34;Alert.Severity&#34;,
        &#34;Alert.LastTime&#34;,
        &#34;Alert.DSIDSigID&#34;,
        &#34;Alert.IPSIDAlertID&#34;]
    &#34;&#34;&#34;
        `Rule.msg`  
        `Alert.SrcIP`  
        `Alert.DstIP`   
        `Alert.SrcMac`  
        `Alert.DstMac`  
        `Rule.NormID`  
        `HostID`  
        `UserIDSrc`  
        `ObjectID`  
        `Alert.Severity`  
        `Alert.LastTime`  
        `Alert.DSIDSigID`  
        `Alert.IPSIDAlertID` 
    &#34;&#34;&#34;
    
    SIEM_FIELDS_MAP = {&#39;ASNGeoDst&#39;: &#39;Alert.ASNGeoDst&#39;,
    &#39;ASNGeoSrc&#39;: &#39;Alert.ASNGeoSrc&#39;,
    &#39;Access_Mask&#39;: &#39;Alert.65622&#39;,
    &#39;Access_Privileges&#39;: &#39;Alert.4259883&#39;,
    &#39;Access_Resource&#39;: &#39;Alert.65555&#39;,
    &#39;Action&#39;: &#39;Alert.Action&#39;,
    &#39;Action.Name&#39;: &#39;Action.Name&#39;,
    &#39;Agent_GUID&#39;: &#39;Alert.262162&#39;,
    &#39;Alert.105250817&#39;: &#39;DNS - Response_Code_Name&#39;,
    &#39;Alert.122028033&#39;: &#39;DNS - Query&#39;,
    &#39;Alert.196609&#39;: &#39;Queue_ID&#39;,
    &#39;Alert.21364737&#39;: &#39;DNS - Class&#39;,
    &#39;Alert.21364738&#39;: &#39;Registry - Key&#39;,
    &#39;Alert.21364739&#39;: &#39;Old_Reputation - GTI_File&#39;,
    &#39;Alert.21364740&#39;: &#39;New_Reputation - GTI_File&#39;,
    &#39;Alert.262145&#39;: &#39;Response_Time&#39;,
    &#39;Alert.262146&#39;: &#39;NAT_Details&#39;,
    &#39;Alert.262152&#39;: &#39;PID&#39;,
    &#39;Alert.262153&#39;: &#39;Grid_Master_IP&#39;,
    &#39;Alert.262154&#39;: &#39;Device_IP&#39;,
    &#39;Alert.262155&#39;: &#39;Device_Port&#39;,
    &#39;Alert.262156&#39;: &#39;External_EventID&#39;,
    &#39;Alert.262157&#39;: &#39;Spam_Score&#39;,
    &#39;Alert.262158&#39;: &#39;External_SubEventID&#39;,
    &#39;Alert.262159&#39;: &#39;File_Hash&#39;,
    &#39;Alert.262160&#39;: &#39;Handle_ID&#39;,
    &#39;Alert.262161&#39;: &#39;Instance_GUID&#39;,
    &#39;Alert.262162&#39;: &#39;Agent_GUID&#39;,
    &#39;Alert.262163&#39;: &#39;UUID&#39;,
    &#39;Alert.262164&#39;: &#39;Reputation&#39;,
    &#39;Alert.262165&#39;: &#39;DAT_Version&#39;,
    &#39;Alert.262166&#39;: &#39;Server_ID&#39;,
    &#39;Alert.262167&#39;: &#39;Policy_ID&#39;,
    &#39;Alert.262168&#39;: &#39;Handheld_ID&#39;,
    &#39;Alert.262169&#39;: &#39;Database_GUID&#39;,
    &#39;Alert.262170&#39;: &#39;Analyzer_DAT_Version&#39;,
    &#39;Alert.262171&#39;: &#39;Reputation_Score&#39;,
    &#39;Alert.262172&#39;: &#39;Parent_File_Hash&#39;,
    &#39;Alert.262173&#39;: &#39;Incident_ID&#39;,
    &#39;Alert.262174&#39;: &#39;Victim_IP&#39;,
    &#39;Alert.262175&#39;: &#39;Attacker_IP&#39;,
    &#39;Alert.262176&#39;: &#39;Object_GUID&#39;,
    &#39;Alert.262177&#39;: &#39;Reputation_Server_IP&#39;,
    &#39;Alert.262178&#39;: &#39;DNS_Server_IP&#39;,
    &#39;Alert.262179&#39;: &#39;Device_Confidence&#39;,
    &#39;Alert.38141953&#39;: &#39;DNS - Class_Name&#39;,
    &#39;Alert.38141954&#39;: &#39;Registry - Value&#39;,
    &#39;Alert.38141955&#39;: &#39;Old_Reputation - TIE_File&#39;,
    &#39;Alert.38141956&#39;: &#39;New_Reputation - TIE_File&#39;,
    &#39;Alert.4259841&#39;: &#39;URL&#39;,
    &#39;Alert.4259842&#39;: &#39;Message_Text&#39;,
    &#39;Alert.4259843&#39;: &#39;Filename&#39;,
    &#39;Alert.4259844&#39;: &#39;From&#39;,
    &#39;Alert.4259845&#39;: &#39;To&#39;,
    &#39;Alert.4259846&#39;: &#39;Cc&#39;,
    &#39;Alert.4259847&#39;: &#39;Bcc&#39;,
    &#39;Alert.4259848&#39;: &#39;Subject&#39;,
    &#39;Alert.4259849&#39;: &#39;User_Agent&#39;,
    &#39;Alert.4259850&#39;: &#39;Cookie&#39;,
    &#39;Alert.4259851&#39;: &#39;Referer&#39;,
    &#39;Alert.4259852&#39;: &#39;Destination_Filename&#39;,
    &#39;Alert.4259853&#39;: &#39;Client_Version&#39;,
    &#39;Alert.4259854&#39;: &#39;Job_Name&#39;,
    &#39;Alert.4259855&#39;: &#39;Language&#39;,
    &#39;Alert.4259856&#39;: &#39;SWF_URL&#39;,
    &#39;Alert.4259857&#39;: &#39;TC_URL&#39;,
    &#39;Alert.4259858&#39;: &#39;RTMP_Application&#39;,
    &#39;Alert.4259859&#39;: &#39;Version&#39;,
    &#39;Alert.4259860&#39;: &#39;Local_User_Name&#39;,
    &#39;Alert.4259867&#39;: &#39;DNS_Name&#39;,
    &#39;Alert.4259868&#39;: &#39;SNMP_Item&#39;,
    &#39;Alert.4259869&#39;: &#39;Sensor_UUID&#39;,
    &#39;Alert.4259870&#39;: &#39;Process_Name&#39;,
    &#39;Alert.4259871&#39;: &#39;Source_Context&#39;,
    &#39;Alert.4259872&#39;: &#39;Target_Context&#39;,
    &#39;Alert.4259873&#39;: &#39;Description&#39;,
    &#39;Alert.4259874&#39;: &#39;SQL_Statement&#39;,
    &#39;Alert.4259875&#39;: &#39;From_Address&#39;,
    &#39;Alert.4259876&#39;: &#39;To_Address&#39;,
    &#39;Alert.4259877&#39;: &#39;File_Path&#39;,
    &#39;Alert.4259878&#39;: &#39;Target_Process_Name&#39;,
    &#39;Alert.4259879&#39;: &#39;Privileges&#39;,
    &#39;Alert.4259880&#39;: &#39;Search_Query&#39;,
    &#39;Alert.4259881&#39;: &#39;PCAP_Name&#39;,
    &#39;Alert.4259882&#39;: &#39;Vulnerability_References&#39;,
    &#39;Alert.4259883&#39;: &#39;Access_Privileges&#39;,
    &#39;Alert.4259884&#39;: &#39;Old_Value&#39;,
    &#39;Alert.4259885&#39;: &#39;New_Value&#39;,
    &#39;Alert.4259886&#39;: &#39;Device_URL&#39;,
    &#39;Alert.4259887&#39;: &#39;Engine_List&#39;,
    &#39;Alert.4456449&#39;: &#39;Num_Copies&#39;,
    &#39;Alert.4456450&#39;: &#39;Start_Page&#39;,
    &#39;Alert.4456451&#39;: &#39;End_Page&#39;,
    &#39;Alert.4456457&#39;: &#39;NTP_Offset_To_Monitor&#39;,
    &#39;Alert.4456458&#39;: &#39;Confidence&#39;,
    &#39;Alert.4456459&#39;: &#39;Hops&#39;,
    &#39;Alert.4456460&#39;: &#39;Priority&#39;,
    &#39;Alert.54919169&#39;: &#39;DNS - Type&#39;,
    &#39;Alert.54919171&#39;: &#39;Old_Reputation - ATD_File&#39;,
    &#39;Alert.54919172&#39;: &#39;New_Reputation - ATD_File&#39;,
    &#39;Alert.65537&#39;: &#39;Signature_Name&#39;,
    &#39;Alert.65538&#39;: &#39;Threat_Name&#39;,
    &#39;Alert.65539&#39;: &#39;Destination_Hostname&#39;,
    &#39;Alert.65540&#39;: &#39;Category&#39;,
    &#39;Alert.65541&#39;: &#39;Source_Zone&#39;,
    &#39;Alert.65542&#39;: &#39;Destination_Zone&#39;,
    &#39;Alert.65543&#39;: &#39;Target_Class&#39;,
    &#39;Alert.65544&#39;: &#39;Policy_Name&#39;,
    &#39;Alert.65545&#39;: &#39;Event_Class&#39;,
    &#39;Alert.65546&#39;: &#39;Request_Type&#39;,
    &#39;Alert.65547&#39;: &#39;Message_ID&#39;,
    &#39;Alert.65548&#39;: &#39;Mail_ID&#39;,
    &#39;Alert.65549&#39;: &#39;Recipient_ID&#39;,
    &#39;Alert.65550&#39;: &#39;Delivery_ID&#39;,
    &#39;Alert.65551&#39;: &#39;Creator_Name&#39;,
    &#39;Alert.65552&#39;: &#39;External_Application&#39;,
    &#39;Alert.65553&#39;: &#39;External_DB2_Server&#39;,
    &#39;Alert.65554&#39;: &#39;Table_Name&#39;,
    &#39;Alert.65555&#39;: &#39;Access_Resource&#39;,
    &#39;Alert.65556&#39;: &#39;Catalog_Name&#39;,
    &#39;Alert.65557&#39;: &#39;DB2_Plan_Name&#39;,
    &#39;Alert.65558&#39;: &#39;File_Type&#39;,
    &#39;Alert.65559&#39;: &#39;FTP_Command&#39;,
    &#39;Alert.65560&#39;: &#39;Job_Type&#39;,
    &#39;Alert.65561&#39;: &#39;Logical_Unit_Name&#39;,
    &#39;Alert.65562&#39;: &#39;LPAR_DB2_Subsystem&#39;,
    &#39;Alert.65563&#39;: &#39;Step_Count&#39;,
    &#39;Alert.65564&#39;: &#39;Step_Name&#39;,
    &#39;Alert.65565&#39;: &#39;Volume_ID&#39;,
    &#39;Alert.65566&#39;: &#39;Source_UserID&#39;,
    &#39;Alert.65567&#39;: &#39;Destination_UserID&#39;,
    &#39;Alert.65568&#39;: &#39;Mainframe_Job_Name&#39;,
    &#39;Alert.65569&#39;: &#39;Database_ID&#39;,
    &#39;Alert.65570&#39;: &#39;Malware_Insp_Action&#39;,
    &#39;Alert.65571&#39;: &#39;Malware_Insp_Result&#39;,
    &#39;Alert.65572&#39;: &#39;Source_Network&#39;,
    &#39;Alert.65573&#39;: &#39;Destination_Network&#39;,
    &#39;Alert.65574&#39;: &#39;Incoming_ID&#39;,
    &#39;Alert.65575&#39;: &#39;External_Hostname&#39;,
    &#39;Alert.65576&#39;: &#39;Area&#39;,
    &#39;Alert.65577&#39;: &#39;Facility&#39;,
    &#39;Alert.65578&#39;: &#39;Privileged_User&#39;,
    &#39;Alert.65579&#39;: &#39;Operating_System&#39;,
    &#39;Alert.65580&#39;: &#39;Logon_Type&#39;,
    &#39;Alert.65581&#39;: &#39;Management_Server&#39;,
    &#39;Alert.65582&#39;: &#39;External_SessionID&#39;,
    &#39;Alert.65583&#39;: &#39;Source_Logon_ID&#39;,
    &#39;Alert.65584&#39;: &#39;Destination_Logon_ID&#39;,
    &#39;Alert.65585&#39;: &#39;Session_Status&#39;,
    &#39;Alert.65586&#39;: &#39;URL_Category&#39;,
    &#39;Alert.65587&#39;: &#39;Caller_Process&#39;,
    &#39;Alert.65588&#39;: &#39;Registry_Key&#39;,
    &#39;Alert.65589&#39;: &#39;Registry_Value&#39;,
    &#39;Alert.65590&#39;: &#39;Mailbox&#39;,
    &#39;Alert.65591&#39;: &#39;Directory&#39;,
    &#39;Alert.65592&#39;: &#39;Destination_Directory&#39;,
    &#39;Alert.65593&#39;: &#39;SQL_Command&#39;,
    &#39;Alert.65594&#39;: &#39;Device_Action&#39;,
    &#39;Alert.65595&#39;: &#39;Threat_Category&#39;,
    &#39;Alert.65596&#39;: &#39;Threat_Handled&#39;,
    &#39;Alert.65597&#39;: &#39;Reason&#39;,
    &#39;Alert.65599&#39;: &#39;Detection_Method&#39;,
    &#39;Alert.65600&#39;: &#39;Virtual_Machine_Name&#39;,
    &#39;Alert.65601&#39;: &#39;Virtual_Machine_ID&#39;,
    &#39;Alert.65602&#39;: &#39;Datacenter_ID&#39;,
    &#39;Alert.65603&#39;: &#39;Datacenter_Name&#39;,
    &#39;Alert.65604&#39;: &#39;Interface_Dest&#39;,
    &#39;Alert.65605&#39;: &#39;Organizational_Unit&#39;,
    &#39;Alert.65606&#39;: &#39;External_Device_Type&#39;,
    &#39;Alert.65607&#39;: &#39;External_Device_ID&#39;,
    &#39;Alert.65608&#39;: &#39;External_Device_Name&#39;,
    &#39;Alert.65609&#39;: &#39;Service_Name&#39;,
    &#39;Alert.65610&#39;: &#39;Reputation_Name&#39;,
    &#39;Alert.65611&#39;: &#39;Status&#39;,
    &#39;Alert.65612&#39;: &#39;Sub_Status&#39;,
    &#39;Alert.65613&#39;: &#39;Web_Domain&#39;,
    &#39;Alert.65614&#39;: &#39;Group_Name&#39;,
    &#39;Alert.65615&#39;: &#39;App_Layer_Protocol&#39;,
    &#39;Alert.65616&#39;: &#39;Rule_Name&#39;,
    &#39;Alert.65617&#39;: &#39;Security_ID&#39;,
    &#39;Alert.65618&#39;: &#39;Authentication_Type&#39;,
    &#39;Alert.65619&#39;: &#39;SHA1&#39;,
    &#39;Alert.65620&#39;: &#39;File_ID&#39;,
    &#39;Alert.65621&#39;: &#39;Attribute_Type&#39;,
    &#39;Alert.65622&#39;: &#39;Access_Mask&#39;,
    &#39;Alert.65623&#39;: &#39;VPN_Feature_Name&#39;,
    &#39;Alert.65624&#39;: &#39;Hash&#39;,
    &#39;Alert.65625&#39;: &#39;Hash_Type&#39;,
    &#39;Alert.65627&#39;: &#39;Subcategory&#39;,
    &#39;Alert.65628&#39;: &#39;CnC_Host&#39;,
    &#39;Alert.65629&#39;: &#39;Share_Name&#39;,
    &#39;Alert.65630&#39;: &#39;SHA256&#39;,
    &#39;Alert.71696385&#39;: &#39;DNS - Type_Name&#39;,
    &#39;Alert.71696387&#39;: &#39;Old_Reputation - GTI_Cert&#39;,
    &#39;Alert.71696388&#39;: &#39;New_Reputation - GTI_Cert&#39;,
    &#39;Alert.88473601&#39;: &#39;DNS - Response_Code&#39;,
    &#39;Alert.88473603&#39;: &#39;Old_Reputation - TIE_Cert&#39;,
    &#39;Alert.88473604&#39;: &#39;New_Reputation - TIE_Cert&#39;,
    &#39;Alert.ASNGeoDst&#39;: &#39;ASNGeoDst&#39;,
    &#39;Alert.ASNGeoSrc&#39;: &#39;ASNGeoSrc&#39;,
    &#39;Alert.Action&#39;: &#39;Action&#39;,
    &#39;Alert.AlertID&#39;: &#39;AlertID&#39;,
    &#39;Alert.AppIDCat&#39;: &#39;AppIDCat&#39;,
    &#39;Alert.AvgSeverity&#39;: &#39;AvgSeverity&#39;,
    &#39;Alert.BIN(1)&#39;: &#39;AppID&#39;,
    &#39;Alert.BIN(10)&#39;: &#39;Object_Type&#39;,
    &#39;Alert.BIN(11)&#39;: &#39;Method&#39;,
    &#39;Alert.BIN(12)&#39;: &#39;File_Operation&#39;,
    &#39;Alert.BIN(13)&#39;: &#39;File_Operation_Succeeded&#39;,
    &#39;Alert.BIN(14)&#39;: &#39;User_Nickname&#39;,
    &#39;Alert.BIN(15)&#39;: &#39;Contact_Name&#39;,
    &#39;Alert.BIN(16)&#39;: &#39;Contact_Nickname&#39;,
    &#39;Alert.BIN(17)&#39;: &#39;DNS_Type&#39;,
    &#39;Alert.BIN(18)&#39;: &#39;DNS_Class&#39;,
    &#39;Alert.BIN(19)&#39;: &#39;Query_Response&#39;,
    &#39;Alert.BIN(2)&#39;: &#39;CommandID&#39;,
    &#39;Alert.BIN(20)&#39;: &#39;Authoritative_Answer&#39;,
    &#39;Alert.BIN(21)&#39;: &#39;SNMP_Operation&#39;,
    &#39;Alert.BIN(22)&#39;: &#39;SNMP_Item_Type&#39;,
    &#39;Alert.BIN(23)&#39;: &#39;SNMP_Version&#39;,
    &#39;Alert.BIN(24)&#39;: &#39;SNMP_Error_Code&#39;,
    &#39;Alert.BIN(25)&#39;: &#39;NTP_Client_Mode&#39;,
    &#39;Alert.BIN(26)&#39;: &#39;NTP_Server_Mode&#39;,
    &#39;Alert.BIN(27)&#39;: &#39;NTP_Request&#39;,
    &#39;Alert.BIN(28)&#39;: &#39;NTP_Opcode&#39;,
    &#39;Alert.BIN(29)&#39;: &#39;Interface&#39;,
    &#39;Alert.BIN(3)&#39;: &#39;DomainID&#39;,
    &#39;Alert.BIN(30)&#39;: &#39;Direction&#39;,
    &#39;Alert.BIN(31)&#39;: &#39;Sensor_Name&#39;,
    &#39;Alert.BIN(32)&#39;: &#39;Sensor_Type&#39;,
    &#39;Alert.BIN(33)&#39;: &#39;Response_Code&#39;,
    &#39;Alert.BIN(34)&#39;: &#39;Return_Code&#39;,
    &#39;Alert.BIN(4)&#39;: &#39;HostID&#39;,
    &#39;Alert.BIN(5)&#39;: &#39;ObjectID&#39;,
    &#39;Alert.BIN(6)&#39;: &#39;UserIDDst&#39;,
    &#39;Alert.BIN(7)&#39;: &#39;UserIDSrc&#39;,
    &#39;Alert.BIN(8)&#39;: &#39;Database_Name&#39;,
    &#39;Alert.BIN(9)&#39;: &#39;Application_Protocol&#39;,
    &#39;Alert.CommandIDCat&#39;: &#39;CommandIDCat&#39;,
    &#39;Alert.DSID&#39;: &#39;DSID&#39;,
    &#39;Alert.DSIDSigID&#39;: &#39;DSIDSigID&#39;,
    &#39;Alert.DomainIDCat&#39;: &#39;DomainIDCat&#39;,
    &#39;Alert.DstIP&#39;: &#39;DstIP&#39;,
    &#39;Alert.DstMac&#39;: &#39;DstMac&#39;,
    &#39;Alert.DstPort&#39;: &#39;DstPort&#39;,
    &#39;Alert.EventCount&#39;: &#39;EventCount&#39;,
    &#39;Alert.FirstTime&#39;: &#39;FirstTime&#39;,
    &#39;Alert.Flow&#39;: &#39;Flow&#39;,
    &#39;Alert.FlowID&#39;: &#39;FlowID&#39;,
    &#39;Alert.GUIDDst&#39;: &#39;GUIDDst&#39;,
    &#39;Alert.GUIDSrc&#39;: &#39;GUIDSrc&#39;,
    &#39;Alert.HostIDCat&#39;: &#39;HostIDCat&#39;,
    &#39;Alert.IPSID&#39;: &#39;IPSID&#39;,
    &#39;Alert.IPSIDAlertID&#39;: &#39;IPSIDAlertID&#39;,
    &#39;Alert.LastTime&#39;: &#39;LastTime&#39;,
    &#39;Alert.LastTime_usec&#39;: &#39;LastTime_usec&#39;,
    &#39;Alert.ObjectIDCat&#39;: &#39;ObjectIDCat&#39;,
    &#39;Alert.Protocol&#39;: &#39;Protocol&#39;,
    &#39;Alert.RemCaseID&#39;: &#39;RemCaseID&#39;,
    &#39;Alert.RemOpenTicketTime&#39;: &#39;RemOpenTicketTime&#39;,
    &#39;Alert.Reviewed&#39;: &#39;Reviewed&#39;,
    &#39;Alert.Sequence&#39;: &#39;Sequence&#39;,
    &#39;Alert.SessionID&#39;: &#39;SessionID&#39;,
    &#39;Alert.Severity&#39;: &#39;Severity&#39;,
    &#39;Alert.SigID&#39;: &#39;SigID&#39;,
    &#39;Alert.SrcIP&#39;: &#39;SrcIP&#39;,
    &#39;Alert.SrcMac&#39;: &#39;SrcMac&#39;,
    &#39;Alert.SrcPort&#39;: &#39;SrcPort&#39;,
    &#39;Alert.Trusted&#39;: &#39;Trusted&#39;,
    &#39;Alert.UserFld10Cat&#39;: &#39;UserFld10Cat&#39;,
    &#39;Alert.UserFld21Cat&#39;: &#39;UserFld21Cat&#39;,
    &#39;Alert.UserFld22Cat&#39;: &#39;UserFld22Cat&#39;,
    &#39;Alert.UserFld23Cat&#39;: &#39;UserFld23Cat&#39;,
    &#39;Alert.UserFld24Cat&#39;: &#39;UserFld24Cat&#39;,
    &#39;Alert.UserFld25Cat&#39;: &#39;UserFld25Cat&#39;,
    &#39;Alert.UserFld26Cat&#39;: &#39;UserFld26Cat&#39;,
    &#39;Alert.UserFld27Cat&#39;: &#39;UserFld27Cat&#39;,
    &#39;Alert.UserFld8Cat&#39;: &#39;UserFld8Cat&#39;,
    &#39;Alert.UserFld9Cat&#39;: &#39;UserFld9Cat&#39;,
    &#39;Alert.UserIDDstCat&#39;: &#39;UserIDDstCat&#39;,
    &#39;Alert.UserIDSrcCat&#39;: &#39;UserIDSrcCat&#39;,
    &#39;Alert.VLan&#39;: &#39;VLan&#39;,
    &#39;Alert.WriteTime&#39;: &#39;WriteTime&#39;,
    &#39;Alert.ZoneDst&#39;: &#39;ZoneDst&#39;,
    &#39;Alert.ZoneSrc&#39;: &#39;ZoneSrc&#39;,
    &#39;AlertID&#39;: &#39;Alert.AlertID&#39;,
    &#39;Analyzer_DAT_Version&#39;: &#39;Alert.262170&#39;,
    &#39;AppID&#39;: &#39;Alert.BIN(1)&#39;,
    &#39;AppIDCat&#39;: &#39;Alert.AppIDCat&#39;,
    &#39;App_Layer_Protocol&#39;: &#39;Alert.65615&#39;,
    &#39;Application_Protocol&#39;: &#39;Alert.BIN(9)&#39;,
    &#39;Area&#39;: &#39;Alert.65576&#39;,
    &#39;Attacker_IP&#39;: &#39;Alert.262175&#39;,
    &#39;Attribute_Type&#39;: &#39;Alert.65621&#39;,
    &#39;Authentication_Type&#39;: &#39;Alert.65618&#39;,
    &#39;Authoritative_Answer&#39;: &#39;Alert.BIN(20)&#39;,
    &#39;AvgSeverity&#39;: &#39;Alert.AvgSeverity&#39;,
    &#39;Bcc&#39;: &#39;Alert.4259847&#39;,
    &#39;Caller_Process&#39;: &#39;Alert.65587&#39;,
    &#39;Catalog_Name&#39;: &#39;Alert.65556&#39;,
    &#39;Category&#39;: &#39;Alert.65540&#39;,
    &#39;Cc&#39;: &#39;Alert.4259846&#39;,
    &#39;Class.Name&#39;: &#39;Class.Name&#39;,
    &#39;Class.Priority&#39;: &#39;Class.Priority&#39;,
    &#39;Client_Version&#39;: &#39;Alert.4259853&#39;,
    &#39;CnC_Host&#39;: &#39;Alert.65628&#39;,
    &#39;CommandID&#39;: &#39;Alert.BIN(2)&#39;,
    &#39;CommandIDCat&#39;: &#39;Alert.CommandIDCat&#39;,
    &#39;Confidence&#39;: &#39;Alert.4456458&#39;,
    &#39;Contact_Name&#39;: &#39;Alert.BIN(15)&#39;,
    &#39;Contact_Nickname&#39;: &#39;Alert.BIN(16)&#39;,
    &#39;Cookie&#39;: &#39;Alert.4259850&#39;,
    &#39;Creator_Name&#39;: &#39;Alert.65551&#39;,
    &#39;DAT_Version&#39;: &#39;Alert.262165&#39;,
    &#39;DB2_Plan_Name&#39;: &#39;Alert.65557&#39;,
    &#39;DNS - Class&#39;: &#39;Alert.21364737&#39;,
    &#39;DNS - Class_Name&#39;: &#39;Alert.38141953&#39;,
    &#39;DNS - Query&#39;: &#39;Alert.122028033&#39;,
    &#39;DNS - Response_Code&#39;: &#39;Alert.88473601&#39;,
    &#39;DNS - Response_Code_Name&#39;: &#39;Alert.105250817&#39;,
    &#39;DNS - Type&#39;: &#39;Alert.54919169&#39;,
    &#39;DNS - Type_Name&#39;: &#39;Alert.71696385&#39;,
    &#39;DNS_Class&#39;: &#39;Alert.BIN(18)&#39;,
    &#39;DNS_Name&#39;: &#39;Alert.4259867&#39;,
    &#39;DNS_Server_IP&#39;: &#39;Alert.262178&#39;,
    &#39;DNS_Type&#39;: &#39;Alert.BIN(17)&#39;,
    &#39;DSID&#39;: &#39;Alert.DSID&#39;,
    &#39;DSIDSigID&#39;: &#39;Alert.DSIDSigID&#39;,
    &#39;Database_GUID&#39;: &#39;Alert.262169&#39;,
    &#39;Database_ID&#39;: &#39;Alert.65569&#39;,
    &#39;Database_Name&#39;: &#39;Alert.BIN(8)&#39;,
    &#39;Datacenter_ID&#39;: &#39;Alert.65602&#39;,
    &#39;Datacenter_Name&#39;: &#39;Alert.65603&#39;,
    &#39;Delivery_ID&#39;: &#39;Alert.65550&#39;,
    &#39;Description&#39;: &#39;Alert.4259873&#39;,
    &#39;Destination_Directory&#39;: &#39;Alert.65592&#39;,
    &#39;Destination_Filename&#39;: &#39;Alert.4259852&#39;,
    &#39;Destination_Hostname&#39;: &#39;Alert.65539&#39;,
    &#39;Destination_Logon_ID&#39;: &#39;Alert.65584&#39;,
    &#39;Destination_Network&#39;: &#39;Alert.65573&#39;,
    &#39;Destination_UserID&#39;: &#39;Alert.65567&#39;,
    &#39;Destination_Zone&#39;: &#39;Alert.65542&#39;,
    &#39;Detection_Method&#39;: &#39;Alert.65599&#39;,
    &#39;Device_Action&#39;: &#39;Alert.65594&#39;,
    &#39;Device_Confidence&#39;: &#39;Alert.262179&#39;,
    &#39;Device_IP&#39;: &#39;Alert.262154&#39;,
    &#39;Device_Port&#39;: &#39;Alert.262155&#39;,
    &#39;Device_URL&#39;: &#39;Alert.4259886&#39;,
    &#39;Direction&#39;: &#39;Alert.BIN(30)&#39;,
    &#39;Directory&#39;: &#39;Alert.65591&#39;,
    &#39;DomainID&#39;: &#39;Alert.BIN(3)&#39;,
    &#39;DomainIDCat&#39;: &#39;Alert.DomainIDCat&#39;,
    &#39;DstIP&#39;: &#39;Alert.DstIP&#39;,
    &#39;DstMac&#39;: &#39;Alert.DstMac&#39;,
    &#39;DstPort&#39;: &#39;Alert.DstPort&#39;,
    &#39;End_Page&#39;: &#39;Alert.4456451&#39;,
    &#39;Engine_List&#39;: &#39;Alert.4259887&#39;,
    &#39;EventCount&#39;: &#39;Alert.EventCount&#39;,
    &#39;Event_Class&#39;: &#39;Alert.65545&#39;,
    &#39;External_Application&#39;: &#39;Alert.65552&#39;,
    &#39;External_DB2_Server&#39;: &#39;Alert.65553&#39;,
    &#39;External_Device_ID&#39;: &#39;Alert.65607&#39;,
    &#39;External_Device_Name&#39;: &#39;Alert.65608&#39;,
    &#39;External_Device_Type&#39;: &#39;Alert.65606&#39;,
    &#39;External_EventID&#39;: &#39;Alert.262156&#39;,
    &#39;External_Hostname&#39;: &#39;Alert.65575&#39;,
    &#39;External_SessionID&#39;: &#39;Alert.65582&#39;,
    &#39;External_SubEventID&#39;: &#39;Alert.262158&#39;,
    &#39;FTP_Command&#39;: &#39;Alert.65559&#39;,
    &#39;Facility&#39;: &#39;Alert.65577&#39;,
    &#39;File_Hash&#39;: &#39;Alert.262159&#39;,
    &#39;File_ID&#39;: &#39;Alert.65620&#39;,
    &#39;File_Operation&#39;: &#39;Alert.BIN(12)&#39;,
    &#39;File_Operation_Succeeded&#39;: &#39;Alert.BIN(13)&#39;,
    &#39;File_Path&#39;: &#39;Alert.4259877&#39;,
    &#39;File_Type&#39;: &#39;Alert.65558&#39;,
    &#39;Filename&#39;: &#39;Alert.4259843&#39;,
    &#39;FirstTime&#39;: &#39;Alert.FirstTime&#39;,
    &#39;Flow&#39;: &#39;Alert.Flow&#39;,
    &#39;FlowID&#39;: &#39;Alert.FlowID&#39;,
    &#39;From&#39;: &#39;Alert.4259844&#39;,
    &#39;From_Address&#39;: &#39;Alert.4259875&#39;,
    &#39;GUIDDst&#39;: &#39;Alert.GUIDDst&#39;,
    &#39;GUIDSrc&#39;: &#39;Alert.GUIDSrc&#39;,
    &#39;GeoLoc_ASNGeoDst.Latitude&#39;: &#39;GeoLoc_ASNGeoDst.Latitude&#39;,
    &#39;GeoLoc_ASNGeoDst.Longitude&#39;: &#39;GeoLoc_ASNGeoDst.Longitude&#39;,
    &#39;GeoLoc_ASNGeoDst.Msg&#39;: &#39;GeoLoc_ASNGeoDst.Msg&#39;,
    &#39;GeoLoc_ASNGeoDst.XCoord&#39;: &#39;GeoLoc_ASNGeoDst.XCoord&#39;,
    &#39;GeoLoc_ASNGeoDst.YCoord&#39;: &#39;GeoLoc_ASNGeoDst.YCoord&#39;,
    &#39;GeoLoc_ASNGeoSrc.Latitude&#39;: &#39;GeoLoc_ASNGeoSrc.Latitude&#39;,
    &#39;GeoLoc_ASNGeoSrc.Longitude&#39;: &#39;GeoLoc_ASNGeoSrc.Longitude&#39;,
    &#39;GeoLoc_ASNGeoSrc.Msg&#39;: &#39;GeoLoc_ASNGeoSrc.Msg&#39;,
    &#39;GeoLoc_ASNGeoSrc.XCoord&#39;: &#39;GeoLoc_ASNGeoSrc.XCoord&#39;,
    &#39;GeoLoc_ASNGeoSrc.YCoord&#39;: &#39;GeoLoc_ASNGeoSrc.YCoord&#39;,
    &#39;Grid_Master_IP&#39;: &#39;Alert.262153&#39;,
    &#39;Group_Name&#39;: &#39;Alert.65614&#39;,
    &#39;Handheld_ID&#39;: &#39;Alert.262168&#39;,
    &#39;Handle_ID&#39;: &#39;Alert.262160&#39;,
    &#39;Hash&#39;: &#39;Alert.65624&#39;,
    &#39;Hash_Type&#39;: &#39;Alert.65625&#39;,
    &#39;Hops&#39;: &#39;Alert.4456459&#39;,
    &#39;HostID&#39;: &#39;Alert.BIN(4)&#39;,
    &#39;HostIDCat&#39;: &#39;Alert.HostIDCat&#39;,
    &#39;IPS.Name&#39;: &#39;IPS.Name&#39;,
    &#39;IPSID&#39;: &#39;Alert.IPSID&#39;,
    &#39;IPSIDAlertID&#39;: &#39;Alert.IPSIDAlertID&#39;,
    &#39;Incident_ID&#39;: &#39;Alert.262173&#39;,
    &#39;Incoming_ID&#39;: &#39;Alert.65574&#39;,
    &#39;Instance_GUID&#39;: &#39;Alert.262161&#39;,
    &#39;Interface&#39;: &#39;Alert.BIN(29)&#39;,
    &#39;Interface_Dest&#39;: &#39;Alert.65604&#39;,
    &#39;Job_Name&#39;: &#39;Alert.4259854&#39;,
    &#39;Job_Type&#39;: &#39;Alert.65560&#39;,
    &#39;LPAR_DB2_Subsystem&#39;: &#39;Alert.65562&#39;,
    &#39;Language&#39;: &#39;Alert.4259855&#39;,
    &#39;LastTime&#39;: &#39;Alert.LastTime&#39;,
    &#39;LastTime_usec&#39;: &#39;Alert.LastTime_usec&#39;,
    &#39;Local_User_Name&#39;: &#39;Alert.4259860&#39;,
    &#39;Logical_Unit_Name&#39;: &#39;Alert.65561&#39;,
    &#39;Logon_Type&#39;: &#39;Alert.65580&#39;,
    &#39;Mail_ID&#39;: &#39;Alert.65548&#39;,
    &#39;Mailbox&#39;: &#39;Alert.65590&#39;,
    &#39;Mainframe_Job_Name&#39;: &#39;Alert.65568&#39;,
    &#39;Malware_Insp_Action&#39;: &#39;Alert.65570&#39;,
    &#39;Malware_Insp_Result&#39;: &#39;Alert.65571&#39;,
    &#39;Management_Server&#39;: &#39;Alert.65581&#39;,
    &#39;Message_ID&#39;: &#39;Alert.65547&#39;,
    &#39;Message_Text&#39;: &#39;Alert.4259842&#39;,
    &#39;Method&#39;: &#39;Alert.BIN(11)&#39;,
    &#39;NAT_Details&#39;: &#39;Alert.262146&#39;,
    &#39;NTP_Client_Mode&#39;: &#39;Alert.BIN(25)&#39;,
    &#39;NTP_Offset_To_Monitor&#39;: &#39;Alert.4456457&#39;,
    &#39;NTP_Opcode&#39;: &#39;Alert.BIN(28)&#39;,
    &#39;NTP_Request&#39;: &#39;Alert.BIN(27)&#39;,
    &#39;NTP_Server_Mode&#39;: &#39;Alert.BIN(26)&#39;,
    &#39;New_Reputation - ATD_File&#39;: &#39;Alert.54919172&#39;,
    &#39;New_Reputation - GTI_Cert&#39;: &#39;Alert.71696388&#39;,
    &#39;New_Reputation - GTI_File&#39;: &#39;Alert.21364740&#39;,
    &#39;New_Reputation - TIE_Cert&#39;: &#39;Alert.88473604&#39;,
    &#39;New_Reputation - TIE_File&#39;: &#39;Alert.38141956&#39;,
    &#39;New_Value&#39;: &#39;Alert.4259885&#39;,
    &#39;Num_Copies&#39;: &#39;Alert.4456449&#39;,
    &#39;ObjectID&#39;: &#39;Alert.BIN(5)&#39;,
    &#39;ObjectIDCat&#39;: &#39;Alert.ObjectIDCat&#39;,
    &#39;Object_GUID&#39;: &#39;Alert.262176&#39;,
    &#39;Object_Type&#39;: &#39;Alert.BIN(10)&#39;,
    &#39;Old_Reputation - ATD_File&#39;: &#39;Alert.54919171&#39;,
    &#39;Old_Reputation - GTI_Cert&#39;: &#39;Alert.71696387&#39;,
    &#39;Old_Reputation - GTI_File&#39;: &#39;Alert.21364739&#39;,
    &#39;Old_Reputation - TIE_Cert&#39;: &#39;Alert.88473603&#39;,
    &#39;Old_Reputation - TIE_File&#39;: &#39;Alert.38141955&#39;,
    &#39;Old_Value&#39;: &#39;Alert.4259884&#39;,
    &#39;Operating_System&#39;: &#39;Alert.65579&#39;,
    &#39;Organizational_Unit&#39;: &#39;Alert.65605&#39;,
    &#39;PCAP_Name&#39;: &#39;Alert.4259881&#39;,
    &#39;PID&#39;: &#39;Alert.262152&#39;,
    &#39;Parent_File_Hash&#39;: &#39;Alert.262172&#39;,
    &#39;Policy_ID&#39;: &#39;Alert.262167&#39;,
    &#39;Policy_Name&#39;: &#39;Alert.65544&#39;,
    &#39;Priority&#39;: &#39;Alert.4456460&#39;,
    &#39;Privileged_User&#39;: &#39;Alert.65578&#39;,
    &#39;Privileges&#39;: &#39;Alert.4259879&#39;,
    &#39;Process_Name&#39;: &#39;Alert.4259870&#39;,
    &#39;Protocol&#39;: &#39;Alert.Protocol&#39;,
    &#39;Query_Response&#39;: &#39;Alert.BIN(19)&#39;,
    &#39;Queue_ID&#39;: &#39;Alert.196609&#39;,
    &#39;RTMP_Application&#39;: &#39;Alert.4259858&#39;,
    &#39;Reason&#39;: &#39;Alert.65597&#39;,
    &#39;Recipient_ID&#39;: &#39;Alert.65549&#39;,
    &#39;Referer&#39;: &#39;Alert.4259851&#39;,
    &#39;Registry - Key&#39;: &#39;Alert.21364738&#39;,
    &#39;Registry - Value&#39;: &#39;Alert.38141954&#39;,
    &#39;Registry_Key&#39;: &#39;Alert.65588&#39;,
    &#39;Registry_Value&#39;: &#39;Alert.65589&#39;,
    &#39;RemCaseID&#39;: &#39;Alert.RemCaseID&#39;,
    &#39;RemOpenTicketTime&#39;: &#39;Alert.RemOpenTicketTime&#39;,
    &#39;Reputation&#39;: &#39;Alert.262164&#39;,
    &#39;Reputation_Name&#39;: &#39;Alert.65610&#39;,
    &#39;Reputation_Score&#39;: &#39;Alert.262171&#39;,
    &#39;Reputation_Server_IP&#39;: &#39;Alert.262177&#39;,
    &#39;Request_Type&#39;: &#39;Alert.65546&#39;,
    &#39;Response_Code&#39;: &#39;Alert.BIN(33)&#39;,
    &#39;Response_Time&#39;: &#39;Alert.262145&#39;,
    &#39;Return_Code&#39;: &#39;Alert.BIN(34)&#39;,
    &#39;Reviewed&#39;: &#39;Alert.Reviewed&#39;,
    &#39;Rule.ID&#39;: &#39;Rule.ID&#39;,
    &#39;Rule.NormID&#39;: &#39;Rule.NormID&#39;,
    &#39;Rule.msg&#39;: &#39;Rule.msg&#39;,
    &#39;Rule_NDSNormSigID.msg&#39;: &#39;Rule_NDSNormSigID.msg&#39;,
    &#39;Rule_Name&#39;: &#39;Alert.65616&#39;,
    &#39;SHA1&#39;: &#39;Alert.65619&#39;,
    &#39;SHA256&#39;: &#39;Alert.65630&#39;,
    &#39;SNMP_Error_Code&#39;: &#39;Alert.BIN(24)&#39;,
    &#39;SNMP_Item&#39;: &#39;Alert.4259868&#39;,
    &#39;SNMP_Item_Type&#39;: &#39;Alert.BIN(22)&#39;,
    &#39;SNMP_Operation&#39;: &#39;Alert.BIN(21)&#39;,
    &#39;SNMP_Version&#39;: &#39;Alert.BIN(23)&#39;,
    &#39;SQL_Command&#39;: &#39;Alert.65593&#39;,
    &#39;SQL_Statement&#39;: &#39;Alert.4259874&#39;,
    &#39;SWF_URL&#39;: &#39;Alert.4259856&#39;,
    &#39;Search_Query&#39;: &#39;Alert.4259880&#39;,
    &#39;Security_ID&#39;: &#39;Alert.65617&#39;,
    &#39;Sensor_Name&#39;: &#39;Alert.BIN(31)&#39;,
    &#39;Sensor_Type&#39;: &#39;Alert.BIN(32)&#39;,
    &#39;Sensor_UUID&#39;: &#39;Alert.4259869&#39;,
    &#39;Sequence&#39;: &#39;Alert.Sequence&#39;,
    &#39;Server_ID&#39;: &#39;Alert.262166&#39;,
    &#39;Service_Name&#39;: &#39;Alert.65609&#39;,
    &#39;SessionID&#39;: &#39;Alert.SessionID&#39;,
    &#39;Session_Status&#39;: &#39;Alert.65585&#39;,
    &#39;Severity&#39;: &#39;Alert.Severity&#39;,
    &#39;Share_Name&#39;: &#39;Alert.65629&#39;,
    &#39;SigID&#39;: &#39;Alert.SigID&#39;,
    &#39;Signature_Name&#39;: &#39;Alert.65537&#39;,
    &#39;Source_Context&#39;: &#39;Alert.4259871&#39;,
    &#39;Source_Logon_ID&#39;: &#39;Alert.65583&#39;,
    &#39;Source_Network&#39;: &#39;Alert.65572&#39;,
    &#39;Source_UserID&#39;: &#39;Alert.65566&#39;,
    &#39;Source_Zone&#39;: &#39;Alert.65541&#39;,
    &#39;Spam_Score&#39;: &#39;Alert.262157&#39;,
    &#39;SrcIP&#39;: &#39;Alert.SrcIP&#39;,
    &#39;SrcMac&#39;: &#39;Alert.SrcMac&#39;,
    &#39;SrcPort&#39;: &#39;Alert.SrcPort&#39;,
    &#39;Start_Page&#39;: &#39;Alert.4456450&#39;,
    &#39;Status&#39;: &#39;Alert.65611&#39;,
    &#39;Step_Count&#39;: &#39;Alert.65563&#39;,
    &#39;Step_Name&#39;: &#39;Alert.65564&#39;,
    &#39;Sub_Status&#39;: &#39;Alert.65612&#39;,
    &#39;Subcategory&#39;: &#39;Alert.65627&#39;,
    &#39;Subject&#39;: &#39;Alert.4259848&#39;,
    &#39;TC_URL&#39;: &#39;Alert.4259857&#39;,
    &#39;Table_Name&#39;: &#39;Alert.65554&#39;,
    &#39;Target_Class&#39;: &#39;Alert.65543&#39;,
    &#39;Target_Context&#39;: &#39;Alert.4259872&#39;,
    &#39;Target_Process_Name&#39;: &#39;Alert.4259878&#39;,
    &#39;ThirdPartyType.Name&#39;: &#39;ThirdPartyType.Name&#39;,
    &#39;Threat_Category&#39;: &#39;Alert.65595&#39;,
    &#39;Threat_Handled&#39;: &#39;Alert.65596&#39;,
    &#39;Threat_Name&#39;: &#39;Alert.65538&#39;,
    &#39;To&#39;: &#39;Alert.4259845&#39;,
    &#39;To_Address&#39;: &#39;Alert.4259876&#39;,
    &#39;Trusted&#39;: &#39;Alert.Trusted&#39;,
    &#39;URL&#39;: &#39;Alert.4259841&#39;,
    &#39;URL_Category&#39;: &#39;Alert.65586&#39;,
    &#39;UUID&#39;: &#39;Alert.262163&#39;,
    &#39;UserFld10Cat&#39;: &#39;Alert.UserFld10Cat&#39;,
    &#39;UserFld21Cat&#39;: &#39;Alert.UserFld21Cat&#39;,
    &#39;UserFld22Cat&#39;: &#39;Alert.UserFld22Cat&#39;,
    &#39;UserFld23Cat&#39;: &#39;Alert.UserFld23Cat&#39;,
    &#39;UserFld24Cat&#39;: &#39;Alert.UserFld24Cat&#39;,
    &#39;UserFld25Cat&#39;: &#39;Alert.UserFld25Cat&#39;,
    &#39;UserFld26Cat&#39;: &#39;Alert.UserFld26Cat&#39;,
    &#39;UserFld27Cat&#39;: &#39;Alert.UserFld27Cat&#39;,
    &#39;UserFld8Cat&#39;: &#39;Alert.UserFld8Cat&#39;,
    &#39;UserFld9Cat&#39;: &#39;Alert.UserFld9Cat&#39;,
    &#39;UserIDDst&#39;: &#39;Alert.BIN(6)&#39;,
    &#39;UserIDDstCat&#39;: &#39;Alert.UserIDDstCat&#39;,
    &#39;UserIDSrc&#39;: &#39;Alert.BIN(7)&#39;,
    &#39;UserIDSrcCat&#39;: &#39;Alert.UserIDSrcCat&#39;,
    &#39;User_Agent&#39;: &#39;Alert.4259849&#39;,
    &#39;User_Nickname&#39;: &#39;Alert.BIN(14)&#39;,
    &#39;Users.Name&#39;: &#39;Users.Name&#39;,
    &#39;VLan&#39;: &#39;Alert.VLan&#39;,
    &#39;VPN_Feature_Name&#39;: &#39;Alert.65623&#39;,
    &#39;Version&#39;: &#39;Alert.4259859&#39;,
    &#39;Victim_IP&#39;: &#39;Alert.262174&#39;,
    &#39;Virtual_Machine_ID&#39;: &#39;Alert.65601&#39;,
    &#39;Virtual_Machine_Name&#39;: &#39;Alert.65600&#39;,
    &#39;Volume_ID&#39;: &#39;Alert.65565&#39;,
    &#39;Vulnerability_References&#39;: &#39;Alert.4259882&#39;,
    &#39;Web_Domain&#39;: &#39;Alert.65613&#39;,
    &#39;WriteTime&#39;: &#39;Alert.WriteTime&#39;,
    &#39;ZoneDst&#39;: &#39;Alert.ZoneDst&#39;,
    &#39;ZoneSrc&#39;: &#39;Alert.ZoneSrc&#39;,
    &#39;Zone_ZoneDst.Name&#39;: &#39;Zone_ZoneDst.Name&#39;,
    &#39;Zone_ZoneSrc.Name&#39;: &#39;Zone_ZoneSrc.Name&#39;}
    &#34;&#34;&#34;
    Best effort to match SIEM returned fields with initial.
    __getitem__, __contains__, __setitem__ and __delitem__ method have been rewrote in order to offer more comprehensive dict usage.
    For exemple, the SIEM will return dicts with keys like  `Alert.65613`, `Alert.BIN(7)` or `Alert.SrcIP`, you&#39;ll be able to use `Event` dictionnary object with your initial queried fields like `Web_Doamin`, `UserIDSrc` or `SrcIP`. 
    &#34;&#34;&#34;
    def __getitem__(self, key):
        &#34;&#34;&#34;
        Best effort to match or autocomplete the field name.
        &#34;&#34;&#34;
        if collections.UserDict.__contains__(self, key): 
            return collections.UserDict.__getitem__(self, key)
        elif key in self.SIEM_FIELDS_MAP.keys():
            if collections.UserDict.__contains__(self, self.SIEM_FIELDS_MAP[key]): 
                return collections.UserDict.__getitem__(self, self.SIEM_FIELDS_MAP[key])
        else :
            for table in self.FIELDS_TABLES :
                if collections.UserDict.__contains__(self, table+&#39;.&#39;+key): 
                    return collections.UserDict.__getitem__(self, table+&#39;.&#39;+key)
            raise KeyError(&#39;Dictionnary key not found : {}&#39;.format(key))
    def __contains__(self, key):
        if collections.UserDict.__contains__(self, key): 
            return True
        elif key in self.SIEM_FIELDS_MAP.keys():
            if collections.UserDict.__contains__(self, self.SIEM_FIELDS_MAP[key]): 
                return True
        else:
            for table in self.FIELDS_TABLES:
                if collections.UserDict.__contains__(self, table+&#39;.&#39;+key): 
                    return True
            return False
    def __setitem__(self, key, value):
        if collections.UserDict.__contains__(self, key): 
            collections.UserDict.__setitem__(self, key, value)
        elif key in self.SIEM_FIELDS_MAP.keys():
            if collections.UserDict.__contains__(self, self.SIEM_FIELDS_MAP[key]): 
                collections.UserDict.__setitem__(self, self.SIEM_FIELDS_MAP[key], value)
        else:
            for table in self.FIELDS_TABLES:
                if collections.UserDict.__contains__(self, table+&#39;.&#39;+key): 
                    collections.UserDict.__setitem__(self, table+&#39;.&#39;+key, value)
            raise KeyError(&#39;Dictionnary key not found : {}&#39;.format(key))
    def __delitem__(self, key):
        if collections.UserDict.__contains__(self, key): 
            collections.UserDict.__delitem__(self, key)
        elif key in self.SIEM_FIELDS_MAP.keys():
            if collections.UserDict.__contains__(self, self.SIEM_FIELDS_MAP[key]): 
                collections.UserDict.__delitem__(self, self.SIEM_FIELDS_MAP[key])
        else:
            for table in self.FIELDS_TABLES:
                if collections.UserDict.__contains__(self, table+&#39;.&#39;+key): 
                    collections.UserDict.__delitem__(self, table+&#39;.&#39;+key)
            raise KeyError(&#39;Dictionnary key not found : {}&#39;.format(key))

    def clear_notes(self):
        &#34;&#34;&#34;
        Replace the notes by an empty string. Desctructive action.
        &#34;&#34;&#34;
        self.set_note(&#39;&#39;, no_date=True)

    def set_note(self, note, no_date=False):
        &#34;&#34;&#34;
        Set the event&#39;s note. Desctructive action.
        &#34;&#34;&#34;
        the_id = self.data[&#34;Alert.IPSIDAlertID&#34;] if &#34;Alert.IPSIDAlertID&#34; in self.data else str(self.data[&#39;ipsId&#39;][&#39;id&#39;])+&#39;|&#39;+str(self.data[&#34;alertId&#34;]) if &#34;alertId&#34; in self.data else None

        if isinstance(the_id, str):

            if len(note) &gt;= 4000:
                log.warning(&#34;The note is longer than 4000 characters, only the&#34; 
                            &#34;first 4000 characters will be kept. The maximum&#34; 
                            &#34;accepted by the SIEM is 4096 characters.&#34;)
                note=note[:4000]+&#39;\n\n--NOTE HAS BEEN TRUNCATED--&#39;
            
            if no_date==False:
                timestamp = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)
                note = note.replace(&#39;&#34;&#39;,&#39;\\&#34;&#39;).replace(&#39;\n&#39;,&#39;\\n&#39;)
                note = timestamp + &#39; - &#39; + note
            
            self.nitro.request(&#34;add_note_to_event_int&#34;, 
                id=the_id,
                note=note)
        else :
            log.error(&#34;Couldn&#39;t set event&#39;s note, the event ID hasn&#39;t been found.&#34;)
        
    def data_from_id(self, id, use_query=False, extra_fields=[]):
        &#34;&#34;&#34;
        Load event&#39;s data.  

        Arguments:   

        - `id` : The event ID. (i.e. : `144128388087414784|747122896`)  
        - `use_query` : Uses the query module to retreive common event data. Only works with SIEM v 11.2.x.  
        - `extra_fields` : Only when `use_query=True`. Additionnal event fields to load in the query.  
        &#34;&#34;&#34;
        
        if use_query == True :

            e = EventManager(
                time_range=&#39;CUSTOM&#39;,
                start_time=datetime.now()-timedelta(days=365),
                end_time=datetime.now()+timedelta(days=1),
                filters=[(&#39;IPSIDAlertID&#39;,id)],
                fields=extra_fields,
                limit=2)
                
            e.load_data()

            if len(e) == 1 :
                return e[0]
            else :
                raise NitroError(&#39;Could not load event : &#39;+str(id)+&#39; from query :&#39;+str(e.__dict__)+&#39;. Try with use_query=False.&#39;)

        elif use_query == False :
            return self.nitro.request(&#39;get_alert_data&#39;, id=id)

    def refresh(self): 
        &#34;&#34;&#34;Re-load event&#39;s data&#34;&#34;&#34;
        if &#39;Alert.IPSIDAlertID&#39; in self.data.keys() :
            self.data.update(self.data_from_id(self.data[&#39;Alert.IPSIDAlertID&#39;], 
                use_query=True, extra_fields=self.data.keys()))
        else :
            id = &#39;|&#39;.join([str(self.data[&#39;ipsId&#39;][&#39;id&#39;]), str(self.data[&#39;alertId&#39;])])
            self.data.update(self.data_from_id(id))
   
class _QueryFilter(collections.UserDict):
    &#34;&#34;&#34;Base class for all SIEM query objects in order to dump the filter as dict.
    &#34;&#34;&#34;

class GroupFilter(_QueryFilter):
    &#34;&#34;&#34;
        Based on EsmFilterGroup. See SIEM api doc.
        Used to dump groups of filters in the right format.

        Arguments :  

        - `filters` : a list of filters, it can be `msiempy.event.FieldFilter` or `msiempy.event.GroupFilter`  
        - `logic` : &#39;AND&#39; or &#39;OR&#39;  
    &#34;&#34;&#34;

    def __init__(self, filters, logic=&#39;AND&#39;) :
        super().__init__()
        
        #Declaring attributes
        self.data={
            &#34;type&#34;: &#34;EsmFilterGroup&#34;,
            &#34;filters&#34;: [dict(f) for f in filters],
            &#34;logic&#34;:logic
            }
        
class FieldFilter(_QueryFilter):
    &#34;&#34;&#34;
    Based on EsmFieldFilter. See SIEM api doc.
    Used to dump a filter in the right format.

    Arguments:

        - `name` : field name as string. Field name property. Example : `SrcIP`. See full list here: https://github.com/mfesiem/msiempy/blob/master/static/all_filters.json
        - `values` : list of values the field is going to be tested againts with the specified orperator.  
        - `orperator` : `IN`,
        `NOT_IN`,
        `GREATER_THAN`,
        `LESS_THAN`,
        `GREATER_OR_EQUALS_THAN`,
        `LESS_OR_EQUALS_THAN`,
        `NUMERIC_EQUALS`,
        `NUMERIC_NOT_EQUALS`,
        `DOES_NOT_EQUAL`,
        `EQUALS`,
        `CONTAINS`,
        `DOES_NOT_CONTAIN`,
        `REGEX`.  
    &#34;&#34;&#34;

    def __init__(self, name, values, operator=&#39;IN&#39;) :
        super().__init__()
        #Declaring attributes
        self._operator=str()
        self._values=list()
        self.name = name
        self.operator = operator
        self.values = values

        self.data={
            &#34;type&#34;: &#34;EsmFieldFilter&#34;,
            &#34;field&#34;: {&#34;name&#34;: self.name},
            &#34;operator&#34;: self.operator,
            &#34;values&#34;: self.values
            }

    
    POSSIBLE_OPERATORS=[&#39;IN&#39;,
        &#39;NOT_IN&#39;,
        &#39;GREATER_THAN&#39;,
        &#39;LESS_THAN&#39;,
        &#39;GREATER_OR_EQUALS_THAN&#39;,
        &#39;LESS_OR_EQUALS_THAN&#39;,
        &#39;NUMERIC_EQUALS&#39;,
        &#39;NUMERIC_NOT_EQUALS&#39;,
        &#39;DOES_NOT_EQUAL&#39;,
        &#39;EQUALS&#39;,
        &#39;CONTAINS&#39;,
        &#39;DOES_NOT_CONTAIN&#39;,
        &#39;REGEX&#39;]
    &#34;&#34;&#34;List of possibles operators&#34;&#34;&#34;

    POSSIBLE_VALUE_TYPES=[
            {&#39;type&#39;:&#39;EsmWatchlistValue&#39;,    &#39;key&#39;:&#39;watchlist&#39;},
            {&#39;type&#39;:&#39;EsmVariableValue&#39;,     &#39;key&#39;:&#39;variable&#39;},
            {&#39;type&#39;:&#39;EsmBasicValue&#39;,        &#39;key&#39;:&#39;value&#39;},
            {&#39;type&#39;:&#39;EsmCompoundValue&#39;,     &#39;key&#39;:&#39;values&#39;}]
    &#34;&#34;&#34;
    List of possible value type. See `msiempy.event.FieldFilter.add_value`.
    &#34;&#34;&#34;
   
    @property
    def operator(self):
        &#34;&#34;&#34;Field operator.  
        Setter check the value against the list of possible operators and trow `AttributeError` if not present.
        &#34;&#34;&#34;
        return (self._operator)
    
    @operator.setter
    def operator(self, operator):
        try:
            if operator in self.POSSIBLE_OPERATORS :
                self._operator = operator
            else:
                raise AttributeError(&#34;Illegal value for the filter operator &#34;+operator+&#34;. The operator must be in &#34;+str(self.POSSIBLE_OPERATORS))
        except:
            raise

    @property
    def values(self):
        &#34;&#34;&#34;List of values of the filter.  
        Setter iterate trough the list and call : 

        - `msiempy.FilteredQueryList.add_value()` if value is a `dict`
        - `msiempy.FilteredQueryList.add_basic_value()` if value type is `int`, `float` or `str`.

        Values will always be added to the filter. To remove values, handle directly the `_values` property.

        Example :  
            `filter = FieldFilter(name=&#39;DstIP&#39;,values=[&#39;10.1.13.0/24&#39;, {&#39;type&#39;:&#39;EsmWatchlistValue&#39;, &#39;watchlist&#39;:42}], operator=&#39;IN&#39;)`
        &#34;&#34;&#34;
        return (self._values)

    @values.setter  
    def values(self, values):
        if isinstance(values, list): 

            for val in values :
                if isinstance(val, dict):
                    self.add_value(**val)

                elif isinstance(val, (int, float, str)) :
                    self.add_basic_value(val)

                else:
                    raise TypeError(&#34;Invalid filter type, must be a list, int, float or str&#34;)
        
        elif isinstance(values, dict):
            self.add_value(**values)

        elif isinstance(values, (int, float, str)) :
            self.add_basic_value(values)
        
        else :
            raise TypeError(&#34;Invalid filter type, must be a list, int, float or str&#34;)
        
    def add_value(self, type=None, **kwargs):
        &#34;&#34;&#34;
        Add a new value to the field filter.  
        
        Arguments (`**kwargs` depends on the value `type`):  

        - `type` (`str`) : Type of the value    
        - `value` (`str`) : If `type` is `EsmBasicValue`  
        - `watchlist` (`int`) : if `type` is `EsmWatchlistValue`    
        - `variable` (`int`) if `type` is `EsmVariableValue`    
        - `values` (`list`) if `type` is `EsmCompoundValue`  
        
        Raises : `KeyError` or `AttributeError` if you don&#39;t respect the correct type/key/value combo.  
        Note : Filtering query with other type of filter than `EsmBasicValue` is not tested.
        &#34;&#34;&#34;
        try:
            type_template=None
            
            #Look for the type of the object ex EsmBasicValue
            # it&#39; used to know the type and name of value parameter we should receive next
            for possible_value_type in self.POSSIBLE_VALUE_TYPES :
                if possible_value_type[&#39;type&#39;] == type :
                    type_template=possible_value_type
                    if type != &#39;EsmBasicValue&#39; :
                        log.warning(&#34;Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.&#34;)                            
                    break

            #Error throwing
            if type_template != None :
                if type_template[&#39;key&#39;] in kwargs :
                    
                    # Adds a new value to a fields filter
                    # Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.
                    value = kwargs[type_template[&#39;key&#39;]]
                    if type == &#39;EsmBasicValue&#39; :
                        value=str(value)
                        #log.debug(&#39;Adding a basic value to filter (&#39;+self.text+&#39;) : &#39;+value)
                    self._values.append({&#39;type&#39;:type, type_template[&#39;key&#39;]:value})
                    #log.debug(&#39;The value was appended to the list: &#39;+str(self))
                    
                #Error throwing
                else: raise KeyError (&#39;The valid key value argument is not present&#39;)
            else: raise KeyError (&#39;Impossible filter&#39;)
        except KeyError as err:
            raise AttributeError(&#34;You must provide a valid named Arguments containing the type and values for this filter. The type/keys must be in &#34;+str(self.POSSIBLE_VALUE_TYPES)+&#34;Can&#39;t be type=&#34;+str(type)+&#39; &#39;+str(kwargs)+&#34;. Additionnal indicator :&#34;+str(err) )

    def add_basic_value(self, value):
        &#34;&#34;&#34;
        Wrapper arround `add_value` method to simply add a `EsmBasicValue`.
        &#34;&#34;&#34;
        self.add_value(type=&#39;EsmBasicValue&#39;, value=value)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="msiempy.event.EventManager"><code class="flex name class">
<span>class <span class="ident">EventManager</span></span>
<span>(</span><span>*args, fields=None, order=None, limit=500, filters=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Interface to query and manage events.<br>
Inherits from <a title="msiempy.FilteredQueryList" href="index.html#msiempy.FilteredQueryList"><code>FilteredQueryList</code></a>.</p>
<p>Arguments:
</p>
<ul>
<li><code>fields</code> : list of strings representing all fields you want to apprear in the Events records.
Get the list of possible fields by calling <a title="msiempy.event.EventManager.get_possible_fields" href="#msiempy.event.EventManager.get_possible_fields"><code>EventManager.get_possible_fields()</code></a> method or see <a title="msiempy.event.Event" href="#msiempy.event.Event"><code>Event</code></a>.
Some default fields will be present. </li>
<li><code>order</code> : <code>tuple ((direction, field))</code>. Direction can be 'ASCENDING' or 'DESCENDING'.</li>
<li><code>limit</code> : max number of rows per query.</li>
<li><code>filters</code> : list of filters. A filter can be a <code>tuple(field, [values])</code> or it can be a <code>msiempy.event._QueryFilter</code> if you wish to use advanced filtering.</li>
<li><code>time_range</code> : Query time range. String representation of a time range.
</li>
<li><code>start_time</code> : Query starting time, can be a <code>string</code> or a <code>datetime</code> object. Parsed with <code>dateutil</code>.
</li>
<li><code>end_time</code> : Query endding time, can be a <code>string</code> or a <code>datetime</code> object. Parsed with <code>dateutil</code>.</li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventManager(FilteredQueryList):
    &#34;&#34;&#34;Interface to query and manage events.  
    Inherits from `msiempy.FilteredQueryList`.

    Arguments:  

    - `fields` : list of strings representing all fields you want to apprear in the Events records.
        Get the list of possible fields by calling `msiempy.event.EventManager.get_possible_fields()` method or see `msiempy.event.Event`.
        Some default fields will be present. 
    - `order` : `tuple ((direction, field))`. Direction can be &#39;ASCENDING&#39; or &#39;DESCENDING&#39;.
    - `limit` : max number of rows per query.
    - `filters` : list of filters. A filter can be a `tuple(field, [values])` or it can be a `msiempy.event._QueryFilter` if you wish to use advanced filtering.
    - `time_range` : Query time range. String representation of a time range.  
    - `start_time` : Query starting time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  
    - `end_time` : Query endding time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  
    &#34;&#34;&#34; 

    #Constants
    #TODO Try grouped queries !
    TYPE=&#39;EVENT&#39;
    &#34;&#34;&#34;EVENT: Flow query or other are not implemented&#34;&#34;&#34;
    GROUPTYPE=&#39;NO_GROUP&#39;
    &#34;&#34;&#34;NO_GROUP: Group query is not implemented&#34;&#34;&#34;
    POSSBILE_ROW_ORDER=[
            &#39;ASCENDING&#39;,
            &#39;DESCENDING&#39;
    ]
    &#34;&#34;&#34;`ASCENDING` or `DESCENDING`&#34;&#34;&#34;

    # Declaring static value containing all the possibles
    # event fields, should be loaded once (when the session start ?)
    _possible_fields = []

    def __init__(self, *args, fields=None, 
        order=None, limit=500, filters=None, 
        __parent__=None, **kwargs):
        #Calling super constructor : time_range set etc...
        super().__init__(*args, **kwargs)

        #Store the query parent 
        self.__parent__=__parent__

        #Declaring attributes
        self._filters=list()
        
        #Setting the default fields Adds the specified fields, make sure there is no duplicates and delete TABLE identifiers
        if fields and len(fields)&gt;0: 
            self.fields=set(Event.DEFAULTS_EVENT_FIELDS+[f.split(&#39;.&#39;)[1] if &#39;.&#39; in f else f for f in list(fields)])
        else:
            self.fields=Event.DEFAULTS_EVENT_FIELDS
        #log.debug(&#39;{}\nFIELDS : {}&#39;.format(locals(), self.fields))

        #Setting limit according to config or limit argument
        #TODO Try to load queries with a limit of 10k and get result as chucks of 500 with starPost nbRows
        #   and compare efficiency
        self.limit=int(limit)
        
        self.order=order

        #TODO : find a solution not to use this
        #callign super().filters=filters #https://bugs.python.org/issue14965
        super(self.__class__, self.__class__).filters.__set__(self, filters)

        #Type cast all items in the list &#34;data&#34; to events type objects
        #Casting all data to Event objects, better way to do it ?
        collections.UserList.__init__(self, [Event(adict=item) for item in self.data if isinstance(item, (dict, NitroDict))])

    @property
    def order(self):
        &#34;&#34;&#34;
        Orders representing the what the SIEM is expecting as the &#39;order&#39;.
        The `order` must be tuple (direction, field).
        &#34;&#34;&#34;
        return((self._order_direction, self._order_field))

    @order.setter
    def order(self, order):
        if order:
            try:
                if order[0] not in self.POSSBILE_ROW_ORDER :
                    raise AttributeError(&#39;Order direction must be in &#39;+str(self.POSSBILE_ROW_ORDER))

                self._order_direction = order[0]
                self._order_field = order[1]
            except IndexError:
                raise ValueError(&#39;Order must be tuple (direction, field).&#39;)
        else:
            self._order_direction = &#39;DESCENDING&#39;
            self._order_field = &#39;LastTime&#39;
    @property
    def filters(self):
        &#34;&#34;&#34;
        JSON SIEM formatted filters for the query by calling reccursively : `msiempy.event._QueryFilter.config_dict`.
        See `msiempy.FilteredQueryList.filters`.
        &#34;&#34;&#34;
        return([dict(f) for f in self._filters])

    def add_filter(self, afilter):
        &#34;&#34;&#34;
        Concrete description of the `msiempy.FilteredQueryList` method.
        It can take a `tuple(fiels, [values])` or a `msiempy.event._QueryFilter` subclass.
        &#34;&#34;&#34;
        if isinstance(afilter, tuple) :
            self._filters.append(FieldFilter(afilter[0], afilter[1]))

        elif isinstance(afilter, _QueryFilter) :
            self._filters.append(afilter)
        
        else :
            raise NitroError(&#34;Sorry the filters must be either a tuple(fiels, [values]) or a _QueryFilter sub class.&#34;)

    def clear_filters(self):
        &#34;&#34;&#34;
        Replace all filters by a non filtering rule.
        Acts like the is not filters.
        &#34;&#34;&#34; 
        self._filters=[FieldFilter(&#39;SrcIP&#39;, [&#39;0.0.0.0/0&#39;,])]

    def get_possible_fields(self):
        &#34;&#34;&#34;
        Indicate a list of possible fields that you can request in a query.
        The list is loaded from the SIEM.
        &#34;&#34;&#34;
        return self.nitro.request(&#39;get_possible_fields&#39;, type=self.TYPE, groupType=self.GROUPTYPE)

    def qry_load_data(self, retry=2, wait_timeout_sec=120):
        &#34;&#34;&#34;
        Concrete helper method to execute the query and load the data :  
            -&gt; Submit the query  
            -&gt; Wait the query to be executed  
            -&gt; Get and parse the events  

        Arguments:

        - `retry` (`int`): number of time the query can be failed and retied
        - `wait_timeout_sec` (`int`): wait timeout in seconds

        Returns : `tuple` : (( `msiempy.event.EventManager`, Status of the query (completed?) `True/False` ))

        Can raise `msiempy.NitroError`: 

            - Query wait timeout -&gt; You might want to change the value of `wait_timeout_sec` argument !
            - Other errors
        &#34;&#34;&#34;
        query_infos=dict()

        #Queries api calls are very different if the time range is custom.
        if self.time_range == &#39;CUSTOM&#39; :
            query_infos=self.nitro.request(
                &#39;event_query_custom_time&#39;,
                time_range=self.time_range,
                start_time=self.start_time,
                end_time=self.end_time,
                order_direction=self._order_direction,
                order_field=self._order_field,
                fields=format_fields_for_query(self.fields),
                filters=self.filters,
                limit=self.limit,
                offset=0,
                includeTotal=False
                )

        else :
            query_infos=self.nitro.request(
                &#39;event_query&#39;,
                time_range=self.time_range,
                order_direction=self._order_direction,
                order_field=self._order_field,
                fields=format_fields_for_query(self.fields),
                filters=self.filters,
                limit=self.limit,
                offset=0,
                includeTotal=False
                )
        
        log.debug(&#34;Waiting for EsmRunningQuery object : &#34;+str(query_infos))
        try:
            self._wait_for(query_infos[&#39;resultID&#39;], wait_timeout_sec)
            events_raw=self._get_events(query_infos[&#39;resultID&#39;])
        except NitroError as error :
            if retry &gt;0 and any(match in str(error) for match in [&#39;ResultUnavailable&#39;,&#39;UnknownList&#39;, &#39;Query wait timeout&#39;]):
                log.warning(&#39;Retring after: &#39;+str(error))
                return self.qry_load_data(retry=retry-1)
            else: raise

        events=EventManager(alist=events_raw)
        self.data=events
        return((events,len(events)&lt;self.limit))

    def load_data(self, workers=10, slots=10, delta=None, max_query_depth=0, **kwargs):
        &#34;&#34;&#34;Load the data from the SIEM into the manager list.  
        Split the query in defferents time slots if the query apprears not to be completed.  
        Wraps around `msiempy.FilteredQueryList.qry_load_data`.    

        Note: Only the first query is loaded asynchronously.

        Arguments:  
    
        - `workers` : numbre of parrallels tasks, should be equal or less than the number of slots.  
        - `slots` : number of time slots the query can be divided. The loading bar is 
            divided according to the number of slots  
        - `delta` : exemple : &#39;6h30m&#39;, the query will be firstly divided in chuncks according to the time delta read
            with dateutil.  
        - `max_query_depth` : maximum number of supplement reccursions of division of the query times
        Meaning, if EventManager query limit=500, slots=5 and max_query_depth=3, then the maximum capacity of 
        the list is (500*5)*(500*5)*(500*5) = 15625000000
        - `retry` (`int`): number of time the query can be failed and retried
        - `wait_timeout_sec` (`int`): wait timeout in seconds


        Returns : `msiempy.event.EventManager`
        &#34;&#34;&#34;

        items, completed = self.qry_load_data()

        if not completed :
            #If not completed the query is split and items aren&#39;t actually used

            if max_query_depth &gt; 0 :
                #log.info(&#34;The query data couldn&#39;t be loaded in one request, separating it in sub-queries...&#34;)

                if self.time_range != &#39;CUSTOM&#39;: #can raise a NotImplementedError if unsupported time_range
                    start, end = timerange_gettimes(self.time_range)
                else :
                    start, end = self.start_time, self.end_time

                if self.__parent__ == None and isinstance(delta, str) :
                    #if it&#39;s the first query and delta is speficied, cut the time_range in slots according to the delta
                    times=divide_times(start, end, delta=parse_timedelta(delta))
                    
                else : 
                    times=divide_times(start, end, slots=slots)

                if workers &gt; len(times) :
                    log.warning(&#34;The numbre of slots is smaller than the number of workers, only &#34;+str(len(times))+&#34; asynch workers will be used when you could use up to &#34;+str(workers)+&#34;. Number of slots should be greater than the number of workers for better performance.&#34;)
                
                sub_queries=list()

                for time in times : #reversed(times) :
                    #Divide the query in sub queries
                    sub_query = EventManager(fields=self.fields, 
                        order=self.order, 
                        limit=self.limit,
                        filters=self._filters,
                        time_range=&#39;CUSTOM&#39;,
                        start_time=time[0].isoformat(),
                        end_time=time[1].isoformat(),

                         __parent__=self
                        )
                    
                    sub_queries.append(sub_query)
            
                results = self.perform(EventManager.load_data, sub_queries, 
                    #The sub query is asynch only when it&#39;s the first query (root parent)
                    asynch=self.__parent__==None,
                    progress=self.__parent__==None, 
                    message=&#39;Loading data from &#39;+start+&#39; to &#39;+end+&#39;. In {} slots&#39;.format(len(times)),
                    func_args=dict(slots=slots, max_query_depth=max_query_depth-1),
                    workers=workers)

                #Flatten the list of lists in a list
                items=[item for sublist in results for item in sublist]
                
            else :
                if not self.__root_parent__.not_completed :
                    log.warning(&#34;The query is not complete... Try to divide in more slots or increase the limit&#34;)
                    self.__root_parent__.not_completed=True

        self.data=items
        return(self)

    def _wait_for(self, resultID, wait_timeout_sec, sleep_time=0.2):
        &#34;&#34;&#34;
        Internal method called by qry_load_data
        Wait and sleep - for `sleep_time` duration in seconds -
            until the query is completed or retry countdown arrives at zero.    
        
        Return: `True`  

        Raises: 

        - `msiempy.NitroError`: &#39;ResultUnavailable&#39; error some times...
        - `msiempy.NitroError`: &#39;Query wait timeout&#39;
        &#34;&#34;&#34;
        # time_out=parse_timedelta(wait_timeout).total_seconds()
        # retry = wait_timeout_sec / sleep_time

        begin=datetime.now()
        timeout_delta=timedelta(seconds=wait_timeout_sec)

        log.debug(&#34;Waiting for the query to be executed on the SIEM...&#34;)
        
        while datetime.now()-timeout_delta &lt; begin :
            status = self.nitro.request(&#39;query_status&#39;, resultID=resultID)
            if status[&#39;complete&#39;] is True :
                return True
            else :
                time.sleep(sleep_time)
            # retry=retry-1
        raise NitroError(&#34;Query wait timeout. resultID={}, sleep_time={}, wait_timeout_sec={}&#34;.format(
            resultID, sleep_time, wait_timeout_sec))

    def _get_events(self, resultID, startPos=0, numRows=None):
        &#34;&#34;&#34;
        Internal method that will get the query events, 
            called by qry_load_data
        by default, numRows correspond to limit
        &#34;&#34;&#34;
        
        if not numRows :
            numRows=self.limit
                
        result=self.nitro.request(&#39;query_result&#39;,
            startPos=startPos,
            numRows=numRows,
            resultID=resultID)

        #Calls a utils function to parse the [columns][rows]
        #   to format into list of dict
        #log.debug(&#34;Parsing colums : &#34;+str(result[&#39;columns&#39;]))
        #log.debug(&#34;Parsing rows : &#34;+str(result[&#39;rows&#39;]))
        if len(result[&#39;columns&#39;]) != len(set([column[&#39;name&#39;] for column in result[&#39;columns&#39;]])) :
            log.error(&#34;You requested duplicated fields, the parsed fields/values results will be missmatched !&#34;)
        events=parse_query_result(result[&#39;columns&#39;], result[&#39;rows&#39;])
        #log.debug(&#34;Events parsed : &#34;+str(events))
        return events

    @property
    def __root_parent__(self):
        &#34;&#34;&#34;
        Internal method that return the first query of the query tree
        &#34;&#34;&#34;
        if self.__parent__==None:
            return self
        else :
            return self.__parent__.__root_parent__

    def get_possible_filters(self):
        &#34;&#34;&#34;
        Return all the fields that you can filter on in a query.
        &#34;&#34;&#34;
        return(self.nitro.request(&#39;get_possible_filters&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="msiempy.FilteredQueryList" href="index.html#msiempy.FilteredQueryList">FilteredQueryList</a></li>
<li><a title="msiempy.NitroList" href="index.html#msiempy.NitroList">NitroList</a></li>
<li>collections.UserList</li>
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="msiempy.NitroObject" href="index.html#msiempy.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.event.EventManager.TYPE"><code class="name">var <span class="ident">TYPE</span></code></dt>
<dd>
<section class="desc"><p>EVENT: Flow query or other are not implemented</p></section>
</dd>
<dt id="msiempy.event.EventManager.GROUPTYPE"><code class="name">var <span class="ident">GROUPTYPE</span></code></dt>
<dd>
<section class="desc"><p>NO_GROUP: Group query is not implemented</p></section>
</dd>
<dt id="msiempy.event.EventManager.POSSBILE_ROW_ORDER"><code class="name">var <span class="ident">POSSBILE_ROW_ORDER</span></code></dt>
<dd>
<section class="desc"><p><code>ASCENDING</code> or <code>DESCENDING</code></p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.event.EventManager.order"><code class="name">var <span class="ident">order</span></code></dt>
<dd>
<section class="desc"><p>Orders representing the what the SIEM is expecting as the 'order'.
The <code>order</code> must be tuple (direction, field).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def order(self):
    &#34;&#34;&#34;
    Orders representing the what the SIEM is expecting as the &#39;order&#39;.
    The `order` must be tuple (direction, field).
    &#34;&#34;&#34;
    return((self._order_direction, self._order_field))</code></pre>
</details>
</dd>
<dt id="msiempy.event.EventManager.filters"><code class="name">var <span class="ident">filters</span></code></dt>
<dd>
<section class="desc"><p>JSON SIEM formatted filters for the query by calling reccursively : <code>msiempy.event._QueryFilter.config_dict</code>.
See <a title="msiempy.FilteredQueryList.filters" href="index.html#msiempy.FilteredQueryList.filters"><code>FilteredQueryList.filters</code></a>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def filters(self):
    &#34;&#34;&#34;
    JSON SIEM formatted filters for the query by calling reccursively : `msiempy.event._QueryFilter.config_dict`.
    See `msiempy.FilteredQueryList.filters`.
    &#34;&#34;&#34;
    return([dict(f) for f in self._filters])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.event.EventManager.add_filter"><code class="name flex">
<span>def <span class="ident">add_filter</span></span>(<span>self, afilter)</span>
</code></dt>
<dd>
<section class="desc"><p>Concrete description of the <a title="msiempy.FilteredQueryList" href="index.html#msiempy.FilteredQueryList"><code>FilteredQueryList</code></a> method.
It can take a <code>tuple(fiels, [values])</code> or a <code>msiempy.event._QueryFilter</code> subclass.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_filter(self, afilter):
    &#34;&#34;&#34;
    Concrete description of the `msiempy.FilteredQueryList` method.
    It can take a `tuple(fiels, [values])` or a `msiempy.event._QueryFilter` subclass.
    &#34;&#34;&#34;
    if isinstance(afilter, tuple) :
        self._filters.append(FieldFilter(afilter[0], afilter[1]))

    elif isinstance(afilter, _QueryFilter) :
        self._filters.append(afilter)
    
    else :
        raise NitroError(&#34;Sorry the filters must be either a tuple(fiels, [values]) or a _QueryFilter sub class.&#34;)</code></pre>
</details>
</dd>
<dt id="msiempy.event.EventManager.clear_filters"><code class="name flex">
<span>def <span class="ident">clear_filters</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Replace all filters by a non filtering rule.
Acts like the is not filters.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_filters(self):
    &#34;&#34;&#34;
    Replace all filters by a non filtering rule.
    Acts like the is not filters.
    &#34;&#34;&#34; 
    self._filters=[FieldFilter(&#39;SrcIP&#39;, [&#39;0.0.0.0/0&#39;,])]</code></pre>
</details>
</dd>
<dt id="msiempy.event.EventManager.get_possible_fields"><code class="name flex">
<span>def <span class="ident">get_possible_fields</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Indicate a list of possible fields that you can request in a query.
The list is loaded from the SIEM.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_possible_fields(self):
    &#34;&#34;&#34;
    Indicate a list of possible fields that you can request in a query.
    The list is loaded from the SIEM.
    &#34;&#34;&#34;
    return self.nitro.request(&#39;get_possible_fields&#39;, type=self.TYPE, groupType=self.GROUPTYPE)</code></pre>
</details>
</dd>
<dt id="msiempy.event.EventManager.qry_load_data"><code class="name flex">
<span>def <span class="ident">qry_load_data</span></span>(<span>self, retry=2, wait_timeout_sec=120)</span>
</code></dt>
<dd>
<section class="desc"><p>Concrete helper method to execute the query and load the data :<br>
-&gt; Submit the query<br>
-&gt; Wait the query to be executed<br>
-&gt; Get and parse the events
</p>
<p>Arguments:</p>
<ul>
<li><code>retry</code> (<code>int</code>): number of time the query can be failed and retied</li>
<li><code>wait_timeout_sec</code> (<code>int</code>): wait timeout in seconds</li>
</ul>
<p>Returns : <code>tuple</code> : (( <a title="msiempy.event.EventManager" href="#msiempy.event.EventManager"><code>EventManager</code></a>, Status of the query (completed?) <code>True/False</code> ))</p>
<p>Can raise <a title="msiempy.NitroError" href="index.html#msiempy.NitroError"><code>NitroError</code></a>: </p>
<pre><code>- Query wait timeout -&gt; You might want to change the value of `wait_timeout_sec` argument !
- Other errors
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def qry_load_data(self, retry=2, wait_timeout_sec=120):
    &#34;&#34;&#34;
    Concrete helper method to execute the query and load the data :  
        -&gt; Submit the query  
        -&gt; Wait the query to be executed  
        -&gt; Get and parse the events  

    Arguments:

    - `retry` (`int`): number of time the query can be failed and retied
    - `wait_timeout_sec` (`int`): wait timeout in seconds

    Returns : `tuple` : (( `msiempy.event.EventManager`, Status of the query (completed?) `True/False` ))

    Can raise `msiempy.NitroError`: 

        - Query wait timeout -&gt; You might want to change the value of `wait_timeout_sec` argument !
        - Other errors
    &#34;&#34;&#34;
    query_infos=dict()

    #Queries api calls are very different if the time range is custom.
    if self.time_range == &#39;CUSTOM&#39; :
        query_infos=self.nitro.request(
            &#39;event_query_custom_time&#39;,
            time_range=self.time_range,
            start_time=self.start_time,
            end_time=self.end_time,
            order_direction=self._order_direction,
            order_field=self._order_field,
            fields=format_fields_for_query(self.fields),
            filters=self.filters,
            limit=self.limit,
            offset=0,
            includeTotal=False
            )

    else :
        query_infos=self.nitro.request(
            &#39;event_query&#39;,
            time_range=self.time_range,
            order_direction=self._order_direction,
            order_field=self._order_field,
            fields=format_fields_for_query(self.fields),
            filters=self.filters,
            limit=self.limit,
            offset=0,
            includeTotal=False
            )
    
    log.debug(&#34;Waiting for EsmRunningQuery object : &#34;+str(query_infos))
    try:
        self._wait_for(query_infos[&#39;resultID&#39;], wait_timeout_sec)
        events_raw=self._get_events(query_infos[&#39;resultID&#39;])
    except NitroError as error :
        if retry &gt;0 and any(match in str(error) for match in [&#39;ResultUnavailable&#39;,&#39;UnknownList&#39;, &#39;Query wait timeout&#39;]):
            log.warning(&#39;Retring after: &#39;+str(error))
            return self.qry_load_data(retry=retry-1)
        else: raise

    events=EventManager(alist=events_raw)
    self.data=events
    return((events,len(events)&lt;self.limit))</code></pre>
</details>
</dd>
<dt id="msiempy.event.EventManager.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self, workers=10, slots=10, delta=None, max_query_depth=0, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Load the data from the SIEM into the manager list.<br>
Split the query in defferents time slots if the query apprears not to be completed.<br>
Wraps around <a title="msiempy.FilteredQueryList.qry_load_data" href="index.html#msiempy.FilteredQueryList.qry_load_data"><code>FilteredQueryList.qry_load_data()</code></a>.
</p>
<p>Note: Only the first query is loaded asynchronously.</p>
<p>Arguments:
</p>
<ul>
<li><code>workers</code> : numbre of parrallels tasks, should be equal or less than the number of slots.
</li>
<li><code>slots</code> : number of time slots the query can be divided. The loading bar is
divided according to the number of slots
</li>
<li><code>delta</code> : exemple : '6h30m', the query will be firstly divided in chuncks according to the time delta read
with dateutil.
</li>
<li><code>max_query_depth</code> : maximum number of supplement reccursions of division of the query times
Meaning, if EventManager query limit=500, slots=5 and max_query_depth=3, then the maximum capacity of
the list is (500<em>5)</em>(500<em>5)</em>(500*5) = 15625000000</li>
<li><code>retry</code> (<code>int</code>): number of time the query can be failed and retried</li>
<li><code>wait_timeout_sec</code> (<code>int</code>): wait timeout in seconds</li>
</ul>
<p>Returns : <a title="msiempy.event.EventManager" href="#msiempy.event.EventManager"><code>EventManager</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_data(self, workers=10, slots=10, delta=None, max_query_depth=0, **kwargs):
    &#34;&#34;&#34;Load the data from the SIEM into the manager list.  
    Split the query in defferents time slots if the query apprears not to be completed.  
    Wraps around `msiempy.FilteredQueryList.qry_load_data`.    

    Note: Only the first query is loaded asynchronously.

    Arguments:  

    - `workers` : numbre of parrallels tasks, should be equal or less than the number of slots.  
    - `slots` : number of time slots the query can be divided. The loading bar is 
        divided according to the number of slots  
    - `delta` : exemple : &#39;6h30m&#39;, the query will be firstly divided in chuncks according to the time delta read
        with dateutil.  
    - `max_query_depth` : maximum number of supplement reccursions of division of the query times
    Meaning, if EventManager query limit=500, slots=5 and max_query_depth=3, then the maximum capacity of 
    the list is (500*5)*(500*5)*(500*5) = 15625000000
    - `retry` (`int`): number of time the query can be failed and retried
    - `wait_timeout_sec` (`int`): wait timeout in seconds


    Returns : `msiempy.event.EventManager`
    &#34;&#34;&#34;

    items, completed = self.qry_load_data()

    if not completed :
        #If not completed the query is split and items aren&#39;t actually used

        if max_query_depth &gt; 0 :
            #log.info(&#34;The query data couldn&#39;t be loaded in one request, separating it in sub-queries...&#34;)

            if self.time_range != &#39;CUSTOM&#39;: #can raise a NotImplementedError if unsupported time_range
                start, end = timerange_gettimes(self.time_range)
            else :
                start, end = self.start_time, self.end_time

            if self.__parent__ == None and isinstance(delta, str) :
                #if it&#39;s the first query and delta is speficied, cut the time_range in slots according to the delta
                times=divide_times(start, end, delta=parse_timedelta(delta))
                
            else : 
                times=divide_times(start, end, slots=slots)

            if workers &gt; len(times) :
                log.warning(&#34;The numbre of slots is smaller than the number of workers, only &#34;+str(len(times))+&#34; asynch workers will be used when you could use up to &#34;+str(workers)+&#34;. Number of slots should be greater than the number of workers for better performance.&#34;)
            
            sub_queries=list()

            for time in times : #reversed(times) :
                #Divide the query in sub queries
                sub_query = EventManager(fields=self.fields, 
                    order=self.order, 
                    limit=self.limit,
                    filters=self._filters,
                    time_range=&#39;CUSTOM&#39;,
                    start_time=time[0].isoformat(),
                    end_time=time[1].isoformat(),

                     __parent__=self
                    )
                
                sub_queries.append(sub_query)
        
            results = self.perform(EventManager.load_data, sub_queries, 
                #The sub query is asynch only when it&#39;s the first query (root parent)
                asynch=self.__parent__==None,
                progress=self.__parent__==None, 
                message=&#39;Loading data from &#39;+start+&#39; to &#39;+end+&#39;. In {} slots&#39;.format(len(times)),
                func_args=dict(slots=slots, max_query_depth=max_query_depth-1),
                workers=workers)

            #Flatten the list of lists in a list
            items=[item for sublist in results for item in sublist]
            
        else :
            if not self.__root_parent__.not_completed :
                log.warning(&#34;The query is not complete... Try to divide in more slots or increase the limit&#34;)
                self.__root_parent__.not_completed=True

    self.data=items
    return(self)</code></pre>
</details>
</dd>
<dt id="msiempy.event.EventManager.get_possible_filters"><code class="name flex">
<span>def <span class="ident">get_possible_filters</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return all the fields that you can filter on in a query.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_possible_filters(self):
    &#34;&#34;&#34;
    Return all the fields that you can filter on in a query.
    &#34;&#34;&#34;
    return(self.nitro.request(&#39;get_possible_filters&#39;))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.FilteredQueryList" href="index.html#msiempy.FilteredQueryList">FilteredQueryList</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.FilteredQueryList.DEFAULT_TIME_RANGE" href="index.html#msiempy.FilteredQueryList.DEFAULT_TIME_RANGE">DEFAULT_TIME_RANGE</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.NitroJSONEncoder" href="index.html#msiempy.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.POSSIBLE_TIME_RANGE" href="index.html#msiempy.FilteredQueryList.POSSIBLE_TIME_RANGE">POSSIBLE_TIME_RANGE</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.end_time" href="index.html#msiempy.FilteredQueryList.end_time">end_time</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.get_text" href="index.html#msiempy.NitroList.get_text">get_text</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.json" href="index.html#msiempy.NitroList.json">json</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.keys" href="index.html#msiempy.NitroList.keys">keys</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.nitro" href="index.html#msiempy.NitroObject.nitro">nitro</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.perform" href="index.html#msiempy.NitroList.perform">perform</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.refresh" href="index.html#msiempy.NitroList.refresh">refresh</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.search" href="index.html#msiempy.NitroList.search">search</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.start_time" href="index.html#msiempy.FilteredQueryList.start_time">start_time</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.text" href="index.html#msiempy.NitroList.text">text</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.time_range" href="index.html#msiempy.FilteredQueryList.time_range">time_range</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="msiempy.event.Event"><code class="flex name class">
<span>class <span class="ident">Event</span></span>
<span>(</span><span>adict=None, id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Dictionary keys :
</p>
<ul>
<li><code>Rule.msg</code>
</li>
<li><code>Alert.LastTime</code>
</li>
<li><code>Alert.IPSIDAlertID</code>
</li>
<li>and others&hellip;
</li>
</ul>
<p>You can request more fields by passing a list of fields to the <a title="msiempy.event.EventManager" href="#msiempy.event.EventManager"><code>EventManager</code></a> object.
<a title="msiempy.event.Event.REGULAR_EVENT_FIELDS" href="#msiempy.event.Event.REGULAR_EVENT_FIELDS"><code>Event.REGULAR_EVENT_FIELDS</code></a> offer a base list of regular fields that may be useful.
See msiempy/static JSON files to browse complete list : <a href="https://github.com/mfesiem/msiempy/blob/master/static/all_fields.json">https://github.com/mfesiem/msiempy/blob/master/static/all_fields.json</a><br>
You can also use this script to dinamically print the available fields and filters : <a href="https://github.com/mfesiem/msiempy/blob/master/samples/dump_all_fields.py">https://github.com/mfesiem/msiempy/blob/master/samples/dump_all_fields.py</a><br>
Prefixes <code>Alert.</code>, <code>Rule.</code>, etc are optionnal, prefix autocompletion is computed in any case within the <code>__getitem__</code> method ;)
</p>
<p>Arguments:</p>
<ul>
<li><code>adict</code>: Event parameters
</li>
<li><code>id</code>: The event <code>IPSIDAlertID</code> to instanciate. Will load informations</li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Event(NitroDict):
    &#34;&#34;&#34;        
    Dictionary keys :  

    - `Rule.msg`  
    - `Alert.LastTime`  
    - `Alert.IPSIDAlertID`  
    - and others...  

    You can request more fields by passing a list of fields to the `msiempy.event.EventManager` object. 
    `msiempy.event.Event.REGULAR_EVENT_FIELDS` offer a base list of regular fields that may be useful.
    See msiempy/static JSON files to browse complete list : https://github.com/mfesiem/msiempy/blob/master/static/all_fields.json  
    You can also use this script to dinamically print the available fields and filters : https://github.com/mfesiem/msiempy/blob/master/samples/dump_all_fields.py  
    Prefixes `Alert.`, `Rule.`, etc are optionnal, prefix autocompletion is computed in any case within the `__getitem__` method ;)  

    Arguments:

    - `adict`: Event parameters  
    - `id`: The event `IPSIDAlertID` to instanciate. Will load informations
    &#34;&#34;&#34;
   
    FIELDS_TABLES=[
        &#34;Alert&#34;,
        &#34;Rule&#34;,
        &#34;ADGroup&#34;,
        &#34;Action&#34;,
        &#34;Asset&#34;,
        &#34;AssetGroup&#34;,
        &#34;AssetThreat&#34;,
        &#34;CaseMgt&#34;,
        &#34;CaseOrg&#34;,
        &#34;CaseStatus&#34;,
        &#34;Class&#34;,
        &#34;Connection&#34;,
        &#34;DataEnrichment&#34;,
        &#34;GeoLoc_ASNGeoDst&#34;,
        &#34;GeoLoc_ASNGeoSrc&#34;,
        &#34;IOC&#34;,
        &#34;IPS&#34;,
        &#34;IPSCheck&#34;,
        &#34;NDDeviceInterface_NDDevIFDst&#34;,
        &#34;NDDeviceInterface_NDDevIFSrc&#34;,
        &#34;NDDevice_NDDevIDDst&#34;,
        &#34;NDDevice_NDDevIDSrc&#34;,
        &#34;OS&#34;,
        &#34;Rule_NDSNormSigID&#34;,
        &#34;Tag&#34;,
        &#34;TagAsset&#34;,
        &#34;ThirdPartyType&#34;,
        &#34;Threat&#34;,
        &#34;ThreatVendor&#34;,
        &#34;TriggeredAlarm&#34;,
        &#34;Users&#34;,
        &#34;Vulnerability&#34;,
        &#34;Zone_ZoneDst&#34;,
        &#34;Zone_ZoneSrc&#34;,
        ]
    &#34;&#34;&#34;List of internal fields table : `Rule`,`Alert`,etc.
    &#34;&#34;&#34;

    # Minimal default query fields
    DEFAULTS_EVENT_FIELDS=[&#34;msg&#34;, &#34;LastTime&#34;,&#34;IPSIDAlertID&#34;]
    &#34;&#34;&#34;Always present when using `msiempy.event.EventManager` querying :  
        `Rule.msg`  
        `Alert.LastTime`  
        `Alert.IPSIDAlertID`
    &#34;&#34;&#34;
    # Regular query fields
    REGULAR_EVENT_FIELDS=[
        &#34;Rule.msg&#34;,
        &#34;Alert.SrcIP&#34;,
        &#34;Alert.DstIP&#34;, 
        &#34;Alert.SrcMac&#34;,
        &#34;Alert.DstMac&#34;,
        &#34;Rule.NormID&#34;,
        &#34;HostID&#34;,
        &#34;UserIDSrc&#34;,
        &#34;ObjectID&#34;,
        &#34;Alert.Severity&#34;,
        &#34;Alert.LastTime&#34;,
        &#34;Alert.DSIDSigID&#34;,
        &#34;Alert.IPSIDAlertID&#34;]
    &#34;&#34;&#34;
        `Rule.msg`  
        `Alert.SrcIP`  
        `Alert.DstIP`   
        `Alert.SrcMac`  
        `Alert.DstMac`  
        `Rule.NormID`  
        `HostID`  
        `UserIDSrc`  
        `ObjectID`  
        `Alert.Severity`  
        `Alert.LastTime`  
        `Alert.DSIDSigID`  
        `Alert.IPSIDAlertID` 
    &#34;&#34;&#34;
    
    SIEM_FIELDS_MAP = {&#39;ASNGeoDst&#39;: &#39;Alert.ASNGeoDst&#39;,
    &#39;ASNGeoSrc&#39;: &#39;Alert.ASNGeoSrc&#39;,
    &#39;Access_Mask&#39;: &#39;Alert.65622&#39;,
    &#39;Access_Privileges&#39;: &#39;Alert.4259883&#39;,
    &#39;Access_Resource&#39;: &#39;Alert.65555&#39;,
    &#39;Action&#39;: &#39;Alert.Action&#39;,
    &#39;Action.Name&#39;: &#39;Action.Name&#39;,
    &#39;Agent_GUID&#39;: &#39;Alert.262162&#39;,
    &#39;Alert.105250817&#39;: &#39;DNS - Response_Code_Name&#39;,
    &#39;Alert.122028033&#39;: &#39;DNS - Query&#39;,
    &#39;Alert.196609&#39;: &#39;Queue_ID&#39;,
    &#39;Alert.21364737&#39;: &#39;DNS - Class&#39;,
    &#39;Alert.21364738&#39;: &#39;Registry - Key&#39;,
    &#39;Alert.21364739&#39;: &#39;Old_Reputation - GTI_File&#39;,
    &#39;Alert.21364740&#39;: &#39;New_Reputation - GTI_File&#39;,
    &#39;Alert.262145&#39;: &#39;Response_Time&#39;,
    &#39;Alert.262146&#39;: &#39;NAT_Details&#39;,
    &#39;Alert.262152&#39;: &#39;PID&#39;,
    &#39;Alert.262153&#39;: &#39;Grid_Master_IP&#39;,
    &#39;Alert.262154&#39;: &#39;Device_IP&#39;,
    &#39;Alert.262155&#39;: &#39;Device_Port&#39;,
    &#39;Alert.262156&#39;: &#39;External_EventID&#39;,
    &#39;Alert.262157&#39;: &#39;Spam_Score&#39;,
    &#39;Alert.262158&#39;: &#39;External_SubEventID&#39;,
    &#39;Alert.262159&#39;: &#39;File_Hash&#39;,
    &#39;Alert.262160&#39;: &#39;Handle_ID&#39;,
    &#39;Alert.262161&#39;: &#39;Instance_GUID&#39;,
    &#39;Alert.262162&#39;: &#39;Agent_GUID&#39;,
    &#39;Alert.262163&#39;: &#39;UUID&#39;,
    &#39;Alert.262164&#39;: &#39;Reputation&#39;,
    &#39;Alert.262165&#39;: &#39;DAT_Version&#39;,
    &#39;Alert.262166&#39;: &#39;Server_ID&#39;,
    &#39;Alert.262167&#39;: &#39;Policy_ID&#39;,
    &#39;Alert.262168&#39;: &#39;Handheld_ID&#39;,
    &#39;Alert.262169&#39;: &#39;Database_GUID&#39;,
    &#39;Alert.262170&#39;: &#39;Analyzer_DAT_Version&#39;,
    &#39;Alert.262171&#39;: &#39;Reputation_Score&#39;,
    &#39;Alert.262172&#39;: &#39;Parent_File_Hash&#39;,
    &#39;Alert.262173&#39;: &#39;Incident_ID&#39;,
    &#39;Alert.262174&#39;: &#39;Victim_IP&#39;,
    &#39;Alert.262175&#39;: &#39;Attacker_IP&#39;,
    &#39;Alert.262176&#39;: &#39;Object_GUID&#39;,
    &#39;Alert.262177&#39;: &#39;Reputation_Server_IP&#39;,
    &#39;Alert.262178&#39;: &#39;DNS_Server_IP&#39;,
    &#39;Alert.262179&#39;: &#39;Device_Confidence&#39;,
    &#39;Alert.38141953&#39;: &#39;DNS - Class_Name&#39;,
    &#39;Alert.38141954&#39;: &#39;Registry - Value&#39;,
    &#39;Alert.38141955&#39;: &#39;Old_Reputation - TIE_File&#39;,
    &#39;Alert.38141956&#39;: &#39;New_Reputation - TIE_File&#39;,
    &#39;Alert.4259841&#39;: &#39;URL&#39;,
    &#39;Alert.4259842&#39;: &#39;Message_Text&#39;,
    &#39;Alert.4259843&#39;: &#39;Filename&#39;,
    &#39;Alert.4259844&#39;: &#39;From&#39;,
    &#39;Alert.4259845&#39;: &#39;To&#39;,
    &#39;Alert.4259846&#39;: &#39;Cc&#39;,
    &#39;Alert.4259847&#39;: &#39;Bcc&#39;,
    &#39;Alert.4259848&#39;: &#39;Subject&#39;,
    &#39;Alert.4259849&#39;: &#39;User_Agent&#39;,
    &#39;Alert.4259850&#39;: &#39;Cookie&#39;,
    &#39;Alert.4259851&#39;: &#39;Referer&#39;,
    &#39;Alert.4259852&#39;: &#39;Destination_Filename&#39;,
    &#39;Alert.4259853&#39;: &#39;Client_Version&#39;,
    &#39;Alert.4259854&#39;: &#39;Job_Name&#39;,
    &#39;Alert.4259855&#39;: &#39;Language&#39;,
    &#39;Alert.4259856&#39;: &#39;SWF_URL&#39;,
    &#39;Alert.4259857&#39;: &#39;TC_URL&#39;,
    &#39;Alert.4259858&#39;: &#39;RTMP_Application&#39;,
    &#39;Alert.4259859&#39;: &#39;Version&#39;,
    &#39;Alert.4259860&#39;: &#39;Local_User_Name&#39;,
    &#39;Alert.4259867&#39;: &#39;DNS_Name&#39;,
    &#39;Alert.4259868&#39;: &#39;SNMP_Item&#39;,
    &#39;Alert.4259869&#39;: &#39;Sensor_UUID&#39;,
    &#39;Alert.4259870&#39;: &#39;Process_Name&#39;,
    &#39;Alert.4259871&#39;: &#39;Source_Context&#39;,
    &#39;Alert.4259872&#39;: &#39;Target_Context&#39;,
    &#39;Alert.4259873&#39;: &#39;Description&#39;,
    &#39;Alert.4259874&#39;: &#39;SQL_Statement&#39;,
    &#39;Alert.4259875&#39;: &#39;From_Address&#39;,
    &#39;Alert.4259876&#39;: &#39;To_Address&#39;,
    &#39;Alert.4259877&#39;: &#39;File_Path&#39;,
    &#39;Alert.4259878&#39;: &#39;Target_Process_Name&#39;,
    &#39;Alert.4259879&#39;: &#39;Privileges&#39;,
    &#39;Alert.4259880&#39;: &#39;Search_Query&#39;,
    &#39;Alert.4259881&#39;: &#39;PCAP_Name&#39;,
    &#39;Alert.4259882&#39;: &#39;Vulnerability_References&#39;,
    &#39;Alert.4259883&#39;: &#39;Access_Privileges&#39;,
    &#39;Alert.4259884&#39;: &#39;Old_Value&#39;,
    &#39;Alert.4259885&#39;: &#39;New_Value&#39;,
    &#39;Alert.4259886&#39;: &#39;Device_URL&#39;,
    &#39;Alert.4259887&#39;: &#39;Engine_List&#39;,
    &#39;Alert.4456449&#39;: &#39;Num_Copies&#39;,
    &#39;Alert.4456450&#39;: &#39;Start_Page&#39;,
    &#39;Alert.4456451&#39;: &#39;End_Page&#39;,
    &#39;Alert.4456457&#39;: &#39;NTP_Offset_To_Monitor&#39;,
    &#39;Alert.4456458&#39;: &#39;Confidence&#39;,
    &#39;Alert.4456459&#39;: &#39;Hops&#39;,
    &#39;Alert.4456460&#39;: &#39;Priority&#39;,
    &#39;Alert.54919169&#39;: &#39;DNS - Type&#39;,
    &#39;Alert.54919171&#39;: &#39;Old_Reputation - ATD_File&#39;,
    &#39;Alert.54919172&#39;: &#39;New_Reputation - ATD_File&#39;,
    &#39;Alert.65537&#39;: &#39;Signature_Name&#39;,
    &#39;Alert.65538&#39;: &#39;Threat_Name&#39;,
    &#39;Alert.65539&#39;: &#39;Destination_Hostname&#39;,
    &#39;Alert.65540&#39;: &#39;Category&#39;,
    &#39;Alert.65541&#39;: &#39;Source_Zone&#39;,
    &#39;Alert.65542&#39;: &#39;Destination_Zone&#39;,
    &#39;Alert.65543&#39;: &#39;Target_Class&#39;,
    &#39;Alert.65544&#39;: &#39;Policy_Name&#39;,
    &#39;Alert.65545&#39;: &#39;Event_Class&#39;,
    &#39;Alert.65546&#39;: &#39;Request_Type&#39;,
    &#39;Alert.65547&#39;: &#39;Message_ID&#39;,
    &#39;Alert.65548&#39;: &#39;Mail_ID&#39;,
    &#39;Alert.65549&#39;: &#39;Recipient_ID&#39;,
    &#39;Alert.65550&#39;: &#39;Delivery_ID&#39;,
    &#39;Alert.65551&#39;: &#39;Creator_Name&#39;,
    &#39;Alert.65552&#39;: &#39;External_Application&#39;,
    &#39;Alert.65553&#39;: &#39;External_DB2_Server&#39;,
    &#39;Alert.65554&#39;: &#39;Table_Name&#39;,
    &#39;Alert.65555&#39;: &#39;Access_Resource&#39;,
    &#39;Alert.65556&#39;: &#39;Catalog_Name&#39;,
    &#39;Alert.65557&#39;: &#39;DB2_Plan_Name&#39;,
    &#39;Alert.65558&#39;: &#39;File_Type&#39;,
    &#39;Alert.65559&#39;: &#39;FTP_Command&#39;,
    &#39;Alert.65560&#39;: &#39;Job_Type&#39;,
    &#39;Alert.65561&#39;: &#39;Logical_Unit_Name&#39;,
    &#39;Alert.65562&#39;: &#39;LPAR_DB2_Subsystem&#39;,
    &#39;Alert.65563&#39;: &#39;Step_Count&#39;,
    &#39;Alert.65564&#39;: &#39;Step_Name&#39;,
    &#39;Alert.65565&#39;: &#39;Volume_ID&#39;,
    &#39;Alert.65566&#39;: &#39;Source_UserID&#39;,
    &#39;Alert.65567&#39;: &#39;Destination_UserID&#39;,
    &#39;Alert.65568&#39;: &#39;Mainframe_Job_Name&#39;,
    &#39;Alert.65569&#39;: &#39;Database_ID&#39;,
    &#39;Alert.65570&#39;: &#39;Malware_Insp_Action&#39;,
    &#39;Alert.65571&#39;: &#39;Malware_Insp_Result&#39;,
    &#39;Alert.65572&#39;: &#39;Source_Network&#39;,
    &#39;Alert.65573&#39;: &#39;Destination_Network&#39;,
    &#39;Alert.65574&#39;: &#39;Incoming_ID&#39;,
    &#39;Alert.65575&#39;: &#39;External_Hostname&#39;,
    &#39;Alert.65576&#39;: &#39;Area&#39;,
    &#39;Alert.65577&#39;: &#39;Facility&#39;,
    &#39;Alert.65578&#39;: &#39;Privileged_User&#39;,
    &#39;Alert.65579&#39;: &#39;Operating_System&#39;,
    &#39;Alert.65580&#39;: &#39;Logon_Type&#39;,
    &#39;Alert.65581&#39;: &#39;Management_Server&#39;,
    &#39;Alert.65582&#39;: &#39;External_SessionID&#39;,
    &#39;Alert.65583&#39;: &#39;Source_Logon_ID&#39;,
    &#39;Alert.65584&#39;: &#39;Destination_Logon_ID&#39;,
    &#39;Alert.65585&#39;: &#39;Session_Status&#39;,
    &#39;Alert.65586&#39;: &#39;URL_Category&#39;,
    &#39;Alert.65587&#39;: &#39;Caller_Process&#39;,
    &#39;Alert.65588&#39;: &#39;Registry_Key&#39;,
    &#39;Alert.65589&#39;: &#39;Registry_Value&#39;,
    &#39;Alert.65590&#39;: &#39;Mailbox&#39;,
    &#39;Alert.65591&#39;: &#39;Directory&#39;,
    &#39;Alert.65592&#39;: &#39;Destination_Directory&#39;,
    &#39;Alert.65593&#39;: &#39;SQL_Command&#39;,
    &#39;Alert.65594&#39;: &#39;Device_Action&#39;,
    &#39;Alert.65595&#39;: &#39;Threat_Category&#39;,
    &#39;Alert.65596&#39;: &#39;Threat_Handled&#39;,
    &#39;Alert.65597&#39;: &#39;Reason&#39;,
    &#39;Alert.65599&#39;: &#39;Detection_Method&#39;,
    &#39;Alert.65600&#39;: &#39;Virtual_Machine_Name&#39;,
    &#39;Alert.65601&#39;: &#39;Virtual_Machine_ID&#39;,
    &#39;Alert.65602&#39;: &#39;Datacenter_ID&#39;,
    &#39;Alert.65603&#39;: &#39;Datacenter_Name&#39;,
    &#39;Alert.65604&#39;: &#39;Interface_Dest&#39;,
    &#39;Alert.65605&#39;: &#39;Organizational_Unit&#39;,
    &#39;Alert.65606&#39;: &#39;External_Device_Type&#39;,
    &#39;Alert.65607&#39;: &#39;External_Device_ID&#39;,
    &#39;Alert.65608&#39;: &#39;External_Device_Name&#39;,
    &#39;Alert.65609&#39;: &#39;Service_Name&#39;,
    &#39;Alert.65610&#39;: &#39;Reputation_Name&#39;,
    &#39;Alert.65611&#39;: &#39;Status&#39;,
    &#39;Alert.65612&#39;: &#39;Sub_Status&#39;,
    &#39;Alert.65613&#39;: &#39;Web_Domain&#39;,
    &#39;Alert.65614&#39;: &#39;Group_Name&#39;,
    &#39;Alert.65615&#39;: &#39;App_Layer_Protocol&#39;,
    &#39;Alert.65616&#39;: &#39;Rule_Name&#39;,
    &#39;Alert.65617&#39;: &#39;Security_ID&#39;,
    &#39;Alert.65618&#39;: &#39;Authentication_Type&#39;,
    &#39;Alert.65619&#39;: &#39;SHA1&#39;,
    &#39;Alert.65620&#39;: &#39;File_ID&#39;,
    &#39;Alert.65621&#39;: &#39;Attribute_Type&#39;,
    &#39;Alert.65622&#39;: &#39;Access_Mask&#39;,
    &#39;Alert.65623&#39;: &#39;VPN_Feature_Name&#39;,
    &#39;Alert.65624&#39;: &#39;Hash&#39;,
    &#39;Alert.65625&#39;: &#39;Hash_Type&#39;,
    &#39;Alert.65627&#39;: &#39;Subcategory&#39;,
    &#39;Alert.65628&#39;: &#39;CnC_Host&#39;,
    &#39;Alert.65629&#39;: &#39;Share_Name&#39;,
    &#39;Alert.65630&#39;: &#39;SHA256&#39;,
    &#39;Alert.71696385&#39;: &#39;DNS - Type_Name&#39;,
    &#39;Alert.71696387&#39;: &#39;Old_Reputation - GTI_Cert&#39;,
    &#39;Alert.71696388&#39;: &#39;New_Reputation - GTI_Cert&#39;,
    &#39;Alert.88473601&#39;: &#39;DNS - Response_Code&#39;,
    &#39;Alert.88473603&#39;: &#39;Old_Reputation - TIE_Cert&#39;,
    &#39;Alert.88473604&#39;: &#39;New_Reputation - TIE_Cert&#39;,
    &#39;Alert.ASNGeoDst&#39;: &#39;ASNGeoDst&#39;,
    &#39;Alert.ASNGeoSrc&#39;: &#39;ASNGeoSrc&#39;,
    &#39;Alert.Action&#39;: &#39;Action&#39;,
    &#39;Alert.AlertID&#39;: &#39;AlertID&#39;,
    &#39;Alert.AppIDCat&#39;: &#39;AppIDCat&#39;,
    &#39;Alert.AvgSeverity&#39;: &#39;AvgSeverity&#39;,
    &#39;Alert.BIN(1)&#39;: &#39;AppID&#39;,
    &#39;Alert.BIN(10)&#39;: &#39;Object_Type&#39;,
    &#39;Alert.BIN(11)&#39;: &#39;Method&#39;,
    &#39;Alert.BIN(12)&#39;: &#39;File_Operation&#39;,
    &#39;Alert.BIN(13)&#39;: &#39;File_Operation_Succeeded&#39;,
    &#39;Alert.BIN(14)&#39;: &#39;User_Nickname&#39;,
    &#39;Alert.BIN(15)&#39;: &#39;Contact_Name&#39;,
    &#39;Alert.BIN(16)&#39;: &#39;Contact_Nickname&#39;,
    &#39;Alert.BIN(17)&#39;: &#39;DNS_Type&#39;,
    &#39;Alert.BIN(18)&#39;: &#39;DNS_Class&#39;,
    &#39;Alert.BIN(19)&#39;: &#39;Query_Response&#39;,
    &#39;Alert.BIN(2)&#39;: &#39;CommandID&#39;,
    &#39;Alert.BIN(20)&#39;: &#39;Authoritative_Answer&#39;,
    &#39;Alert.BIN(21)&#39;: &#39;SNMP_Operation&#39;,
    &#39;Alert.BIN(22)&#39;: &#39;SNMP_Item_Type&#39;,
    &#39;Alert.BIN(23)&#39;: &#39;SNMP_Version&#39;,
    &#39;Alert.BIN(24)&#39;: &#39;SNMP_Error_Code&#39;,
    &#39;Alert.BIN(25)&#39;: &#39;NTP_Client_Mode&#39;,
    &#39;Alert.BIN(26)&#39;: &#39;NTP_Server_Mode&#39;,
    &#39;Alert.BIN(27)&#39;: &#39;NTP_Request&#39;,
    &#39;Alert.BIN(28)&#39;: &#39;NTP_Opcode&#39;,
    &#39;Alert.BIN(29)&#39;: &#39;Interface&#39;,
    &#39;Alert.BIN(3)&#39;: &#39;DomainID&#39;,
    &#39;Alert.BIN(30)&#39;: &#39;Direction&#39;,
    &#39;Alert.BIN(31)&#39;: &#39;Sensor_Name&#39;,
    &#39;Alert.BIN(32)&#39;: &#39;Sensor_Type&#39;,
    &#39;Alert.BIN(33)&#39;: &#39;Response_Code&#39;,
    &#39;Alert.BIN(34)&#39;: &#39;Return_Code&#39;,
    &#39;Alert.BIN(4)&#39;: &#39;HostID&#39;,
    &#39;Alert.BIN(5)&#39;: &#39;ObjectID&#39;,
    &#39;Alert.BIN(6)&#39;: &#39;UserIDDst&#39;,
    &#39;Alert.BIN(7)&#39;: &#39;UserIDSrc&#39;,
    &#39;Alert.BIN(8)&#39;: &#39;Database_Name&#39;,
    &#39;Alert.BIN(9)&#39;: &#39;Application_Protocol&#39;,
    &#39;Alert.CommandIDCat&#39;: &#39;CommandIDCat&#39;,
    &#39;Alert.DSID&#39;: &#39;DSID&#39;,
    &#39;Alert.DSIDSigID&#39;: &#39;DSIDSigID&#39;,
    &#39;Alert.DomainIDCat&#39;: &#39;DomainIDCat&#39;,
    &#39;Alert.DstIP&#39;: &#39;DstIP&#39;,
    &#39;Alert.DstMac&#39;: &#39;DstMac&#39;,
    &#39;Alert.DstPort&#39;: &#39;DstPort&#39;,
    &#39;Alert.EventCount&#39;: &#39;EventCount&#39;,
    &#39;Alert.FirstTime&#39;: &#39;FirstTime&#39;,
    &#39;Alert.Flow&#39;: &#39;Flow&#39;,
    &#39;Alert.FlowID&#39;: &#39;FlowID&#39;,
    &#39;Alert.GUIDDst&#39;: &#39;GUIDDst&#39;,
    &#39;Alert.GUIDSrc&#39;: &#39;GUIDSrc&#39;,
    &#39;Alert.HostIDCat&#39;: &#39;HostIDCat&#39;,
    &#39;Alert.IPSID&#39;: &#39;IPSID&#39;,
    &#39;Alert.IPSIDAlertID&#39;: &#39;IPSIDAlertID&#39;,
    &#39;Alert.LastTime&#39;: &#39;LastTime&#39;,
    &#39;Alert.LastTime_usec&#39;: &#39;LastTime_usec&#39;,
    &#39;Alert.ObjectIDCat&#39;: &#39;ObjectIDCat&#39;,
    &#39;Alert.Protocol&#39;: &#39;Protocol&#39;,
    &#39;Alert.RemCaseID&#39;: &#39;RemCaseID&#39;,
    &#39;Alert.RemOpenTicketTime&#39;: &#39;RemOpenTicketTime&#39;,
    &#39;Alert.Reviewed&#39;: &#39;Reviewed&#39;,
    &#39;Alert.Sequence&#39;: &#39;Sequence&#39;,
    &#39;Alert.SessionID&#39;: &#39;SessionID&#39;,
    &#39;Alert.Severity&#39;: &#39;Severity&#39;,
    &#39;Alert.SigID&#39;: &#39;SigID&#39;,
    &#39;Alert.SrcIP&#39;: &#39;SrcIP&#39;,
    &#39;Alert.SrcMac&#39;: &#39;SrcMac&#39;,
    &#39;Alert.SrcPort&#39;: &#39;SrcPort&#39;,
    &#39;Alert.Trusted&#39;: &#39;Trusted&#39;,
    &#39;Alert.UserFld10Cat&#39;: &#39;UserFld10Cat&#39;,
    &#39;Alert.UserFld21Cat&#39;: &#39;UserFld21Cat&#39;,
    &#39;Alert.UserFld22Cat&#39;: &#39;UserFld22Cat&#39;,
    &#39;Alert.UserFld23Cat&#39;: &#39;UserFld23Cat&#39;,
    &#39;Alert.UserFld24Cat&#39;: &#39;UserFld24Cat&#39;,
    &#39;Alert.UserFld25Cat&#39;: &#39;UserFld25Cat&#39;,
    &#39;Alert.UserFld26Cat&#39;: &#39;UserFld26Cat&#39;,
    &#39;Alert.UserFld27Cat&#39;: &#39;UserFld27Cat&#39;,
    &#39;Alert.UserFld8Cat&#39;: &#39;UserFld8Cat&#39;,
    &#39;Alert.UserFld9Cat&#39;: &#39;UserFld9Cat&#39;,
    &#39;Alert.UserIDDstCat&#39;: &#39;UserIDDstCat&#39;,
    &#39;Alert.UserIDSrcCat&#39;: &#39;UserIDSrcCat&#39;,
    &#39;Alert.VLan&#39;: &#39;VLan&#39;,
    &#39;Alert.WriteTime&#39;: &#39;WriteTime&#39;,
    &#39;Alert.ZoneDst&#39;: &#39;ZoneDst&#39;,
    &#39;Alert.ZoneSrc&#39;: &#39;ZoneSrc&#39;,
    &#39;AlertID&#39;: &#39;Alert.AlertID&#39;,
    &#39;Analyzer_DAT_Version&#39;: &#39;Alert.262170&#39;,
    &#39;AppID&#39;: &#39;Alert.BIN(1)&#39;,
    &#39;AppIDCat&#39;: &#39;Alert.AppIDCat&#39;,
    &#39;App_Layer_Protocol&#39;: &#39;Alert.65615&#39;,
    &#39;Application_Protocol&#39;: &#39;Alert.BIN(9)&#39;,
    &#39;Area&#39;: &#39;Alert.65576&#39;,
    &#39;Attacker_IP&#39;: &#39;Alert.262175&#39;,
    &#39;Attribute_Type&#39;: &#39;Alert.65621&#39;,
    &#39;Authentication_Type&#39;: &#39;Alert.65618&#39;,
    &#39;Authoritative_Answer&#39;: &#39;Alert.BIN(20)&#39;,
    &#39;AvgSeverity&#39;: &#39;Alert.AvgSeverity&#39;,
    &#39;Bcc&#39;: &#39;Alert.4259847&#39;,
    &#39;Caller_Process&#39;: &#39;Alert.65587&#39;,
    &#39;Catalog_Name&#39;: &#39;Alert.65556&#39;,
    &#39;Category&#39;: &#39;Alert.65540&#39;,
    &#39;Cc&#39;: &#39;Alert.4259846&#39;,
    &#39;Class.Name&#39;: &#39;Class.Name&#39;,
    &#39;Class.Priority&#39;: &#39;Class.Priority&#39;,
    &#39;Client_Version&#39;: &#39;Alert.4259853&#39;,
    &#39;CnC_Host&#39;: &#39;Alert.65628&#39;,
    &#39;CommandID&#39;: &#39;Alert.BIN(2)&#39;,
    &#39;CommandIDCat&#39;: &#39;Alert.CommandIDCat&#39;,
    &#39;Confidence&#39;: &#39;Alert.4456458&#39;,
    &#39;Contact_Name&#39;: &#39;Alert.BIN(15)&#39;,
    &#39;Contact_Nickname&#39;: &#39;Alert.BIN(16)&#39;,
    &#39;Cookie&#39;: &#39;Alert.4259850&#39;,
    &#39;Creator_Name&#39;: &#39;Alert.65551&#39;,
    &#39;DAT_Version&#39;: &#39;Alert.262165&#39;,
    &#39;DB2_Plan_Name&#39;: &#39;Alert.65557&#39;,
    &#39;DNS - Class&#39;: &#39;Alert.21364737&#39;,
    &#39;DNS - Class_Name&#39;: &#39;Alert.38141953&#39;,
    &#39;DNS - Query&#39;: &#39;Alert.122028033&#39;,
    &#39;DNS - Response_Code&#39;: &#39;Alert.88473601&#39;,
    &#39;DNS - Response_Code_Name&#39;: &#39;Alert.105250817&#39;,
    &#39;DNS - Type&#39;: &#39;Alert.54919169&#39;,
    &#39;DNS - Type_Name&#39;: &#39;Alert.71696385&#39;,
    &#39;DNS_Class&#39;: &#39;Alert.BIN(18)&#39;,
    &#39;DNS_Name&#39;: &#39;Alert.4259867&#39;,
    &#39;DNS_Server_IP&#39;: &#39;Alert.262178&#39;,
    &#39;DNS_Type&#39;: &#39;Alert.BIN(17)&#39;,
    &#39;DSID&#39;: &#39;Alert.DSID&#39;,
    &#39;DSIDSigID&#39;: &#39;Alert.DSIDSigID&#39;,
    &#39;Database_GUID&#39;: &#39;Alert.262169&#39;,
    &#39;Database_ID&#39;: &#39;Alert.65569&#39;,
    &#39;Database_Name&#39;: &#39;Alert.BIN(8)&#39;,
    &#39;Datacenter_ID&#39;: &#39;Alert.65602&#39;,
    &#39;Datacenter_Name&#39;: &#39;Alert.65603&#39;,
    &#39;Delivery_ID&#39;: &#39;Alert.65550&#39;,
    &#39;Description&#39;: &#39;Alert.4259873&#39;,
    &#39;Destination_Directory&#39;: &#39;Alert.65592&#39;,
    &#39;Destination_Filename&#39;: &#39;Alert.4259852&#39;,
    &#39;Destination_Hostname&#39;: &#39;Alert.65539&#39;,
    &#39;Destination_Logon_ID&#39;: &#39;Alert.65584&#39;,
    &#39;Destination_Network&#39;: &#39;Alert.65573&#39;,
    &#39;Destination_UserID&#39;: &#39;Alert.65567&#39;,
    &#39;Destination_Zone&#39;: &#39;Alert.65542&#39;,
    &#39;Detection_Method&#39;: &#39;Alert.65599&#39;,
    &#39;Device_Action&#39;: &#39;Alert.65594&#39;,
    &#39;Device_Confidence&#39;: &#39;Alert.262179&#39;,
    &#39;Device_IP&#39;: &#39;Alert.262154&#39;,
    &#39;Device_Port&#39;: &#39;Alert.262155&#39;,
    &#39;Device_URL&#39;: &#39;Alert.4259886&#39;,
    &#39;Direction&#39;: &#39;Alert.BIN(30)&#39;,
    &#39;Directory&#39;: &#39;Alert.65591&#39;,
    &#39;DomainID&#39;: &#39;Alert.BIN(3)&#39;,
    &#39;DomainIDCat&#39;: &#39;Alert.DomainIDCat&#39;,
    &#39;DstIP&#39;: &#39;Alert.DstIP&#39;,
    &#39;DstMac&#39;: &#39;Alert.DstMac&#39;,
    &#39;DstPort&#39;: &#39;Alert.DstPort&#39;,
    &#39;End_Page&#39;: &#39;Alert.4456451&#39;,
    &#39;Engine_List&#39;: &#39;Alert.4259887&#39;,
    &#39;EventCount&#39;: &#39;Alert.EventCount&#39;,
    &#39;Event_Class&#39;: &#39;Alert.65545&#39;,
    &#39;External_Application&#39;: &#39;Alert.65552&#39;,
    &#39;External_DB2_Server&#39;: &#39;Alert.65553&#39;,
    &#39;External_Device_ID&#39;: &#39;Alert.65607&#39;,
    &#39;External_Device_Name&#39;: &#39;Alert.65608&#39;,
    &#39;External_Device_Type&#39;: &#39;Alert.65606&#39;,
    &#39;External_EventID&#39;: &#39;Alert.262156&#39;,
    &#39;External_Hostname&#39;: &#39;Alert.65575&#39;,
    &#39;External_SessionID&#39;: &#39;Alert.65582&#39;,
    &#39;External_SubEventID&#39;: &#39;Alert.262158&#39;,
    &#39;FTP_Command&#39;: &#39;Alert.65559&#39;,
    &#39;Facility&#39;: &#39;Alert.65577&#39;,
    &#39;File_Hash&#39;: &#39;Alert.262159&#39;,
    &#39;File_ID&#39;: &#39;Alert.65620&#39;,
    &#39;File_Operation&#39;: &#39;Alert.BIN(12)&#39;,
    &#39;File_Operation_Succeeded&#39;: &#39;Alert.BIN(13)&#39;,
    &#39;File_Path&#39;: &#39;Alert.4259877&#39;,
    &#39;File_Type&#39;: &#39;Alert.65558&#39;,
    &#39;Filename&#39;: &#39;Alert.4259843&#39;,
    &#39;FirstTime&#39;: &#39;Alert.FirstTime&#39;,
    &#39;Flow&#39;: &#39;Alert.Flow&#39;,
    &#39;FlowID&#39;: &#39;Alert.FlowID&#39;,
    &#39;From&#39;: &#39;Alert.4259844&#39;,
    &#39;From_Address&#39;: &#39;Alert.4259875&#39;,
    &#39;GUIDDst&#39;: &#39;Alert.GUIDDst&#39;,
    &#39;GUIDSrc&#39;: &#39;Alert.GUIDSrc&#39;,
    &#39;GeoLoc_ASNGeoDst.Latitude&#39;: &#39;GeoLoc_ASNGeoDst.Latitude&#39;,
    &#39;GeoLoc_ASNGeoDst.Longitude&#39;: &#39;GeoLoc_ASNGeoDst.Longitude&#39;,
    &#39;GeoLoc_ASNGeoDst.Msg&#39;: &#39;GeoLoc_ASNGeoDst.Msg&#39;,
    &#39;GeoLoc_ASNGeoDst.XCoord&#39;: &#39;GeoLoc_ASNGeoDst.XCoord&#39;,
    &#39;GeoLoc_ASNGeoDst.YCoord&#39;: &#39;GeoLoc_ASNGeoDst.YCoord&#39;,
    &#39;GeoLoc_ASNGeoSrc.Latitude&#39;: &#39;GeoLoc_ASNGeoSrc.Latitude&#39;,
    &#39;GeoLoc_ASNGeoSrc.Longitude&#39;: &#39;GeoLoc_ASNGeoSrc.Longitude&#39;,
    &#39;GeoLoc_ASNGeoSrc.Msg&#39;: &#39;GeoLoc_ASNGeoSrc.Msg&#39;,
    &#39;GeoLoc_ASNGeoSrc.XCoord&#39;: &#39;GeoLoc_ASNGeoSrc.XCoord&#39;,
    &#39;GeoLoc_ASNGeoSrc.YCoord&#39;: &#39;GeoLoc_ASNGeoSrc.YCoord&#39;,
    &#39;Grid_Master_IP&#39;: &#39;Alert.262153&#39;,
    &#39;Group_Name&#39;: &#39;Alert.65614&#39;,
    &#39;Handheld_ID&#39;: &#39;Alert.262168&#39;,
    &#39;Handle_ID&#39;: &#39;Alert.262160&#39;,
    &#39;Hash&#39;: &#39;Alert.65624&#39;,
    &#39;Hash_Type&#39;: &#39;Alert.65625&#39;,
    &#39;Hops&#39;: &#39;Alert.4456459&#39;,
    &#39;HostID&#39;: &#39;Alert.BIN(4)&#39;,
    &#39;HostIDCat&#39;: &#39;Alert.HostIDCat&#39;,
    &#39;IPS.Name&#39;: &#39;IPS.Name&#39;,
    &#39;IPSID&#39;: &#39;Alert.IPSID&#39;,
    &#39;IPSIDAlertID&#39;: &#39;Alert.IPSIDAlertID&#39;,
    &#39;Incident_ID&#39;: &#39;Alert.262173&#39;,
    &#39;Incoming_ID&#39;: &#39;Alert.65574&#39;,
    &#39;Instance_GUID&#39;: &#39;Alert.262161&#39;,
    &#39;Interface&#39;: &#39;Alert.BIN(29)&#39;,
    &#39;Interface_Dest&#39;: &#39;Alert.65604&#39;,
    &#39;Job_Name&#39;: &#39;Alert.4259854&#39;,
    &#39;Job_Type&#39;: &#39;Alert.65560&#39;,
    &#39;LPAR_DB2_Subsystem&#39;: &#39;Alert.65562&#39;,
    &#39;Language&#39;: &#39;Alert.4259855&#39;,
    &#39;LastTime&#39;: &#39;Alert.LastTime&#39;,
    &#39;LastTime_usec&#39;: &#39;Alert.LastTime_usec&#39;,
    &#39;Local_User_Name&#39;: &#39;Alert.4259860&#39;,
    &#39;Logical_Unit_Name&#39;: &#39;Alert.65561&#39;,
    &#39;Logon_Type&#39;: &#39;Alert.65580&#39;,
    &#39;Mail_ID&#39;: &#39;Alert.65548&#39;,
    &#39;Mailbox&#39;: &#39;Alert.65590&#39;,
    &#39;Mainframe_Job_Name&#39;: &#39;Alert.65568&#39;,
    &#39;Malware_Insp_Action&#39;: &#39;Alert.65570&#39;,
    &#39;Malware_Insp_Result&#39;: &#39;Alert.65571&#39;,
    &#39;Management_Server&#39;: &#39;Alert.65581&#39;,
    &#39;Message_ID&#39;: &#39;Alert.65547&#39;,
    &#39;Message_Text&#39;: &#39;Alert.4259842&#39;,
    &#39;Method&#39;: &#39;Alert.BIN(11)&#39;,
    &#39;NAT_Details&#39;: &#39;Alert.262146&#39;,
    &#39;NTP_Client_Mode&#39;: &#39;Alert.BIN(25)&#39;,
    &#39;NTP_Offset_To_Monitor&#39;: &#39;Alert.4456457&#39;,
    &#39;NTP_Opcode&#39;: &#39;Alert.BIN(28)&#39;,
    &#39;NTP_Request&#39;: &#39;Alert.BIN(27)&#39;,
    &#39;NTP_Server_Mode&#39;: &#39;Alert.BIN(26)&#39;,
    &#39;New_Reputation - ATD_File&#39;: &#39;Alert.54919172&#39;,
    &#39;New_Reputation - GTI_Cert&#39;: &#39;Alert.71696388&#39;,
    &#39;New_Reputation - GTI_File&#39;: &#39;Alert.21364740&#39;,
    &#39;New_Reputation - TIE_Cert&#39;: &#39;Alert.88473604&#39;,
    &#39;New_Reputation - TIE_File&#39;: &#39;Alert.38141956&#39;,
    &#39;New_Value&#39;: &#39;Alert.4259885&#39;,
    &#39;Num_Copies&#39;: &#39;Alert.4456449&#39;,
    &#39;ObjectID&#39;: &#39;Alert.BIN(5)&#39;,
    &#39;ObjectIDCat&#39;: &#39;Alert.ObjectIDCat&#39;,
    &#39;Object_GUID&#39;: &#39;Alert.262176&#39;,
    &#39;Object_Type&#39;: &#39;Alert.BIN(10)&#39;,
    &#39;Old_Reputation - ATD_File&#39;: &#39;Alert.54919171&#39;,
    &#39;Old_Reputation - GTI_Cert&#39;: &#39;Alert.71696387&#39;,
    &#39;Old_Reputation - GTI_File&#39;: &#39;Alert.21364739&#39;,
    &#39;Old_Reputation - TIE_Cert&#39;: &#39;Alert.88473603&#39;,
    &#39;Old_Reputation - TIE_File&#39;: &#39;Alert.38141955&#39;,
    &#39;Old_Value&#39;: &#39;Alert.4259884&#39;,
    &#39;Operating_System&#39;: &#39;Alert.65579&#39;,
    &#39;Organizational_Unit&#39;: &#39;Alert.65605&#39;,
    &#39;PCAP_Name&#39;: &#39;Alert.4259881&#39;,
    &#39;PID&#39;: &#39;Alert.262152&#39;,
    &#39;Parent_File_Hash&#39;: &#39;Alert.262172&#39;,
    &#39;Policy_ID&#39;: &#39;Alert.262167&#39;,
    &#39;Policy_Name&#39;: &#39;Alert.65544&#39;,
    &#39;Priority&#39;: &#39;Alert.4456460&#39;,
    &#39;Privileged_User&#39;: &#39;Alert.65578&#39;,
    &#39;Privileges&#39;: &#39;Alert.4259879&#39;,
    &#39;Process_Name&#39;: &#39;Alert.4259870&#39;,
    &#39;Protocol&#39;: &#39;Alert.Protocol&#39;,
    &#39;Query_Response&#39;: &#39;Alert.BIN(19)&#39;,
    &#39;Queue_ID&#39;: &#39;Alert.196609&#39;,
    &#39;RTMP_Application&#39;: &#39;Alert.4259858&#39;,
    &#39;Reason&#39;: &#39;Alert.65597&#39;,
    &#39;Recipient_ID&#39;: &#39;Alert.65549&#39;,
    &#39;Referer&#39;: &#39;Alert.4259851&#39;,
    &#39;Registry - Key&#39;: &#39;Alert.21364738&#39;,
    &#39;Registry - Value&#39;: &#39;Alert.38141954&#39;,
    &#39;Registry_Key&#39;: &#39;Alert.65588&#39;,
    &#39;Registry_Value&#39;: &#39;Alert.65589&#39;,
    &#39;RemCaseID&#39;: &#39;Alert.RemCaseID&#39;,
    &#39;RemOpenTicketTime&#39;: &#39;Alert.RemOpenTicketTime&#39;,
    &#39;Reputation&#39;: &#39;Alert.262164&#39;,
    &#39;Reputation_Name&#39;: &#39;Alert.65610&#39;,
    &#39;Reputation_Score&#39;: &#39;Alert.262171&#39;,
    &#39;Reputation_Server_IP&#39;: &#39;Alert.262177&#39;,
    &#39;Request_Type&#39;: &#39;Alert.65546&#39;,
    &#39;Response_Code&#39;: &#39;Alert.BIN(33)&#39;,
    &#39;Response_Time&#39;: &#39;Alert.262145&#39;,
    &#39;Return_Code&#39;: &#39;Alert.BIN(34)&#39;,
    &#39;Reviewed&#39;: &#39;Alert.Reviewed&#39;,
    &#39;Rule.ID&#39;: &#39;Rule.ID&#39;,
    &#39;Rule.NormID&#39;: &#39;Rule.NormID&#39;,
    &#39;Rule.msg&#39;: &#39;Rule.msg&#39;,
    &#39;Rule_NDSNormSigID.msg&#39;: &#39;Rule_NDSNormSigID.msg&#39;,
    &#39;Rule_Name&#39;: &#39;Alert.65616&#39;,
    &#39;SHA1&#39;: &#39;Alert.65619&#39;,
    &#39;SHA256&#39;: &#39;Alert.65630&#39;,
    &#39;SNMP_Error_Code&#39;: &#39;Alert.BIN(24)&#39;,
    &#39;SNMP_Item&#39;: &#39;Alert.4259868&#39;,
    &#39;SNMP_Item_Type&#39;: &#39;Alert.BIN(22)&#39;,
    &#39;SNMP_Operation&#39;: &#39;Alert.BIN(21)&#39;,
    &#39;SNMP_Version&#39;: &#39;Alert.BIN(23)&#39;,
    &#39;SQL_Command&#39;: &#39;Alert.65593&#39;,
    &#39;SQL_Statement&#39;: &#39;Alert.4259874&#39;,
    &#39;SWF_URL&#39;: &#39;Alert.4259856&#39;,
    &#39;Search_Query&#39;: &#39;Alert.4259880&#39;,
    &#39;Security_ID&#39;: &#39;Alert.65617&#39;,
    &#39;Sensor_Name&#39;: &#39;Alert.BIN(31)&#39;,
    &#39;Sensor_Type&#39;: &#39;Alert.BIN(32)&#39;,
    &#39;Sensor_UUID&#39;: &#39;Alert.4259869&#39;,
    &#39;Sequence&#39;: &#39;Alert.Sequence&#39;,
    &#39;Server_ID&#39;: &#39;Alert.262166&#39;,
    &#39;Service_Name&#39;: &#39;Alert.65609&#39;,
    &#39;SessionID&#39;: &#39;Alert.SessionID&#39;,
    &#39;Session_Status&#39;: &#39;Alert.65585&#39;,
    &#39;Severity&#39;: &#39;Alert.Severity&#39;,
    &#39;Share_Name&#39;: &#39;Alert.65629&#39;,
    &#39;SigID&#39;: &#39;Alert.SigID&#39;,
    &#39;Signature_Name&#39;: &#39;Alert.65537&#39;,
    &#39;Source_Context&#39;: &#39;Alert.4259871&#39;,
    &#39;Source_Logon_ID&#39;: &#39;Alert.65583&#39;,
    &#39;Source_Network&#39;: &#39;Alert.65572&#39;,
    &#39;Source_UserID&#39;: &#39;Alert.65566&#39;,
    &#39;Source_Zone&#39;: &#39;Alert.65541&#39;,
    &#39;Spam_Score&#39;: &#39;Alert.262157&#39;,
    &#39;SrcIP&#39;: &#39;Alert.SrcIP&#39;,
    &#39;SrcMac&#39;: &#39;Alert.SrcMac&#39;,
    &#39;SrcPort&#39;: &#39;Alert.SrcPort&#39;,
    &#39;Start_Page&#39;: &#39;Alert.4456450&#39;,
    &#39;Status&#39;: &#39;Alert.65611&#39;,
    &#39;Step_Count&#39;: &#39;Alert.65563&#39;,
    &#39;Step_Name&#39;: &#39;Alert.65564&#39;,
    &#39;Sub_Status&#39;: &#39;Alert.65612&#39;,
    &#39;Subcategory&#39;: &#39;Alert.65627&#39;,
    &#39;Subject&#39;: &#39;Alert.4259848&#39;,
    &#39;TC_URL&#39;: &#39;Alert.4259857&#39;,
    &#39;Table_Name&#39;: &#39;Alert.65554&#39;,
    &#39;Target_Class&#39;: &#39;Alert.65543&#39;,
    &#39;Target_Context&#39;: &#39;Alert.4259872&#39;,
    &#39;Target_Process_Name&#39;: &#39;Alert.4259878&#39;,
    &#39;ThirdPartyType.Name&#39;: &#39;ThirdPartyType.Name&#39;,
    &#39;Threat_Category&#39;: &#39;Alert.65595&#39;,
    &#39;Threat_Handled&#39;: &#39;Alert.65596&#39;,
    &#39;Threat_Name&#39;: &#39;Alert.65538&#39;,
    &#39;To&#39;: &#39;Alert.4259845&#39;,
    &#39;To_Address&#39;: &#39;Alert.4259876&#39;,
    &#39;Trusted&#39;: &#39;Alert.Trusted&#39;,
    &#39;URL&#39;: &#39;Alert.4259841&#39;,
    &#39;URL_Category&#39;: &#39;Alert.65586&#39;,
    &#39;UUID&#39;: &#39;Alert.262163&#39;,
    &#39;UserFld10Cat&#39;: &#39;Alert.UserFld10Cat&#39;,
    &#39;UserFld21Cat&#39;: &#39;Alert.UserFld21Cat&#39;,
    &#39;UserFld22Cat&#39;: &#39;Alert.UserFld22Cat&#39;,
    &#39;UserFld23Cat&#39;: &#39;Alert.UserFld23Cat&#39;,
    &#39;UserFld24Cat&#39;: &#39;Alert.UserFld24Cat&#39;,
    &#39;UserFld25Cat&#39;: &#39;Alert.UserFld25Cat&#39;,
    &#39;UserFld26Cat&#39;: &#39;Alert.UserFld26Cat&#39;,
    &#39;UserFld27Cat&#39;: &#39;Alert.UserFld27Cat&#39;,
    &#39;UserFld8Cat&#39;: &#39;Alert.UserFld8Cat&#39;,
    &#39;UserFld9Cat&#39;: &#39;Alert.UserFld9Cat&#39;,
    &#39;UserIDDst&#39;: &#39;Alert.BIN(6)&#39;,
    &#39;UserIDDstCat&#39;: &#39;Alert.UserIDDstCat&#39;,
    &#39;UserIDSrc&#39;: &#39;Alert.BIN(7)&#39;,
    &#39;UserIDSrcCat&#39;: &#39;Alert.UserIDSrcCat&#39;,
    &#39;User_Agent&#39;: &#39;Alert.4259849&#39;,
    &#39;User_Nickname&#39;: &#39;Alert.BIN(14)&#39;,
    &#39;Users.Name&#39;: &#39;Users.Name&#39;,
    &#39;VLan&#39;: &#39;Alert.VLan&#39;,
    &#39;VPN_Feature_Name&#39;: &#39;Alert.65623&#39;,
    &#39;Version&#39;: &#39;Alert.4259859&#39;,
    &#39;Victim_IP&#39;: &#39;Alert.262174&#39;,
    &#39;Virtual_Machine_ID&#39;: &#39;Alert.65601&#39;,
    &#39;Virtual_Machine_Name&#39;: &#39;Alert.65600&#39;,
    &#39;Volume_ID&#39;: &#39;Alert.65565&#39;,
    &#39;Vulnerability_References&#39;: &#39;Alert.4259882&#39;,
    &#39;Web_Domain&#39;: &#39;Alert.65613&#39;,
    &#39;WriteTime&#39;: &#39;Alert.WriteTime&#39;,
    &#39;ZoneDst&#39;: &#39;Alert.ZoneDst&#39;,
    &#39;ZoneSrc&#39;: &#39;Alert.ZoneSrc&#39;,
    &#39;Zone_ZoneDst.Name&#39;: &#39;Zone_ZoneDst.Name&#39;,
    &#39;Zone_ZoneSrc.Name&#39;: &#39;Zone_ZoneSrc.Name&#39;}
    &#34;&#34;&#34;
    Best effort to match SIEM returned fields with initial.
    __getitem__, __contains__, __setitem__ and __delitem__ method have been rewrote in order to offer more comprehensive dict usage.
    For exemple, the SIEM will return dicts with keys like  `Alert.65613`, `Alert.BIN(7)` or `Alert.SrcIP`, you&#39;ll be able to use `Event` dictionnary object with your initial queried fields like `Web_Doamin`, `UserIDSrc` or `SrcIP`. 
    &#34;&#34;&#34;
    def __getitem__(self, key):
        &#34;&#34;&#34;
        Best effort to match or autocomplete the field name.
        &#34;&#34;&#34;
        if collections.UserDict.__contains__(self, key): 
            return collections.UserDict.__getitem__(self, key)
        elif key in self.SIEM_FIELDS_MAP.keys():
            if collections.UserDict.__contains__(self, self.SIEM_FIELDS_MAP[key]): 
                return collections.UserDict.__getitem__(self, self.SIEM_FIELDS_MAP[key])
        else :
            for table in self.FIELDS_TABLES :
                if collections.UserDict.__contains__(self, table+&#39;.&#39;+key): 
                    return collections.UserDict.__getitem__(self, table+&#39;.&#39;+key)
            raise KeyError(&#39;Dictionnary key not found : {}&#39;.format(key))
    def __contains__(self, key):
        if collections.UserDict.__contains__(self, key): 
            return True
        elif key in self.SIEM_FIELDS_MAP.keys():
            if collections.UserDict.__contains__(self, self.SIEM_FIELDS_MAP[key]): 
                return True
        else:
            for table in self.FIELDS_TABLES:
                if collections.UserDict.__contains__(self, table+&#39;.&#39;+key): 
                    return True
            return False
    def __setitem__(self, key, value):
        if collections.UserDict.__contains__(self, key): 
            collections.UserDict.__setitem__(self, key, value)
        elif key in self.SIEM_FIELDS_MAP.keys():
            if collections.UserDict.__contains__(self, self.SIEM_FIELDS_MAP[key]): 
                collections.UserDict.__setitem__(self, self.SIEM_FIELDS_MAP[key], value)
        else:
            for table in self.FIELDS_TABLES:
                if collections.UserDict.__contains__(self, table+&#39;.&#39;+key): 
                    collections.UserDict.__setitem__(self, table+&#39;.&#39;+key, value)
            raise KeyError(&#39;Dictionnary key not found : {}&#39;.format(key))
    def __delitem__(self, key):
        if collections.UserDict.__contains__(self, key): 
            collections.UserDict.__delitem__(self, key)
        elif key in self.SIEM_FIELDS_MAP.keys():
            if collections.UserDict.__contains__(self, self.SIEM_FIELDS_MAP[key]): 
                collections.UserDict.__delitem__(self, self.SIEM_FIELDS_MAP[key])
        else:
            for table in self.FIELDS_TABLES:
                if collections.UserDict.__contains__(self, table+&#39;.&#39;+key): 
                    collections.UserDict.__delitem__(self, table+&#39;.&#39;+key)
            raise KeyError(&#39;Dictionnary key not found : {}&#39;.format(key))

    def clear_notes(self):
        &#34;&#34;&#34;
        Replace the notes by an empty string. Desctructive action.
        &#34;&#34;&#34;
        self.set_note(&#39;&#39;, no_date=True)

    def set_note(self, note, no_date=False):
        &#34;&#34;&#34;
        Set the event&#39;s note. Desctructive action.
        &#34;&#34;&#34;
        the_id = self.data[&#34;Alert.IPSIDAlertID&#34;] if &#34;Alert.IPSIDAlertID&#34; in self.data else str(self.data[&#39;ipsId&#39;][&#39;id&#39;])+&#39;|&#39;+str(self.data[&#34;alertId&#34;]) if &#34;alertId&#34; in self.data else None

        if isinstance(the_id, str):

            if len(note) &gt;= 4000:
                log.warning(&#34;The note is longer than 4000 characters, only the&#34; 
                            &#34;first 4000 characters will be kept. The maximum&#34; 
                            &#34;accepted by the SIEM is 4096 characters.&#34;)
                note=note[:4000]+&#39;\n\n--NOTE HAS BEEN TRUNCATED--&#39;
            
            if no_date==False:
                timestamp = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)
                note = note.replace(&#39;&#34;&#39;,&#39;\\&#34;&#39;).replace(&#39;\n&#39;,&#39;\\n&#39;)
                note = timestamp + &#39; - &#39; + note
            
            self.nitro.request(&#34;add_note_to_event_int&#34;, 
                id=the_id,
                note=note)
        else :
            log.error(&#34;Couldn&#39;t set event&#39;s note, the event ID hasn&#39;t been found.&#34;)
        
    def data_from_id(self, id, use_query=False, extra_fields=[]):
        &#34;&#34;&#34;
        Load event&#39;s data.  

        Arguments:   

        - `id` : The event ID. (i.e. : `144128388087414784|747122896`)  
        - `use_query` : Uses the query module to retreive common event data. Only works with SIEM v 11.2.x.  
        - `extra_fields` : Only when `use_query=True`. Additionnal event fields to load in the query.  
        &#34;&#34;&#34;
        
        if use_query == True :

            e = EventManager(
                time_range=&#39;CUSTOM&#39;,
                start_time=datetime.now()-timedelta(days=365),
                end_time=datetime.now()+timedelta(days=1),
                filters=[(&#39;IPSIDAlertID&#39;,id)],
                fields=extra_fields,
                limit=2)
                
            e.load_data()

            if len(e) == 1 :
                return e[0]
            else :
                raise NitroError(&#39;Could not load event : &#39;+str(id)+&#39; from query :&#39;+str(e.__dict__)+&#39;. Try with use_query=False.&#39;)

        elif use_query == False :
            return self.nitro.request(&#39;get_alert_data&#39;, id=id)

    def refresh(self): 
        &#34;&#34;&#34;Re-load event&#39;s data&#34;&#34;&#34;
        if &#39;Alert.IPSIDAlertID&#39; in self.data.keys() :
            self.data.update(self.data_from_id(self.data[&#39;Alert.IPSIDAlertID&#39;], 
                use_query=True, extra_fields=self.data.keys()))
        else :
            id = &#39;|&#39;.join([str(self.data[&#39;ipsId&#39;][&#39;id&#39;]), str(self.data[&#39;alertId&#39;])])
            self.data.update(self.data_from_id(id))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="msiempy.NitroDict" href="index.html#msiempy.NitroDict">NitroDict</a></li>
<li>collections.UserDict</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="msiempy.NitroObject" href="index.html#msiempy.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.event.Event.FIELDS_TABLES"><code class="name">var <span class="ident">FIELDS_TABLES</span></code></dt>
<dd>
<section class="desc"><p>List of internal fields table : <code>Rule</code>,<code>Alert</code>,etc.</p></section>
</dd>
<dt id="msiempy.event.Event.DEFAULTS_EVENT_FIELDS"><code class="name">var <span class="ident">DEFAULTS_EVENT_FIELDS</span></code></dt>
<dd>
<section class="desc"><p>Always present when using <a title="msiempy.event.EventManager" href="#msiempy.event.EventManager"><code>EventManager</code></a> querying :<br>
<code>Rule.msg</code><br>
<code>Alert.LastTime</code><br>
<code>Alert.IPSIDAlertID</code></p></section>
</dd>
<dt id="msiempy.event.Event.REGULAR_EVENT_FIELDS"><code class="name">var <span class="ident">REGULAR_EVENT_FIELDS</span></code></dt>
<dd>
<section class="desc"><p><code>Rule.msg</code><br>
<code>Alert.SrcIP</code><br>
<code>Alert.DstIP</code> <br>
<code>Alert.SrcMac</code><br>
<code>Alert.DstMac</code><br>
<code>Rule.NormID</code><br>
<code>HostID</code><br>
<code>UserIDSrc</code><br>
<code>ObjectID</code><br>
<code>Alert.Severity</code><br>
<code>Alert.LastTime</code><br>
<code>Alert.DSIDSigID</code><br>
<code>Alert.IPSIDAlertID</code></p></section>
</dd>
<dt id="msiempy.event.Event.SIEM_FIELDS_MAP"><code class="name">var <span class="ident">SIEM_FIELDS_MAP</span></code></dt>
<dd>
<section class="desc"><p>Best effort to match SIEM returned fields with initial.
<strong>getitem</strong>, <strong>contains</strong>, <strong>setitem</strong> and <strong>delitem</strong> method have been rewrote in order to offer more comprehensive dict usage.
For exemple, the SIEM will return dicts with keys like
<code>Alert.65613</code>, <code>Alert.BIN(7)</code> or <code>Alert.SrcIP</code>, you'll be able to use <a title="msiempy.event.Event" href="#msiempy.event.Event"><code>Event</code></a> dictionnary object with your initial queried fields like <code>Web_Doamin</code>, <code>UserIDSrc</code> or <code>SrcIP</code>.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.event.Event.clear_notes"><code class="name flex">
<span>def <span class="ident">clear_notes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Replace the notes by an empty string. Desctructive action.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_notes(self):
    &#34;&#34;&#34;
    Replace the notes by an empty string. Desctructive action.
    &#34;&#34;&#34;
    self.set_note(&#39;&#39;, no_date=True)</code></pre>
</details>
</dd>
<dt id="msiempy.event.Event.set_note"><code class="name flex">
<span>def <span class="ident">set_note</span></span>(<span>self, note, no_date=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the event's note. Desctructive action.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_note(self, note, no_date=False):
    &#34;&#34;&#34;
    Set the event&#39;s note. Desctructive action.
    &#34;&#34;&#34;
    the_id = self.data[&#34;Alert.IPSIDAlertID&#34;] if &#34;Alert.IPSIDAlertID&#34; in self.data else str(self.data[&#39;ipsId&#39;][&#39;id&#39;])+&#39;|&#39;+str(self.data[&#34;alertId&#34;]) if &#34;alertId&#34; in self.data else None

    if isinstance(the_id, str):

        if len(note) &gt;= 4000:
            log.warning(&#34;The note is longer than 4000 characters, only the&#34; 
                        &#34;first 4000 characters will be kept. The maximum&#34; 
                        &#34;accepted by the SIEM is 4096 characters.&#34;)
            note=note[:4000]+&#39;\n\n--NOTE HAS BEEN TRUNCATED--&#39;
        
        if no_date==False:
            timestamp = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)
            note = note.replace(&#39;&#34;&#39;,&#39;\\&#34;&#39;).replace(&#39;\n&#39;,&#39;\\n&#39;)
            note = timestamp + &#39; - &#39; + note
        
        self.nitro.request(&#34;add_note_to_event_int&#34;, 
            id=the_id,
            note=note)
    else :
        log.error(&#34;Couldn&#39;t set event&#39;s note, the event ID hasn&#39;t been found.&#34;)</code></pre>
</details>
</dd>
<dt id="msiempy.event.Event.data_from_id"><code class="name flex">
<span>def <span class="ident">data_from_id</span></span>(<span>self, id, use_query=False, extra_fields=[])</span>
</code></dt>
<dd>
<section class="desc"><p>Load event's data.
</p>
<p>Arguments:
</p>
<ul>
<li><code>id</code> : The event ID. (i.e. : <code>144128388087414784|747122896</code>)
</li>
<li><code>use_query</code> : Uses the query module to retreive common event data. Only works with SIEM v 11.2.x.
</li>
<li><code>extra_fields</code> : Only when <code>use_query=True</code>. Additionnal event fields to load in the query.</li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_from_id(self, id, use_query=False, extra_fields=[]):
    &#34;&#34;&#34;
    Load event&#39;s data.  

    Arguments:   

    - `id` : The event ID. (i.e. : `144128388087414784|747122896`)  
    - `use_query` : Uses the query module to retreive common event data. Only works with SIEM v 11.2.x.  
    - `extra_fields` : Only when `use_query=True`. Additionnal event fields to load in the query.  
    &#34;&#34;&#34;
    
    if use_query == True :

        e = EventManager(
            time_range=&#39;CUSTOM&#39;,
            start_time=datetime.now()-timedelta(days=365),
            end_time=datetime.now()+timedelta(days=1),
            filters=[(&#39;IPSIDAlertID&#39;,id)],
            fields=extra_fields,
            limit=2)
            
        e.load_data()

        if len(e) == 1 :
            return e[0]
        else :
            raise NitroError(&#39;Could not load event : &#39;+str(id)+&#39; from query :&#39;+str(e.__dict__)+&#39;. Try with use_query=False.&#39;)

    elif use_query == False :
        return self.nitro.request(&#39;get_alert_data&#39;, id=id)</code></pre>
</details>
</dd>
<dt id="msiempy.event.Event.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Re-load event's data</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self): 
    &#34;&#34;&#34;Re-load event&#39;s data&#34;&#34;&#34;
    if &#39;Alert.IPSIDAlertID&#39; in self.data.keys() :
        self.data.update(self.data_from_id(self.data[&#39;Alert.IPSIDAlertID&#39;], 
            use_query=True, extra_fields=self.data.keys()))
    else :
        id = &#39;|&#39;.join([str(self.data[&#39;ipsId&#39;][&#39;id&#39;]), str(self.data[&#39;alertId&#39;])])
        self.data.update(self.data_from_id(id))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.NitroDict" href="index.html#msiempy.NitroDict">NitroDict</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.NitroDict.NitroJSONEncoder" href="index.html#msiempy.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.NitroDict.json" href="index.html#msiempy.NitroDict.json">json</a></code></li>
<li><code><a title="msiempy.NitroDict.nitro" href="index.html#msiempy.NitroObject.nitro">nitro</a></code></li>
<li><code><a title="msiempy.NitroDict.text" href="index.html#msiempy.NitroDict.text">text</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="msiempy.event.GroupFilter"><code class="flex name class">
<span>class <span class="ident">GroupFilter</span></span>
<span>(</span><span>filters, logic='AND')</span>
</code></dt>
<dd>
<section class="desc"><p>Based on EsmFilterGroup. See SIEM api doc.
Used to dump groups of filters in the right format.</p>
<p>Arguments :
</p>
<ul>
<li><code>filters</code> : a list of filters, it can be <a title="msiempy.event.FieldFilter" href="#msiempy.event.FieldFilter"><code>FieldFilter</code></a> or <a title="msiempy.event.GroupFilter" href="#msiempy.event.GroupFilter"><code>GroupFilter</code></a>
</li>
<li><code>logic</code> : 'AND' or 'OR'</li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GroupFilter(_QueryFilter):
    &#34;&#34;&#34;
        Based on EsmFilterGroup. See SIEM api doc.
        Used to dump groups of filters in the right format.

        Arguments :  

        - `filters` : a list of filters, it can be `msiempy.event.FieldFilter` or `msiempy.event.GroupFilter`  
        - `logic` : &#39;AND&#39; or &#39;OR&#39;  
    &#34;&#34;&#34;

    def __init__(self, filters, logic=&#39;AND&#39;) :
        super().__init__()
        
        #Declaring attributes
        self.data={
            &#34;type&#34;: &#34;EsmFilterGroup&#34;,
            &#34;filters&#34;: [dict(f) for f in filters],
            &#34;logic&#34;:logic
            }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>msiempy.event._QueryFilter</li>
<li>collections.UserDict</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
</dd>
<dt id="msiempy.event.FieldFilter"><code class="flex name class">
<span>class <span class="ident">FieldFilter</span></span>
<span>(</span><span>name, values, operator='IN')</span>
</code></dt>
<dd>
<section class="desc"><p>Based on EsmFieldFilter. See SIEM api doc.
Used to dump a filter in the right format.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li><code>name</code> : field name as string. Field name property. Example : <code>SrcIP</code>. See full list here: <a href="https://github.com/mfesiem/msiempy/blob/master/static/all_filters.json">https://github.com/mfesiem/msiempy/blob/master/static/all_filters.json</a></li>
<li><code>values</code> : list of values the field is going to be tested againts with the specified orperator.
</li>
<li><code>orperator</code> : <code>IN</code>,
<code>NOT_IN</code>,
<code>GREATER_THAN</code>,
<code>LESS_THAN</code>,
<code>GREATER_OR_EQUALS_THAN</code>,
<code>LESS_OR_EQUALS_THAN</code>,
<code>NUMERIC_EQUALS</code>,
<code>NUMERIC_NOT_EQUALS</code>,
<code>DOES_NOT_EQUAL</code>,
<code>EQUALS</code>,
<code>CONTAINS</code>,
<code>DOES_NOT_CONTAIN</code>,
<code>REGEX</code>.</li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FieldFilter(_QueryFilter):
    &#34;&#34;&#34;
    Based on EsmFieldFilter. See SIEM api doc.
    Used to dump a filter in the right format.

    Arguments:

        - `name` : field name as string. Field name property. Example : `SrcIP`. See full list here: https://github.com/mfesiem/msiempy/blob/master/static/all_filters.json
        - `values` : list of values the field is going to be tested againts with the specified orperator.  
        - `orperator` : `IN`,
        `NOT_IN`,
        `GREATER_THAN`,
        `LESS_THAN`,
        `GREATER_OR_EQUALS_THAN`,
        `LESS_OR_EQUALS_THAN`,
        `NUMERIC_EQUALS`,
        `NUMERIC_NOT_EQUALS`,
        `DOES_NOT_EQUAL`,
        `EQUALS`,
        `CONTAINS`,
        `DOES_NOT_CONTAIN`,
        `REGEX`.  
    &#34;&#34;&#34;

    def __init__(self, name, values, operator=&#39;IN&#39;) :
        super().__init__()
        #Declaring attributes
        self._operator=str()
        self._values=list()
        self.name = name
        self.operator = operator
        self.values = values

        self.data={
            &#34;type&#34;: &#34;EsmFieldFilter&#34;,
            &#34;field&#34;: {&#34;name&#34;: self.name},
            &#34;operator&#34;: self.operator,
            &#34;values&#34;: self.values
            }

    
    POSSIBLE_OPERATORS=[&#39;IN&#39;,
        &#39;NOT_IN&#39;,
        &#39;GREATER_THAN&#39;,
        &#39;LESS_THAN&#39;,
        &#39;GREATER_OR_EQUALS_THAN&#39;,
        &#39;LESS_OR_EQUALS_THAN&#39;,
        &#39;NUMERIC_EQUALS&#39;,
        &#39;NUMERIC_NOT_EQUALS&#39;,
        &#39;DOES_NOT_EQUAL&#39;,
        &#39;EQUALS&#39;,
        &#39;CONTAINS&#39;,
        &#39;DOES_NOT_CONTAIN&#39;,
        &#39;REGEX&#39;]
    &#34;&#34;&#34;List of possibles operators&#34;&#34;&#34;

    POSSIBLE_VALUE_TYPES=[
            {&#39;type&#39;:&#39;EsmWatchlistValue&#39;,    &#39;key&#39;:&#39;watchlist&#39;},
            {&#39;type&#39;:&#39;EsmVariableValue&#39;,     &#39;key&#39;:&#39;variable&#39;},
            {&#39;type&#39;:&#39;EsmBasicValue&#39;,        &#39;key&#39;:&#39;value&#39;},
            {&#39;type&#39;:&#39;EsmCompoundValue&#39;,     &#39;key&#39;:&#39;values&#39;}]
    &#34;&#34;&#34;
    List of possible value type. See `msiempy.event.FieldFilter.add_value`.
    &#34;&#34;&#34;
   
    @property
    def operator(self):
        &#34;&#34;&#34;Field operator.  
        Setter check the value against the list of possible operators and trow `AttributeError` if not present.
        &#34;&#34;&#34;
        return (self._operator)
    
    @operator.setter
    def operator(self, operator):
        try:
            if operator in self.POSSIBLE_OPERATORS :
                self._operator = operator
            else:
                raise AttributeError(&#34;Illegal value for the filter operator &#34;+operator+&#34;. The operator must be in &#34;+str(self.POSSIBLE_OPERATORS))
        except:
            raise

    @property
    def values(self):
        &#34;&#34;&#34;List of values of the filter.  
        Setter iterate trough the list and call : 

        - `msiempy.FilteredQueryList.add_value()` if value is a `dict`
        - `msiempy.FilteredQueryList.add_basic_value()` if value type is `int`, `float` or `str`.

        Values will always be added to the filter. To remove values, handle directly the `_values` property.

        Example :  
            `filter = FieldFilter(name=&#39;DstIP&#39;,values=[&#39;10.1.13.0/24&#39;, {&#39;type&#39;:&#39;EsmWatchlistValue&#39;, &#39;watchlist&#39;:42}], operator=&#39;IN&#39;)`
        &#34;&#34;&#34;
        return (self._values)

    @values.setter  
    def values(self, values):
        if isinstance(values, list): 

            for val in values :
                if isinstance(val, dict):
                    self.add_value(**val)

                elif isinstance(val, (int, float, str)) :
                    self.add_basic_value(val)

                else:
                    raise TypeError(&#34;Invalid filter type, must be a list, int, float or str&#34;)
        
        elif isinstance(values, dict):
            self.add_value(**values)

        elif isinstance(values, (int, float, str)) :
            self.add_basic_value(values)
        
        else :
            raise TypeError(&#34;Invalid filter type, must be a list, int, float or str&#34;)
        
    def add_value(self, type=None, **kwargs):
        &#34;&#34;&#34;
        Add a new value to the field filter.  
        
        Arguments (`**kwargs` depends on the value `type`):  

        - `type` (`str`) : Type of the value    
        - `value` (`str`) : If `type` is `EsmBasicValue`  
        - `watchlist` (`int`) : if `type` is `EsmWatchlistValue`    
        - `variable` (`int`) if `type` is `EsmVariableValue`    
        - `values` (`list`) if `type` is `EsmCompoundValue`  
        
        Raises : `KeyError` or `AttributeError` if you don&#39;t respect the correct type/key/value combo.  
        Note : Filtering query with other type of filter than `EsmBasicValue` is not tested.
        &#34;&#34;&#34;
        try:
            type_template=None
            
            #Look for the type of the object ex EsmBasicValue
            # it&#39; used to know the type and name of value parameter we should receive next
            for possible_value_type in self.POSSIBLE_VALUE_TYPES :
                if possible_value_type[&#39;type&#39;] == type :
                    type_template=possible_value_type
                    if type != &#39;EsmBasicValue&#39; :
                        log.warning(&#34;Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.&#34;)                            
                    break

            #Error throwing
            if type_template != None :
                if type_template[&#39;key&#39;] in kwargs :
                    
                    # Adds a new value to a fields filter
                    # Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.
                    value = kwargs[type_template[&#39;key&#39;]]
                    if type == &#39;EsmBasicValue&#39; :
                        value=str(value)
                        #log.debug(&#39;Adding a basic value to filter (&#39;+self.text+&#39;) : &#39;+value)
                    self._values.append({&#39;type&#39;:type, type_template[&#39;key&#39;]:value})
                    #log.debug(&#39;The value was appended to the list: &#39;+str(self))
                    
                #Error throwing
                else: raise KeyError (&#39;The valid key value argument is not present&#39;)
            else: raise KeyError (&#39;Impossible filter&#39;)
        except KeyError as err:
            raise AttributeError(&#34;You must provide a valid named Arguments containing the type and values for this filter. The type/keys must be in &#34;+str(self.POSSIBLE_VALUE_TYPES)+&#34;Can&#39;t be type=&#34;+str(type)+&#39; &#39;+str(kwargs)+&#34;. Additionnal indicator :&#34;+str(err) )

    def add_basic_value(self, value):
        &#34;&#34;&#34;
        Wrapper arround `add_value` method to simply add a `EsmBasicValue`.
        &#34;&#34;&#34;
        self.add_value(type=&#39;EsmBasicValue&#39;, value=value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>msiempy.event._QueryFilter</li>
<li>collections.UserDict</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.event.FieldFilter.POSSIBLE_OPERATORS"><code class="name">var <span class="ident">POSSIBLE_OPERATORS</span></code></dt>
<dd>
<section class="desc"><p>List of possibles operators</p></section>
</dd>
<dt id="msiempy.event.FieldFilter.POSSIBLE_VALUE_TYPES"><code class="name">var <span class="ident">POSSIBLE_VALUE_TYPES</span></code></dt>
<dd>
<section class="desc"><p>List of possible value type. See <a title="msiempy.event.FieldFilter.add_value" href="#msiempy.event.FieldFilter.add_value"><code>FieldFilter.add_value()</code></a>.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.event.FieldFilter.operator"><code class="name">var <span class="ident">operator</span></code></dt>
<dd>
<section class="desc"><p>Field operator.<br>
Setter check the value against the list of possible operators and trow <code>AttributeError</code> if not present.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def operator(self):
    &#34;&#34;&#34;Field operator.  
    Setter check the value against the list of possible operators and trow `AttributeError` if not present.
    &#34;&#34;&#34;
    return (self._operator)</code></pre>
</details>
</dd>
<dt id="msiempy.event.FieldFilter.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<section class="desc"><p>List of values of the filter.<br>
Setter iterate trough the list and call : </p>
<ul>
<li><code>msiempy.FilteredQueryList.add_value()</code> if value is a <code>dict</code></li>
<li><code>msiempy.FilteredQueryList.add_basic_value()</code> if value type is <code>int</code>, <code>float</code> or <code>str</code>.</li>
</ul>
<p>Values will always be added to the filter. To remove values, handle directly the <code>_values</code> property.</p>
<p>Example :<br>
<code>filter = FieldFilter(name='DstIP',values=['10.1.13.0/24', {'type':'EsmWatchlistValue', 'watchlist':42}], operator='IN')</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self):
    &#34;&#34;&#34;List of values of the filter.  
    Setter iterate trough the list and call : 

    - `msiempy.FilteredQueryList.add_value()` if value is a `dict`
    - `msiempy.FilteredQueryList.add_basic_value()` if value type is `int`, `float` or `str`.

    Values will always be added to the filter. To remove values, handle directly the `_values` property.

    Example :  
        `filter = FieldFilter(name=&#39;DstIP&#39;,values=[&#39;10.1.13.0/24&#39;, {&#39;type&#39;:&#39;EsmWatchlistValue&#39;, &#39;watchlist&#39;:42}], operator=&#39;IN&#39;)`
    &#34;&#34;&#34;
    return (self._values)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.event.FieldFilter.add_value"><code class="name flex">
<span>def <span class="ident">add_value</span></span>(<span>self, type=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a new value to the field filter.
</p>
<p>Arguments (<code>**kwargs</code> depends on the value <code>type</code>):
</p>
<ul>
<li><code>type</code> (<code>str</code>) : Type of the value
</li>
<li><code>value</code> (<code>str</code>) : If <code>type</code> is <code>EsmBasicValue</code>
</li>
<li><code>watchlist</code> (<code>int</code>) : if <code>type</code> is <code>EsmWatchlistValue</code>
</li>
<li><code>variable</code> (<code>int</code>) if <code>type</code> is <code>EsmVariableValue</code>
</li>
<li><code>values</code> (<code>list</code>) if <code>type</code> is <code>EsmCompoundValue</code>
</li>
</ul>
<p>Raises : <code>KeyError</code> or <code>AttributeError</code> if you don't respect the correct type/key/value combo.<br>
Note : Filtering query with other type of filter than <code>EsmBasicValue</code> is not tested.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_value(self, type=None, **kwargs):
    &#34;&#34;&#34;
    Add a new value to the field filter.  
    
    Arguments (`**kwargs` depends on the value `type`):  

    - `type` (`str`) : Type of the value    
    - `value` (`str`) : If `type` is `EsmBasicValue`  
    - `watchlist` (`int`) : if `type` is `EsmWatchlistValue`    
    - `variable` (`int`) if `type` is `EsmVariableValue`    
    - `values` (`list`) if `type` is `EsmCompoundValue`  
    
    Raises : `KeyError` or `AttributeError` if you don&#39;t respect the correct type/key/value combo.  
    Note : Filtering query with other type of filter than `EsmBasicValue` is not tested.
    &#34;&#34;&#34;
    try:
        type_template=None
        
        #Look for the type of the object ex EsmBasicValue
        # it&#39; used to know the type and name of value parameter we should receive next
        for possible_value_type in self.POSSIBLE_VALUE_TYPES :
            if possible_value_type[&#39;type&#39;] == type :
                type_template=possible_value_type
                if type != &#39;EsmBasicValue&#39; :
                    log.warning(&#34;Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.&#34;)                            
                break

        #Error throwing
        if type_template != None :
            if type_template[&#39;key&#39;] in kwargs :
                
                # Adds a new value to a fields filter
                # Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.
                value = kwargs[type_template[&#39;key&#39;]]
                if type == &#39;EsmBasicValue&#39; :
                    value=str(value)
                    #log.debug(&#39;Adding a basic value to filter (&#39;+self.text+&#39;) : &#39;+value)
                self._values.append({&#39;type&#39;:type, type_template[&#39;key&#39;]:value})
                #log.debug(&#39;The value was appended to the list: &#39;+str(self))
                
            #Error throwing
            else: raise KeyError (&#39;The valid key value argument is not present&#39;)
        else: raise KeyError (&#39;Impossible filter&#39;)
    except KeyError as err:
        raise AttributeError(&#34;You must provide a valid named Arguments containing the type and values for this filter. The type/keys must be in &#34;+str(self.POSSIBLE_VALUE_TYPES)+&#34;Can&#39;t be type=&#34;+str(type)+&#39; &#39;+str(kwargs)+&#34;. Additionnal indicator :&#34;+str(err) )</code></pre>
</details>
</dd>
<dt id="msiempy.event.FieldFilter.add_basic_value"><code class="name flex">
<span>def <span class="ident">add_basic_value</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Wrapper arround <code>add_value</code> method to simply add a <code>EsmBasicValue</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_basic_value(self, value):
    &#34;&#34;&#34;
    Wrapper arround `add_value` method to simply add a `EsmBasicValue`.
    &#34;&#34;&#34;
    self.add_value(type=&#39;EsmBasicValue&#39;, value=value)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="msiempy" href="index.html">msiempy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="msiempy.event.EventManager" href="#msiempy.event.EventManager">EventManager</a></code></h4>
<ul class="">
<li><code><a title="msiempy.event.EventManager.add_filter" href="#msiempy.event.EventManager.add_filter">add_filter</a></code></li>
<li><code><a title="msiempy.event.EventManager.clear_filters" href="#msiempy.event.EventManager.clear_filters">clear_filters</a></code></li>
<li><code><a title="msiempy.event.EventManager.get_possible_fields" href="#msiempy.event.EventManager.get_possible_fields">get_possible_fields</a></code></li>
<li><code><a title="msiempy.event.EventManager.qry_load_data" href="#msiempy.event.EventManager.qry_load_data">qry_load_data</a></code></li>
<li><code><a title="msiempy.event.EventManager.load_data" href="#msiempy.event.EventManager.load_data">load_data</a></code></li>
<li><code><a title="msiempy.event.EventManager.get_possible_filters" href="#msiempy.event.EventManager.get_possible_filters">get_possible_filters</a></code></li>
<li><code><a title="msiempy.event.EventManager.order" href="#msiempy.event.EventManager.order">order</a></code></li>
<li><code><a title="msiempy.event.EventManager.filters" href="#msiempy.event.EventManager.filters">filters</a></code></li>
<li><code><a title="msiempy.event.EventManager.TYPE" href="#msiempy.event.EventManager.TYPE">TYPE</a></code></li>
<li><code><a title="msiempy.event.EventManager.GROUPTYPE" href="#msiempy.event.EventManager.GROUPTYPE">GROUPTYPE</a></code></li>
<li><code><a title="msiempy.event.EventManager.POSSBILE_ROW_ORDER" href="#msiempy.event.EventManager.POSSBILE_ROW_ORDER">POSSBILE_ROW_ORDER</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.event.Event" href="#msiempy.event.Event">Event</a></code></h4>
<ul class="">
<li><code><a title="msiempy.event.Event.clear_notes" href="#msiempy.event.Event.clear_notes">clear_notes</a></code></li>
<li><code><a title="msiempy.event.Event.set_note" href="#msiempy.event.Event.set_note">set_note</a></code></li>
<li><code><a title="msiempy.event.Event.data_from_id" href="#msiempy.event.Event.data_from_id">data_from_id</a></code></li>
<li><code><a title="msiempy.event.Event.refresh" href="#msiempy.event.Event.refresh">refresh</a></code></li>
<li><code><a title="msiempy.event.Event.FIELDS_TABLES" href="#msiempy.event.Event.FIELDS_TABLES">FIELDS_TABLES</a></code></li>
<li><code><a title="msiempy.event.Event.DEFAULTS_EVENT_FIELDS" href="#msiempy.event.Event.DEFAULTS_EVENT_FIELDS">DEFAULTS_EVENT_FIELDS</a></code></li>
<li><code><a title="msiempy.event.Event.REGULAR_EVENT_FIELDS" href="#msiempy.event.Event.REGULAR_EVENT_FIELDS">REGULAR_EVENT_FIELDS</a></code></li>
<li><code><a title="msiempy.event.Event.SIEM_FIELDS_MAP" href="#msiempy.event.Event.SIEM_FIELDS_MAP">SIEM_FIELDS_MAP</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.event.GroupFilter" href="#msiempy.event.GroupFilter">GroupFilter</a></code></h4>
</li>
<li>
<h4><code><a title="msiempy.event.FieldFilter" href="#msiempy.event.FieldFilter">FieldFilter</a></code></h4>
<ul class="">
<li><code><a title="msiempy.event.FieldFilter.add_value" href="#msiempy.event.FieldFilter.add_value">add_value</a></code></li>
<li><code><a title="msiempy.event.FieldFilter.add_basic_value" href="#msiempy.event.FieldFilter.add_basic_value">add_basic_value</a></code></li>
<li><code><a title="msiempy.event.FieldFilter.operator" href="#msiempy.event.FieldFilter.operator">operator</a></code></li>
<li><code><a title="msiempy.event.FieldFilter.values" href="#msiempy.event.FieldFilter.values">values</a></code></li>
<li><code><a title="msiempy.event.FieldFilter.POSSIBLE_OPERATORS" href="#msiempy.event.FieldFilter.POSSIBLE_OPERATORS">POSSIBLE_OPERATORS</a></code></li>
<li><code><a title="msiempy.event.FieldFilter.POSSIBLE_VALUE_TYPES" href="#msiempy.event.FieldFilter.POSSIBLE_VALUE_TYPES">POSSIBLE_VALUE_TYPES</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
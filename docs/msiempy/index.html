<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>msiempy API documentation</title>
<meta name="description" content="Welcome to the msiempy base framework module documentation.
Classes listed in this module are used by other classes in sub-modules to build â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>msiempy</code></h1>
</header>
<section id="section-intro">
<p>Welcome to the msiempy base framework module documentation.
Classes listed in this module are used by other classes in sub-modules to build specialized objects and functions.
<a title="msiempy.NitroSession" href="#msiempy.NitroSession"><code>NitroSession</code></a> is the point of convergence of every request to the McFee ESM It provides standard dialogue with the esm.
It uses <a title="msiempy.NitroConfig" href="#msiempy.NitroConfig"><code>NitroConfig</code></a> to setup authentication, other configuration like verbosity, logfile, general timeout, are offered throught the config file.
This API offers two main types of objects to interact with the SIEM : <a title="msiempy.NitroList" href="#msiempy.NitroList"><code>NitroList</code></a>, <a title="msiempy.NitroDict" href="#msiempy.NitroDict"><code>NitroDict</code></a>.
<a title="msiempy.NitroList" href="#msiempy.NitroList"><code>NitroList</code></a>s have default behaviours related to parallel execution, string representation generation and search feature.
Whereas <a title="msiempy.NitroDict" href="#msiempy.NitroDict"><code>NitroDict</code></a> that doesn't have any specific behaviours.</p>
<p>Look at the class diagram : <a href="https://mfesiem.github.io/docs/msiempy/classes.png">https://mfesiem.github.io/docs/msiempy/classes.png</a></p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;Welcome to the msiempy base framework module documentation.
Classes listed in this module are used by other classes in sub-modules to build specialized objects and functions.
`msiempy.NitroSession` is the point of convergence of every request to the McFee ESM It provides standard dialogue with the esm.
It uses `msiempy.NitroConfig` to setup authentication, other configuration like verbosity, logfile, general timeout, are offered throught the config file.
This API offers two main types of objects to interact with the SIEM : `msiempy.NitroList`, `msiempy.NitroDict`.
`msiempy.NitroList`s have default behaviours related to parallel execution, string representation generation and search feature.
Whereas `msiempy.NitroDict` that doesn&#39;t have any specific behaviours.


Look at the class diagram : https://mfesiem.github.io/docs/msiempy/classes.png
&#34;&#34;&#34;
__version__ = &#39;0.1.1&#39;

import logging
import requests
import json
import ast
import re
import urllib.parse
import urllib3
import configparser
import os
import getpass
import abc
import collections
import tqdm
import copy
import csv
import concurrent.futures
import prettytable
from prettytable import MSWORD_FRIENDLY
import datetime
import functools
import textwrap

from .utils import regex_match, tob64
from .params import PARAMS

try :
    requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
except : pass

logging.getLogger(&#34;urllib3&#34;).setLevel(logging.WARNING)
log = logging.getLogger(&#39;msiempy&#39;)



class NitroError(Exception):
    &#34;&#34;&#34;
    Base internal exception. It&#39;s used when the user/passwd is incorrect, or other specific ESM related errors.
    &#34;&#34;&#34;
    pass

class NitroConfig(configparser.ConfigParser):
    &#34;&#34;&#34;Class that handles the configuration. Reads the config file where ever it is and make accessible it&#39;s values throught object properties. 
    If a `.msiem/` directory exists in your current directory, the program will assume the `conf.ini` file is there, if not, it will create it with default values. 
    Secondly, if no `.msiem/` directory exists in the current directory, it will be automatically placed in a appropriate place depending of your platform:  
    - For Windows:  %APPDATA%\\  
    - For Mac :     $HOME/  
    - For Linux :   $XDG_CONFIG_HOME/ or : $HOME/
    &#34;&#34;&#34;

    CONFIG_FILE_NAME=&#39;.msiem/conf.ini&#39;
    &#34;&#34;&#34;`.msiem/conf.ini`&#34;&#34;&#34;

    CONF_DIR=&#39;.msiem/&#39;
    &#34;&#34;&#34;`.msiem/`&#34;&#34;&#34;

    DEFAULT_CONF_DICT={
        &#39;esm&#39;:{&#39;host&#39;:&#39;&#39;, 
            &#39;user&#39;:&#39;&#39;,
            &#39;passwd&#39;:&#39;&#39;},
        &#39;general&#39;:{&#39;verbose&#39;:False,
            &#39;quiet&#39;:False,
            &#39;logfile&#39;:&#39;&#39;,
            &#39;timeout&#39;:30,
            &#39;ssl_verify&#39;:False,
            &#39;output&#39;:&#39;text&#39;}
    }
    &#34;&#34;&#34;
    Default configuration file should look like this. Authentication is left empty.
    ```
    [esm]
    host = 
    user = 
    passwd = 

    [general]
    verbose = False
    quiet = False
    logfile = 
    timeout = 30
    ssl_verify = False
    output = text #Not used yet
    ```
    &#34;&#34;&#34;

    def __str__(self):
        &#34;&#34;&#34;Custom str() method that lists all config fields.
        &#34;&#34;&#34;
        return(&#39;Configuration file : &#39;+ self._path+&#39;\n&#39;+str({section: dict(self[section]) for section in self.sections()}))

    def __init__(self, path=None, config=None, *arg, **kwarg):
        &#34;&#34;&#34;
        Initiate a config object.  

        Parameters:  

        - path: Config file speciale path, if path is left None, will automatically look for it.  
        - config: Manual config dict. ex: ```{&#39;general&#39;:{&#39;verbose&#39;:True}}```  
        - *args, **kwargs : Passed to configparser.ConfigParser __init__()
        &#34;&#34;&#34;

        super().__init__(*arg, **kwarg)

        self.read_dict(self.DEFAULT_CONF_DICT)
    
        if not path :
            self._path = self._find_ini_location()
        else : 
            self._path = path

        try :
            files=self.read(self._path)
            if len(files) == 0:
                raise FileNotFoundError

        except :
            log.info(&#34;Config file inexistant or currupted, applying defaults&#34;)

            if not os.path.exists(os.path.dirname(self._path)):
                os.makedirs(os.path.dirname(self._path))
            self.write()

        if config is not None :
            log.info(&#34;Reading config_dict : &#34;+str(self))
            self.read_dict(config)

    def write(self):
        &#34;&#34;&#34;
        Write the config file.
        &#34;&#34;&#34;
        log.info(&#34;Write config file at &#34;+self._path)
        with open(self._path, &#39;w&#39;) as conf:
            super().write(conf)

    def _iset(self, section, option, secure=False):
        &#34;&#34;&#34;Internal method to interactively set  a option in a section.
        &#34;&#34;&#34;
        msg=&#39;Enter [{}]{}&#39;
        value = self.get(section, option)
        newvalue=&#39;&#39;
        if option==&#39;passwd&#39;:
            secure=True
        if secure :
            newvalue = tob64(getpass.getpass(msg.format(section, option)+&#39;. Press &lt;Enter&gt; to skip: &#39;))
        else:
            newvalue = input(msg.format(section, option)+ &#39;. Press &lt;Enter&gt; to keep &#39;+ (value if (str(value) is not &#39;&#39;) else &#39;empty&#39;) + &#39;: &#39;)
        if newvalue != &#39;&#39; :
            super().set(section, option, newvalue)

    def iset(self, section, option=None, secure=False):
        &#34;&#34;&#34;
        Will interactively set the specified section/optionby asking the user the input.
        If option stays None, all section&#39;s option will be interactively set.
        &#34;&#34;&#34;
        if option is None :
            for key in self.options(section):
                self._iset(section, key, secure)
        else :
            self._iset(section, option, secure)

    @property
    def user(self):
        &#34;&#34;&#34;ConfigParser.get(&#39;esm&#39;, &#39;user&#39;)&#34;&#34;&#34;
        return self.get(&#39;esm&#39;, &#39;user&#39;)

    @property
    def host(self):
        &#34;&#34;&#34;ConfigParser.get(&#39;esm&#39;, &#39;host&#39;)&#34;&#34;&#34;
        return self.get(&#39;esm&#39;, &#39;host&#39;)

    @property
    def passwd(self):
        &#34;&#34;&#34;ConfigParser.get(&#39;esm&#39;, &#39;passwd&#39;)&#34;&#34;&#34;
        return self.get(&#39;esm&#39;, &#39;passwd&#39;)

    @property
    def verbose(self):
        &#34;&#34;&#34;ConfigParser.getboolean(&#39;general&#39;, &#39;verbose&#39;)&#34;&#34;&#34;
        return self.getboolean(&#39;general&#39;, &#39;verbose&#39;)

    @property
    def quiet(self):
        &#34;&#34;&#34;ConfigParser.getboolean(&#39;general&#39;, &#39;quiet&#39;)&#34;&#34;&#34;
        return self.getboolean(&#39;general&#39;, &#39;quiet&#39;)

    @property
    def logfile(self):
        &#34;&#34;&#34;ConfigParser.get(&#39;general&#39;, &#39;logfile&#39;)&#34;&#34;&#34;
        return self.get(&#39;general&#39;, &#39;logfile&#39;)

    @property
    def timeout(self):
        &#34;&#34;&#34;ConfigParser.getint(&#39;general&#39;, &#39;timeout&#39;)&#34;&#34;&#34;
        return self.getint(&#39;general&#39;, &#39;timeout&#39;)

    @property
    def ssl_verify(self):
        &#34;&#34;&#34;ConfigParser.getboolean(&#39;general&#39;, &#39;ssl_verify&#39;)&#34;&#34;&#34;
        return self.getboolean(&#39;general&#39;, &#39;ssl_verify&#39;)

    @property
    def output(self):
        &#34;&#34;&#34;ConfigParser.get(&#39;general&#39;, &#39;output&#39;)&#34;&#34;&#34;
        return self.get(&#39;general&#39;, &#39;output&#39;)

   
    @staticmethod
    def _find_ini_location():
        &#39;&#39;&#39;
        Returns the location of a supposed conf.ini file the conf.ini file,
        If the file doesn&#39;t exist, will still return the location.
        Do not create a files not directory.
        If a .msiem/ directory exists in pwd, will return &#39;./.msiem/conf.ini&#39;
        Or  For Windows:  %APPDATA%\\Roaming\\
            For Mac :     $HOME/
            For Linux :   $XDG_CONFIG_HOME/
                or :   $HOME/
        If your system doesn&#39;t have any of the above environment varibles,
            will return &#39;./.msiem/conf.ini&#39;
        &#39;&#39;&#39;
        conf_path_dir=None

        if os.path.isdir(&#39;./&#39;+NitroConfig.CONF_DIR):
            conf_path_dir=&#39;./&#39;

        elif &#39;APPDATA&#39; in os.environ:
                conf_path_dir = os.environ[&#39;APPDATA&#39;]

        elif &#39;XDG_CONFIG_HOME&#39; in os.environ:  
            conf_path_dir = os.environ[&#39;XDG_CONFIG_HOME&#39;]

        elif &#39;HOME&#39; in os.environ:  
            conf_path_dir = os.path.join(os.environ[&#39;HOME&#39;])
            
        else:
            conf_path_dir=&#39;./&#39;
        
        #Join configuartion filename with supposed parent directory
        conf_path=(os.path.join(conf_path_dir, NitroConfig.CONFIG_FILE_NAME))

        return(conf_path)

class NitroSession():
    &#39;&#39;&#39;NitroSession object represent the point of convergence of every request to the McFee ESM
    It provides standard dialogue with the esm with agument interpolation with `msiempy.params`.
    Internal `__dict__` refers to a unique instance of dict and thus, properties can be instanciated only once.
    Credentials and other configurations are read from a ./.msiem/conf.ini file.
    If the ./msiem directory desn&#39;t exists in your current directory, will assume the file is your home directory
        as ~/.msiem/conf.ini or %appdata%\\Roaming\\.msiem\\conf.ini.
    Use NitroSession.config.read() - ConfigParser object - to read a new configuration file. 
    &#39;&#39;&#39;

    BASE_URL = &#39;https://{}/rs/esm/&#39;
    &#34;&#34;&#34;API v2 base url.
    &#34;&#34;&#34;

    BASE_URL_PRIV = &#39;https://{}/ess/&#39;
    &#34;&#34;&#34;Private API base URL.
    &#34;&#34;&#34;

    __initiated__ = False
    &#34;&#34;&#34;
    Weither the session has been intaciated. It&#39;s supposed to be a singleton.
    &#34;&#34;&#34;
    __unique_state__ = {}
    &#34;&#34;&#34;
    The singleton unique state.
    &#34;&#34;&#34;
    
    config = None
    &#34;&#34;&#34;
    NitroConfig object.
    &#34;&#34;&#34;
    
    executor = None
    &#34;&#34;&#34;
    Executor object.
    &#34;&#34;&#34;
        
    def __str__(self):
        &#34;&#34;&#34;
    &#34;&#34;&#34;
        return repr(self.__unique_state__) 

    def __init__(self, conf_path=None, conf_dict=None):
        &#34;&#34;&#34;
        The init method is called every time you call NitroSession() constructor.
        But the properties are actually initiated only once.
        Use logout() to trash the obejct and re instanciate NitroSession.

            Parameters

            conf_path : Configuration file path can be passed as conf_path attr.
            conf_dict : attr ie : {&#39;esm&#39;:{&#39;host&#39;:&#39;myhost.com&#39;,&#39;user&#39;:&#39;username&#39;,&#39;passwd&#39;:&#39;&#39;}...}.
            See `msiempy.NitroConfig` class to have full details.
        &#34;&#34;&#34;
        global log
        self.__dict__ = NitroSession.__unique_state__
        
        #Init properties only once
        if not self.__initiated__ :
            NitroSession.__initiated__ = True
            log.info(&#39;New NitroSession instance&#39;)
            
            #Private attributes
            self._headers={&#39;Content-Type&#39;: &#39;application/json&#39;}
            self._logged=False
            
            #Config parsing
            self.config = NitroConfig(path=conf_path, config=conf_dict)
            NitroSession.config=self.config

            #Set the logging configuration
            self._init_log(verbose=self.config.verbose,
                quiet=self.config.quiet,
                logfile=self.config.logfile)

    def _request(self, method, http, data=None, callback=None, raw=False, secure=False):
        &#34;&#34;&#34;
        Helper method that format the request, handle the basic parsing of the SIEM result 
        as well as other errors.        
        If method is all upper cases, it&#39;s a private API call.
        Private API is under /ess/ and public api is under /rs/esm
        Returns None if HTTP error, Timeout or TooManyRedirects if raw=False
        &#34;&#34;&#34;

        url=str()
        privateApiCall=False
        result=None

        #Handling private API calls formatting
        if method == method.upper():
            privateApiCall=True
            url = self.BASE_URL_PRIV
            data = self._format_params(method, **data)
            log.debug(&#39;Private API call : &#39;+str(method)+&#39; Formatted params : &#39;+str(data))
        
        #Normal API calls
        else:
            url = self.BASE_URL
            if data:
                data = json.dumps(data)

        #Logging the data request if not secure | Logs anyway the method
        log.debug(&#39;Requesting HTTP &#39;+http+&#39; &#39;+ method + 
            (&#39; with data &#39;+str(data) if (data is not None and not secure) else &#39;&#39;) )

        try :
            result = requests.request(
                http,
                urllib.parse.urljoin(url.format(self.config.host), method),
                data=data, 
                headers=self._headers,
                verify=self.config.ssl_verify,
                timeout=self.config.timeout
            )

            if raw :
                log.debug(&#39;Returning raw requests Response object :&#39;+str(result))
                return result

            else:
                try:
                    result.raise_for_status()

                except requests.HTTPError as e :
                    log.error(str(e)+&#39; &#39;+str(result.text))
                    return result.text
                    #TODO handle expired session error, result unavailable / other siem errors
                    # ERROR_InvalidFilter (228)
                    # Status Code 500: Error processing request, see server logs for more details 
                    # &lt;Response [400]&gt;
                    # Input Validation Error
                    # By creating a new class

                else: #
                    result = self._unpack_resp(result)

                    if privateApiCall :
                        result = self._format_priv_resp(result)

                    if callback:
                        result = callback(result)

                    log.debug(&#39;Result &#39;+str(result)[:100]+&#39;[...]&#39;)

                    return result

        #Soft errors
        except requests.exceptions.Timeout as e:
            log.error(e)
            return None
        except requests.exceptions.TooManyRedirects as e :
            log.error(e)
            return None
        
    def _login(self):
        &#34;&#34;&#34;
        Internal method that will be called when the user is not logged yet.
        Throws NitroError if login fails
        &#34;&#34;&#34;
        userb64 = tob64(self.config.user)
        passb64 = self.config.passwd
        
        resp = self.request(&#39;login&#39;, username=userb64, password=passb64, raw=True, secure=True)
        
        if resp is not None :
            if resp.status_code in [400, 401]:
                raise NitroError(&#39;Invalid username or password for the ESM&#39;)
            elif 402 &lt;= resp.status_code &lt;= 600:
                raise NitroError(&#39;ESM Login Error:&#39;, resp.text)
       
            self._headers[&#39;Cookie&#39;] = resp.headers.get(&#39;Set-Cookie&#39;)
            self._headers[&#39;X-Xsrf-Token&#39;] = resp.headers.get(&#39;Xsrf-Token&#39;)
    
            return True
        else:
            raise NitroError(&#39;ESM Login Error: Response empty&#39;)

    def request(self, request, http=&#39;post&#39;, callback=None, raw=False, secure=False, **params):
        &#34;&#34;&#34;
            This method is the centralized interface of all request coming to the SIEM.

                Parameters

                request :   keyword corresponding to the request name in `msiempy.params` mapping.
                http :      http method.
                callback :  a callable to execute on the returned object if needed.
                raw :       if true will return the Response object from requests module.
                secure :    if true will not log the content of the request.
                **params :  interpolation parameters that will be match to `msiempy.params` templates. Check the file to be sure of the keyword arguments.

            Returns None if HTTP error, Timeout or TooManyRedirects if raw=False
        &#34;&#34;&#34;
        log.debug(&#34;Calling nitro request : {} params={} http={} raw={} secure={} callback={}&#34;.format(
            str(request), str(params) if not secure else &#39;***&#39;, str(http), str(raw), str(secure), str(callback)
        ))

        method, data = PARAMS.get(request)

        if data is not None :
            data =  data % params
            data = ast.literal_eval((data.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\t&#39;,&#39;&#39;)))
           
        if method is not None:
            try :
                method = method % params
            except TypeError as err :
                if (&#39;must be real number, not dict&#39; in str(err)):
                    log.warning(&#34;Interpolation failed probably because of the private API calls formatting... Unexpected behaviours can happend.&#34;)

        if not self._logged and method != &#39;login&#39;:
            self._logged=self._login()

        try :
            return self._request(method, http, data, callback, raw, secure)

        except ConnectionError as e:
            log.critical(e)
            raise
        except Exception as e:
            log.error(e)
            raise 
        
    def logout(self):
        &#34;&#34;&#34; 
        This method will logout the session, clear headers and throw away the object,
            a new session will be instanciated next time.
        &#34;&#34;&#34;
        self.request(&#39;logout&#39;, http=&#39;delete&#39;)
        self._logged=False
        NitroSession.__initiated__ = False

    @staticmethod
    def _init_log(verbose=False, quiet=False, logfile=None):
        &#34;&#34;&#34;
        Private method. Inits the session&#39;s logger settings based on params
        All objects should be able to log stuff, so the logger is globaly accessible
        &#34;&#34;&#34;

        log.setLevel(logging.DEBUG)

        formatter = logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(message)s&#39;)

        std = logging.StreamHandler()
        std.setLevel(logging.DEBUG)
        std.setFormatter(formatter)

        if verbose :
            std.setLevel(logging.DEBUG)
        elif quiet :
            std.setLevel(logging.CRITICAL)
        else :
            std.setLevel(logging.INFO)

        
            
            
        log.handlers=[]
        
        log.addHandler(std)

        if logfile :
            fh = logging.FileHandler(logfile)
            fh.setLevel(logging.DEBUG)
            fh.setFormatter(logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(message)s&#39;))
            log.addHandler(fh)

        if verbose and quiet :
            log.warning(&#34;Verbose and quiet values are both set to True. This is a very inconsistent state. By default, verbose value has priority.&#34;)

        return (log)
    

    @staticmethod
    def _format_params(cmd, **params):
        &#34;&#34;&#34;
        Format private API call.
        From mfe_saw project at https://github.com/andywalden/mfe_saw
        &#34;&#34;&#34;
        params = {k: v for k, v in params.items() if v is not None}
        params = &#39;%14&#39;.join([k + &#39;%13&#39; + v + &#39;%13&#39; for (k, v) in params.items()])
        
        if params:
            params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39; + params + &#39;%14&#39;
        else:
            params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39;
        return params

    @staticmethod
    def _format_priv_resp(resp):
        &#34;&#34;&#34;
        Format response from private API
        From mfe_saw project at https://github.com/andywalden/mfe_saw
        &#34;&#34;&#34;
        resp = re.search(&#39;Response=(.*)&#39;, resp).group(1)
        resp = resp.replace(&#39;%14&#39;, &#39; &#39;)
        pairs = resp.split()
        formatted = {}
        for pair in pairs:
            pair = pair.replace(&#39;%13&#39;, &#39; &#39;)
            pair = pair.split()
            key = pair[0]
            if key == &#39;ITEMS&#39;:
                value = pair[-1]
            else:
                value = urllib.parse.unquote(pair[-1])
            formatted[key] = value
        return formatted

    @staticmethod
    def _unpack_resp(response) :
        &#34;&#34;&#34;Unpack data from response.
        Args: 
            response: requests.Response response object
        Returns a list, a dict or a string
        &#34;&#34;&#34;
        try :
            data = response.json()
            if isinstance(response.json(), dict):
                try:
                    data = data[&#39;value&#39;]
                except KeyError:
                    try:
                        data = data[&#39;return&#39;]
                    except KeyError:
                        pass
            
        except json.decoder.JSONDecodeError:
            data = response.text

        return data

class NitroObject(abc.ABC):
    &#34;&#34;&#34;
    Base class for all nitro objects. All objects have a reference to the single `msiempy.NitroSession` object that handle the esm requests.
    &#34;&#34;&#34;

    class NitroJSONEncoder(json.JSONEncoder):
        &#34;&#34;&#34;
        Custom JSON encoder that will use the approprtiate propertie depending of the type of NitroObject.
        TODO return meta info about the NitroList. Maybe create a section `manager` and `data`.
        TODO support json json dumping of QueryFilers, may be by making them inherits from NitroDict.
        &#34;&#34;&#34;
        def default(self, obj): # pylint: disable=E0202
            if isinstance(obj,(NitroDict, NitroList)):
                return obj.data
            #elif isinstance(obj, (QueryFilter)):
                #return obj.config_dict
            else:
                return json.JSONEncoder.default(self, obj) 

    @abc.abstractmethod
    def __init__(self):
        &#34;&#34;&#34;Creates the object session.
        &#34;&#34;&#34;
        self.nitro=NitroSession()

    def __str__(self):
        &#34;&#34;&#34;
        str(obj) -&gt; return text string.
        Can be a table if the object is a NitroList.
        &#34;&#34;&#34;
        return self.text

    def __repr__(self):
        &#34;&#34;&#34;
        repr(obj) -&gt; return json string.
        &#34;&#34;&#34;
        return self.json

    @abc.abstractproperty
    def text(self):
        &#34;&#34;&#34;
        Returns printable string.
        &#34;&#34;&#34;
        pass

    @abc.abstractproperty
    def json(self):
        &#34;&#34;&#34;
        Returns json string representation.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def refresh(self):
        &#34;&#34;&#34;
        Refresh the state of the object.
        &#34;&#34;&#34;
        pass

class NitroDict(collections.UserDict, NitroObject):
    &#34;&#34;&#34;
    Base class that represent any SIEM data that can be represented as a item of a list.
    Exemple : Event, Alarm, etc...
    Inherits from dict.
    &#34;&#34;&#34;
    def __init__(self, adict=None, id=None):
        &#34;&#34;&#34;
        Initiate the NitroObject and UserDict objects, load the data if id is specified, use adict agument 
        and update dict values accordingly.

            Parameters

            adict : dict object to wrap.
            id : ESM obejct unique identifier. Alert.IPSIDAlertID for exemple. 
        &#34;&#34;&#34;
        NitroObject.__init__(self)
        collections.UserDict.__init__(self, adict)
        
        if id != None :
            self.data=self.data_from_id(id)

        if isinstance(adict, dict):
            self.data=adict

        for key in self.data :
            if isinstance(self.data[key], list):
                self.data[key]=NitroList(alist=self.data[key])

    @property
    def json(self):
        &#34;&#34;&#34;JSON representation of a item. Basic dict.
        &#34;&#34;&#34;
        return(json.dumps(dict(self), indent=4, cls=NitroObject.NitroJSONEncoder))

    @property
    def text(self):
        &#34;&#34;&#34;A list of values. Not titles.
        &#34;&#34;&#34;
        return(&#39;, &#39;.join([str(val) for val in self.values()]))

    def refresh(self):
        &#34;&#34;&#34;Not implemented here
        &#34;&#34;&#34;
        log.debug(&#39;NOT Refreshing item :&#39;+str(self)+&#39; &#39;+str(NotImplementedError()))

    @abc.abstractmethod
    def data_from_id(self, id):
        &#34;&#34;&#34;This method figured out the way to retreive the item infos from an id.
        &#34;&#34;&#34;
        pass

class NitroList(collections.UserList, NitroObject):
    &#34;&#34;&#34;
    Base class for NitroList objects. It offers callable execution management, searcb and other data list actions.
    &#34;&#34;&#34;

    def __init__(self, alist=None):
        &#34;&#34;&#34;
            Parameters

            alist : list object to wrap.
        &#34;&#34;&#34;
        NitroObject.__init__(self)
        if alist is None:
            collections.UserList.__init__(self, [])
        
        elif isinstance(alist , (list, NitroList)):
            collections.UserList.__init__(
                self, alist #[NitroDict(adict=item) for item in alist if isinstance(item, (dict, NitroDict))] 
                #Can&#39;t instanciate NitroDict, so Concrete classes has to cast the items afterwards
                )
        else :
            raise ValueError(&#39;NitroList can only be initiated based on a list&#39;)

    @property
    def table_colums(self):
        &#34;&#34;&#34;Return the list of columns the table representation will have. This attribute is designed to overwritten.
        &#34;&#34;&#34;            
        return []

    def _norm_dicts(self):
        &#34;&#34;&#34;
        Internal method.
        All dict should have the same set of keys.
        Creating keys in dicts.
        &#34;&#34;&#34;
        for item in self.data :
            if isinstance(item, (dict, NitroDict)):
                for key in self.keys :
                    if key not in item :
                        item[key]=None

    @property
    def keys(self):
        &#34;&#34;&#34;Set of keys for all dict
        &#34;&#34;&#34;
        #If new fields are added it won&#39;t show on text repr. Only json.
        
        manager_keys=set()
        for item in self.data:
            if isinstance(item, (dict,NitroDict)):
                manager_keys.update(item.keys())

        return manager_keys


    def get_text(self, compact=False, fields=None, max_column_width=120):
        &#34;&#34;&#34;
        Return a acsii table string representation of the manager list

            Parameters

            compact : Returns a nice string table made with prettytable, else an &#39;|&#39; separated list.
            fields : list of fields you want in the table
                is None : default fields are returned by .keys attribute and sorted.
            max_column_width : when using prettytable (not compact)

        It&#39;s an expesive thing to do on big ammount of data !
        &#34;&#34;&#34;
        
        if not fields :
            fields=sorted(self.keys)

        if len(self) == 0 :
            return(&#39;The list is empty&#39;)

        if not compact : #Table
            table = prettytable.PrettyTable()
            table.set_style(MSWORD_FRIENDLY)
            table.field_names=fields
            self._norm_dicts()

            for item in self.data:
                if isinstance(item, (dict, NitroDict)):
                    table.add_row([&#39;\n&#39;.join(textwrap.wrap(str(item[field]), width=max_column_width))
                        if not isinstance(item[field], NitroList)
                        else item[field].get_text() for field in fields])
                else : log.warning(&#34;Unnapropriate list element type, doesn&#39;t show on the list : {}&#34;.format(str(item)))

            if len(self.table_colums) &gt;0 :
                try :
                    text =table.get_string(fields=self.table_colums)
                except Exception as err :
                    if &#34;Invalid field name&#34; in str(err):
                        text=table.get_string()
                        log.warning(&#34;Inconsistent manager state, some fields aren&#39;t present {}&#34;.format(str(err)))
                    else :
                        raise
            else: 
                text=table.get_string()

        elif compact is True :
            text=&#39;|_&#39;
            for field in fields :
                text+=field
                text+=&#39;_|_&#39;
            text=text[0:len(text)-1]
            text+=&#39;\n&#39;
            for item in self.data:
                if isinstance(item, (dict, NitroDict)):
                    text+=&#39;| &#39;
                    for field in fields :
                        if isinstance(item[field], NitroList):
                            text+=item[field].get_text(compact=True)
                        else:
                            text+=(str(item[field]))
                            text+=&#39; | &#39;
                    text=text[0:len(text)-1]
                else : log.warning(&#34;Unnapropriate list element type, doesn&#39;t show on the list : {}&#34;.format(str(item)))
                    #text+=textwrap.wrap(str(item),width=max_column_width)
                text+=&#39;\n&#39;
            text=text[0:len(text)-1]
        return text



    @property
    def text(self):
        &#34;&#34;&#34;The text properti is a shorcut to get_text() with no arguments.
        &#34;&#34;&#34;
        return self.get_text()
        
    @property
    def json(self):
        &#34;&#34;&#34;Dumps a JSON list of dicts representing the current list.
        &#34;&#34;&#34;
        return(json.dumps([dict(item) for item in self.data], indent=4, cls=NitroObject.NitroJSONEncoder))

    def search(self, invert=False, match_prop=&#39;json&#39;, *pattern):
        &#34;&#34;&#34;
        Return a list of elements that matches one or more regex patterns.
        Patterns are applied one after another. It&#39;s a logic AND.
        Use `|` inside patterns to search with logic OR.
        This method will return a new NitroList with matching data. NitroDicts in the returned NitroList do not
        references the items in the original NitroList.

            Parameters
            
            *pattern : List or string regex patterns to look for.
            invert : Weither or not to invert the search and return elements that doesn&#39;t not match search.
            match_prop : Propertie that is going to be called to search. Could be `text` or `json`.


        If you wish to apply more specific filters to NitroList list, please
        use filter(), list comprehension, or other filtering method.
            i.e. : `[item for item in list if item[&#39;cost&#39;] &gt; 50]`

        More on regex https://docs.python.org/3/library/re.html#re.Pattern.search
        &#34;&#34;&#34;
        if pattern is None :
            return self
        elif len(pattern) == 0 :
            return self
        else :
            pattern=list(pattern)
            apattern=pattern.pop()
        
        matching_items=list()
        
        if isinstance(apattern, str):
            for item in self.data :
                if regex_match(apattern, getattr(item, match_prop) if isinstance(item, NitroDict) else str(item)) is not invert :
                    matching_items.append(item)
            log.debug(&#34;You&#39;re search returned {} rows : {}&#34;.format(
                len(matching_items),
                str(matching_items)[:100]+&#39;...&#39;))
            #Apply AND reccursively
            return NitroList(alist=matching_items).search(*pattern, invert=invert, match_prop=match_prop)
        else:
            raise ValueError(&#39;pattern must be str&#39;)

    def refresh(self):
        &#34;&#34;&#34;
        Execute refresh function on all items.
        &#34;&#34;&#34;
        log.warning(&#34;The function NitroList.refresh hasn&#39;t been correctly tested&#34;)
        self.perform(NitroDict.refresh)

    def perform(self, func, data=None, func_args=None, confirm=False, asynch=False,  workers=None , progress=False, message=None):
        &#34;&#34;&#34;
        Wrapper arround executable and the data list of `msiempy.NitroList` object.
        Will execute the callable the list.

            Parameters
            
            func : callable stateless function. func is going to be called like func(item, **func_args) on all items in data.
            data : if stays None, will perform the action on all rows, else it will perfom the action on the data list.
            func_args : dict that will be passed by default to func in all calls.
            confirm : will ask interactively confirmation.
            asynch : execute the task asynchronously with `msiempy.NitroSession` executor.
            workers : mandatory if asynch is true.
            progress : to show progress bar with ETA (tqdm).
            message : To show to the user.

        Returns a list of returned results
        &#34;&#34;&#34;

        log.debug(&#39;Calling perform func=&#39;+str(func)+
            &#39; data=&#39;+str(data)[:100]+
            &#39; func_args=&#39;+str(func_args)+
            &#39; confirm=&#39;+str(confirm)+
            &#39; asynch=&#39;+str(asynch)+
            &#39; workers=&#39;+str(workers)+
            &#39; progress=&#39;+str(progress)+
            &#39; message=&#39;+str(message))

        if not callable(func) :
            raise ValueError(&#39;func must be callable&#39;)

        #Confirming with user if asked
        if confirm : self._confirm_func(func, str(self))

        #Setting the arguments on the function
        func = functools.partial(func, **(func_args if func_args is not None else {}))
        
        #The data returned by function
        returned=list()

        #Usethe self contained data if not speficed otherwise
        elements=self.data
        if isinstance(data, list) and data is not None:
            elements=data
        else :
            AttributeError(&#39;data must be a list&#39;)

        #Printing message if specified.
        tqdm_args=dict()
        #The message will appear on loading bar if progress is True
        if progress is True :
            tqdm_args=dict(desc=&#39;Loading...&#39;, total=len(elements))
            if message is not None:
                tqdm_args[&#39;desc&#39;]=message

        

        #Runs the callable on list on executor or by iterating
        if asynch == True :
            if isinstance(workers, int) :
                if progress==True :
                    if not self.nitro.config.quiet:
                        #Need to call tqdm to have better support for concurrent futures executor
                        # tqdm would load the whole bar intantaneously and not wait until the callable func returns. 
                        returned=list(tqdm.tqdm(concurrent.futures.ThreadPoolExecutor(
                        max_workers=workers ).map(
                            func, elements), **tqdm_args))
                    else:
                        log.warning(&#34;You requested to show perfrom progress but config&#39;s quiet value is True, not showing tqdm load bar.&#34;)
                        returned=list(concurrent.futures.ThreadPoolExecutor(
                        max_workers=workers ).map(
                            func, elements))
                else:
                    returned=list(concurrent.futures.ThreadPoolExecutor(
                    max_workers=workers ).map(
                        func, elements))
            else:
                raise AttributeError(&#39;When asynch == True : You must specify a integer value for workers&#39;)
        else :

            if progress==True:
                if not self.nitro.config.quiet:
                    elements=tqdm.tqdm(elements, **tqdm_args)
                else:
                    log.warning(&#34;You requested to show perform progress but config&#39;s quiet value is True, not showing tqdm load bar.&#34;)

            for index_or_item in elements:
                returned.append(func(index_or_item))

        return(returned)

    @staticmethod
    def _confirm_func(func, elements):
        &#34;&#34;&#34;
        Ask user inut to confirm the calling of `func` on `elements`.
        &#34;&#34;&#34;
        if not &#39;y&#39; in input(&#39;Are you sure you want to do this &#39;+str(func)+&#39; on &#39;+
        (&#39;\n&#39;+str(elements) if elements is not None else &#39;all elements&#39;)+&#39;? [y/n]: &#39;):
            raise InterruptedError(&#34;The action was cancelled by the user.&#34;)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="msiempy.alarm" href="alarm.html">msiempy.alarm</a></code></dt>
<dd>
<section class="desc"><p>Provide alarm management.</p></section>
</dd>
<dt><code class="name"><a title="msiempy.device" href="device.html">msiempy.device</a></code></dt>
<dd>
<section class="desc"><p>Provide ESM, ERC and data source management.</p></section>
</dd>
<dt><code class="name"><a title="msiempy.event" href="event.html">msiempy.event</a></code></dt>
<dd>
<section class="desc"><p>Provide event management.</p></section>
</dd>
<dt><code class="name"><a title="msiempy.params" href="params.html">msiempy.params</a></code></dt>
<dd>
<section class="desc"><p>This module imports a dict into the msiem core class to provide
a central place to aggregate API methods and parameters. The params
are stored as â€¦</p></section>
</dd>
<dt><code class="name"><a title="msiempy.query" href="query.html">msiempy.query</a></code></dt>
<dd>
<section class="desc"><p>Provide time ranged filtered query wrapper.</p></section>
</dd>
<dt><code class="name"><a title="msiempy.utils" href="utils.html">msiempy.utils</a></code></dt>
<dd>
<section class="desc"><p>A few quick static util methods.</p></section>
</dd>
<dt><code class="name"><a title="msiempy.watchlist" href="watchlist.html">msiempy.watchlist</a></code></dt>
<dd>
<section class="desc"><p>Provide whatchlist management.</p></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="msiempy.NitroConfig"><code class="flex name class">
<span>class <span class="ident">NitroConfig</span></span>
<span>(</span><span>path=None, config=None, *arg, **kwarg)</span>
</code></dt>
<dd>
<section class="desc"><p>Class that handles the configuration. Reads the config file where ever it is and make accessible it's values throught object properties.
If a <code>.msiem/</code> directory exists in your current directory, the program will assume the <code>conf.ini</code> file is there, if not, it will create it with default values.
Secondly, if no <code>.msiem/</code> directory exists in the current directory, it will be automatically placed in a appropriate place depending of your platform:<br>
- For Windows:
%APPDATA%\<br>
- For Mac :
$HOME/<br>
- For Linux :
$XDG_CONFIG_HOME/ or : $HOME/</p>
<p>Initiate a config object.
</p>
<p>Parameters:
</p>
<ul>
<li>path: Config file speciale path, if path is left None, will automatically look for it.
</li>
<li>config: Manual config dict. ex: <code>{'general':{'verbose':True}}</code>
</li>
<li><em>args, </em>*kwargs : Passed to configparser.ConfigParser <strong>init</strong>()</li>
</ul></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NitroConfig(configparser.ConfigParser):
    &#34;&#34;&#34;Class that handles the configuration. Reads the config file where ever it is and make accessible it&#39;s values throught object properties. 
    If a `.msiem/` directory exists in your current directory, the program will assume the `conf.ini` file is there, if not, it will create it with default values. 
    Secondly, if no `.msiem/` directory exists in the current directory, it will be automatically placed in a appropriate place depending of your platform:  
    - For Windows:  %APPDATA%\\  
    - For Mac :     $HOME/  
    - For Linux :   $XDG_CONFIG_HOME/ or : $HOME/
    &#34;&#34;&#34;

    CONFIG_FILE_NAME=&#39;.msiem/conf.ini&#39;
    &#34;&#34;&#34;`.msiem/conf.ini`&#34;&#34;&#34;

    CONF_DIR=&#39;.msiem/&#39;
    &#34;&#34;&#34;`.msiem/`&#34;&#34;&#34;

    DEFAULT_CONF_DICT={
        &#39;esm&#39;:{&#39;host&#39;:&#39;&#39;, 
            &#39;user&#39;:&#39;&#39;,
            &#39;passwd&#39;:&#39;&#39;},
        &#39;general&#39;:{&#39;verbose&#39;:False,
            &#39;quiet&#39;:False,
            &#39;logfile&#39;:&#39;&#39;,
            &#39;timeout&#39;:30,
            &#39;ssl_verify&#39;:False,
            &#39;output&#39;:&#39;text&#39;}
    }
    &#34;&#34;&#34;
    Default configuration file should look like this. Authentication is left empty.
    ```
    [esm]
    host = 
    user = 
    passwd = 

    [general]
    verbose = False
    quiet = False
    logfile = 
    timeout = 30
    ssl_verify = False
    output = text #Not used yet
    ```
    &#34;&#34;&#34;

    def __str__(self):
        &#34;&#34;&#34;Custom str() method that lists all config fields.
        &#34;&#34;&#34;
        return(&#39;Configuration file : &#39;+ self._path+&#39;\n&#39;+str({section: dict(self[section]) for section in self.sections()}))

    def __init__(self, path=None, config=None, *arg, **kwarg):
        &#34;&#34;&#34;
        Initiate a config object.  

        Parameters:  

        - path: Config file speciale path, if path is left None, will automatically look for it.  
        - config: Manual config dict. ex: ```{&#39;general&#39;:{&#39;verbose&#39;:True}}```  
        - *args, **kwargs : Passed to configparser.ConfigParser __init__()
        &#34;&#34;&#34;

        super().__init__(*arg, **kwarg)

        self.read_dict(self.DEFAULT_CONF_DICT)
    
        if not path :
            self._path = self._find_ini_location()
        else : 
            self._path = path

        try :
            files=self.read(self._path)
            if len(files) == 0:
                raise FileNotFoundError

        except :
            log.info(&#34;Config file inexistant or currupted, applying defaults&#34;)

            if not os.path.exists(os.path.dirname(self._path)):
                os.makedirs(os.path.dirname(self._path))
            self.write()

        if config is not None :
            log.info(&#34;Reading config_dict : &#34;+str(self))
            self.read_dict(config)

    def write(self):
        &#34;&#34;&#34;
        Write the config file.
        &#34;&#34;&#34;
        log.info(&#34;Write config file at &#34;+self._path)
        with open(self._path, &#39;w&#39;) as conf:
            super().write(conf)

    def _iset(self, section, option, secure=False):
        &#34;&#34;&#34;Internal method to interactively set  a option in a section.
        &#34;&#34;&#34;
        msg=&#39;Enter [{}]{}&#39;
        value = self.get(section, option)
        newvalue=&#39;&#39;
        if option==&#39;passwd&#39;:
            secure=True
        if secure :
            newvalue = tob64(getpass.getpass(msg.format(section, option)+&#39;. Press &lt;Enter&gt; to skip: &#39;))
        else:
            newvalue = input(msg.format(section, option)+ &#39;. Press &lt;Enter&gt; to keep &#39;+ (value if (str(value) is not &#39;&#39;) else &#39;empty&#39;) + &#39;: &#39;)
        if newvalue != &#39;&#39; :
            super().set(section, option, newvalue)

    def iset(self, section, option=None, secure=False):
        &#34;&#34;&#34;
        Will interactively set the specified section/optionby asking the user the input.
        If option stays None, all section&#39;s option will be interactively set.
        &#34;&#34;&#34;
        if option is None :
            for key in self.options(section):
                self._iset(section, key, secure)
        else :
            self._iset(section, option, secure)

    @property
    def user(self):
        &#34;&#34;&#34;ConfigParser.get(&#39;esm&#39;, &#39;user&#39;)&#34;&#34;&#34;
        return self.get(&#39;esm&#39;, &#39;user&#39;)

    @property
    def host(self):
        &#34;&#34;&#34;ConfigParser.get(&#39;esm&#39;, &#39;host&#39;)&#34;&#34;&#34;
        return self.get(&#39;esm&#39;, &#39;host&#39;)

    @property
    def passwd(self):
        &#34;&#34;&#34;ConfigParser.get(&#39;esm&#39;, &#39;passwd&#39;)&#34;&#34;&#34;
        return self.get(&#39;esm&#39;, &#39;passwd&#39;)

    @property
    def verbose(self):
        &#34;&#34;&#34;ConfigParser.getboolean(&#39;general&#39;, &#39;verbose&#39;)&#34;&#34;&#34;
        return self.getboolean(&#39;general&#39;, &#39;verbose&#39;)

    @property
    def quiet(self):
        &#34;&#34;&#34;ConfigParser.getboolean(&#39;general&#39;, &#39;quiet&#39;)&#34;&#34;&#34;
        return self.getboolean(&#39;general&#39;, &#39;quiet&#39;)

    @property
    def logfile(self):
        &#34;&#34;&#34;ConfigParser.get(&#39;general&#39;, &#39;logfile&#39;)&#34;&#34;&#34;
        return self.get(&#39;general&#39;, &#39;logfile&#39;)

    @property
    def timeout(self):
        &#34;&#34;&#34;ConfigParser.getint(&#39;general&#39;, &#39;timeout&#39;)&#34;&#34;&#34;
        return self.getint(&#39;general&#39;, &#39;timeout&#39;)

    @property
    def ssl_verify(self):
        &#34;&#34;&#34;ConfigParser.getboolean(&#39;general&#39;, &#39;ssl_verify&#39;)&#34;&#34;&#34;
        return self.getboolean(&#39;general&#39;, &#39;ssl_verify&#39;)

    @property
    def output(self):
        &#34;&#34;&#34;ConfigParser.get(&#39;general&#39;, &#39;output&#39;)&#34;&#34;&#34;
        return self.get(&#39;general&#39;, &#39;output&#39;)

   
    @staticmethod
    def _find_ini_location():
        &#39;&#39;&#39;
        Returns the location of a supposed conf.ini file the conf.ini file,
        If the file doesn&#39;t exist, will still return the location.
        Do not create a files not directory.
        If a .msiem/ directory exists in pwd, will return &#39;./.msiem/conf.ini&#39;
        Or  For Windows:  %APPDATA%\\Roaming\\
            For Mac :     $HOME/
            For Linux :   $XDG_CONFIG_HOME/
                or :   $HOME/
        If your system doesn&#39;t have any of the above environment varibles,
            will return &#39;./.msiem/conf.ini&#39;
        &#39;&#39;&#39;
        conf_path_dir=None

        if os.path.isdir(&#39;./&#39;+NitroConfig.CONF_DIR):
            conf_path_dir=&#39;./&#39;

        elif &#39;APPDATA&#39; in os.environ:
                conf_path_dir = os.environ[&#39;APPDATA&#39;]

        elif &#39;XDG_CONFIG_HOME&#39; in os.environ:  
            conf_path_dir = os.environ[&#39;XDG_CONFIG_HOME&#39;]

        elif &#39;HOME&#39; in os.environ:  
            conf_path_dir = os.path.join(os.environ[&#39;HOME&#39;])
            
        else:
            conf_path_dir=&#39;./&#39;
        
        #Join configuartion filename with supposed parent directory
        conf_path=(os.path.join(conf_path_dir, NitroConfig.CONFIG_FILE_NAME))

        return(conf_path)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>configparser.ConfigParser</li>
<li>configparser.RawConfigParser</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.NitroConfig.CONFIG_FILE_NAME"><code class="name">var <span class="ident">CONFIG_FILE_NAME</span></code></dt>
<dd>
<section class="desc"><p><code>.msiem/conf.ini</code></p></section>
</dd>
<dt id="msiempy.NitroConfig.CONF_DIR"><code class="name">var <span class="ident">CONF_DIR</span></code></dt>
<dd>
<section class="desc"><p><code>.msiem/</code></p></section>
</dd>
<dt id="msiempy.NitroConfig.DEFAULT_CONF_DICT"><code class="name">var <span class="ident">DEFAULT_CONF_DICT</span></code></dt>
<dd>
<section class="desc"><p>Default configuration file should look like this. Authentication is left empty.</p>
<pre><code>[esm]
host = 
user = 
passwd = 

[general]
verbose = False
quiet = False
logfile = 
timeout = 30
ssl_verify = False
output = text #Not used yet
</code></pre></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.NitroConfig.host"><code class="name">var <span class="ident">host</span></code></dt>
<dd>
<section class="desc"><p>ConfigParser.get('esm', 'host')</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def host(self):
    &#34;&#34;&#34;ConfigParser.get(&#39;esm&#39;, &#39;host&#39;)&#34;&#34;&#34;
    return self.get(&#39;esm&#39;, &#39;host&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.logfile"><code class="name">var <span class="ident">logfile</span></code></dt>
<dd>
<section class="desc"><p>ConfigParser.get('general', 'logfile')</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def logfile(self):
    &#34;&#34;&#34;ConfigParser.get(&#39;general&#39;, &#39;logfile&#39;)&#34;&#34;&#34;
    return self.get(&#39;general&#39;, &#39;logfile&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.output"><code class="name">var <span class="ident">output</span></code></dt>
<dd>
<section class="desc"><p>ConfigParser.get('general', 'output')</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def output(self):
    &#34;&#34;&#34;ConfigParser.get(&#39;general&#39;, &#39;output&#39;)&#34;&#34;&#34;
    return self.get(&#39;general&#39;, &#39;output&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.passwd"><code class="name">var <span class="ident">passwd</span></code></dt>
<dd>
<section class="desc"><p>ConfigParser.get('esm', 'passwd')</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def passwd(self):
    &#34;&#34;&#34;ConfigParser.get(&#39;esm&#39;, &#39;passwd&#39;)&#34;&#34;&#34;
    return self.get(&#39;esm&#39;, &#39;passwd&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.quiet"><code class="name">var <span class="ident">quiet</span></code></dt>
<dd>
<section class="desc"><p>ConfigParser.getboolean('general', 'quiet')</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def quiet(self):
    &#34;&#34;&#34;ConfigParser.getboolean(&#39;general&#39;, &#39;quiet&#39;)&#34;&#34;&#34;
    return self.getboolean(&#39;general&#39;, &#39;quiet&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.ssl_verify"><code class="name">var <span class="ident">ssl_verify</span></code></dt>
<dd>
<section class="desc"><p>ConfigParser.getboolean('general', 'ssl_verify')</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def ssl_verify(self):
    &#34;&#34;&#34;ConfigParser.getboolean(&#39;general&#39;, &#39;ssl_verify&#39;)&#34;&#34;&#34;
    return self.getboolean(&#39;general&#39;, &#39;ssl_verify&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.timeout"><code class="name">var <span class="ident">timeout</span></code></dt>
<dd>
<section class="desc"><p>ConfigParser.getint('general', 'timeout')</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def timeout(self):
    &#34;&#34;&#34;ConfigParser.getint(&#39;general&#39;, &#39;timeout&#39;)&#34;&#34;&#34;
    return self.getint(&#39;general&#39;, &#39;timeout&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.user"><code class="name">var <span class="ident">user</span></code></dt>
<dd>
<section class="desc"><p>ConfigParser.get('esm', 'user')</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def user(self):
    &#34;&#34;&#34;ConfigParser.get(&#39;esm&#39;, &#39;user&#39;)&#34;&#34;&#34;
    return self.get(&#39;esm&#39;, &#39;user&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<section class="desc"><p>ConfigParser.getboolean('general', 'verbose')</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def verbose(self):
    &#34;&#34;&#34;ConfigParser.getboolean(&#39;general&#39;, &#39;verbose&#39;)&#34;&#34;&#34;
    return self.getboolean(&#39;general&#39;, &#39;verbose&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.NitroConfig.iset"><code class="name flex">
<span>def <span class="ident">iset</span></span>(<span>self, section, option=None, secure=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Will interactively set the specified section/optionby asking the user the input.
If option stays None, all section's option will be interactively set.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def iset(self, section, option=None, secure=False):
    &#34;&#34;&#34;
    Will interactively set the specified section/optionby asking the user the input.
    If option stays None, all section&#39;s option will be interactively set.
    &#34;&#34;&#34;
    if option is None :
        for key in self.options(section):
            self._iset(section, key, secure)
    else :
        self._iset(section, option, secure)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Write the config file.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write(self):
    &#34;&#34;&#34;
    Write the config file.
    &#34;&#34;&#34;
    log.info(&#34;Write config file at &#34;+self._path)
    with open(self._path, &#39;w&#39;) as conf:
        super().write(conf)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="msiempy.NitroDict"><code class="flex name class">
<span>class <span class="ident">NitroDict</span></span>
<span>(</span><span>adict=None, id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class that represent any SIEM data that can be represented as a item of a list.
Exemple : Event, Alarm, etc&hellip;
Inherits from dict.</p>
<p>Initiate the NitroObject and UserDict objects, load the data if id is specified, use adict agument
and update dict values accordingly.</p>
<pre><code>Parameters

adict : dict object to wrap.
id : ESM obejct unique identifier. Alert.IPSIDAlertID for exemple.
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NitroDict(collections.UserDict, NitroObject):
    &#34;&#34;&#34;
    Base class that represent any SIEM data that can be represented as a item of a list.
    Exemple : Event, Alarm, etc...
    Inherits from dict.
    &#34;&#34;&#34;
    def __init__(self, adict=None, id=None):
        &#34;&#34;&#34;
        Initiate the NitroObject and UserDict objects, load the data if id is specified, use adict agument 
        and update dict values accordingly.

            Parameters

            adict : dict object to wrap.
            id : ESM obejct unique identifier. Alert.IPSIDAlertID for exemple. 
        &#34;&#34;&#34;
        NitroObject.__init__(self)
        collections.UserDict.__init__(self, adict)
        
        if id != None :
            self.data=self.data_from_id(id)

        if isinstance(adict, dict):
            self.data=adict

        for key in self.data :
            if isinstance(self.data[key], list):
                self.data[key]=NitroList(alist=self.data[key])

    @property
    def json(self):
        &#34;&#34;&#34;JSON representation of a item. Basic dict.
        &#34;&#34;&#34;
        return(json.dumps(dict(self), indent=4, cls=NitroObject.NitroJSONEncoder))

    @property
    def text(self):
        &#34;&#34;&#34;A list of values. Not titles.
        &#34;&#34;&#34;
        return(&#39;, &#39;.join([str(val) for val in self.values()]))

    def refresh(self):
        &#34;&#34;&#34;Not implemented here
        &#34;&#34;&#34;
        log.debug(&#39;NOT Refreshing item :&#39;+str(self)+&#39; &#39;+str(NotImplementedError()))

    @abc.abstractmethod
    def data_from_id(self, id):
        &#34;&#34;&#34;This method figured out the way to retreive the item infos from an id.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.UserDict</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="msiempy.NitroObject" href="#msiempy.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="msiempy.event.Event" href="event.html#msiempy.event.Event">Event</a></li>
<li><a title="msiempy.alarm.Alarm" href="alarm.html#msiempy.alarm.Alarm">Alarm</a></li>
<li><a title="msiempy.device.DataSource" href="device.html#msiempy.device.DataSource">DataSource</a></li>
<li><a title="msiempy.watchlist.Watchlist" href="watchlist.html#msiempy.watchlist.Watchlist">Watchlist</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.NitroDict.json"><code class="name">var <span class="ident">json</span></code></dt>
<dd>
<section class="desc"><p>JSON representation of a item. Basic dict.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def json(self):
    &#34;&#34;&#34;JSON representation of a item. Basic dict.
    &#34;&#34;&#34;
    return(json.dumps(dict(self), indent=4, cls=NitroObject.NitroJSONEncoder))</code></pre>
</details>
</dd>
<dt id="msiempy.NitroDict.text"><code class="name">var <span class="ident">text</span></code></dt>
<dd>
<section class="desc"><p>A list of values. Not titles.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def text(self):
    &#34;&#34;&#34;A list of values. Not titles.
    &#34;&#34;&#34;
    return(&#39;, &#39;.join([str(val) for val in self.values()]))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.NitroDict.data_from_id"><code class="name flex">
<span>def <span class="ident">data_from_id</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<section class="desc"><p>This method figured out the way to retreive the item infos from an id.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@abc.abstractmethod
def data_from_id(self, id):
    &#34;&#34;&#34;This method figured out the way to retreive the item infos from an id.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="msiempy.NitroDict.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Not implemented here</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;Not implemented here
    &#34;&#34;&#34;
    log.debug(&#39;NOT Refreshing item :&#39;+str(self)+&#39; &#39;+str(NotImplementedError()))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.NitroObject" href="#msiempy.NitroObject">NitroObject</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.NitroObject.NitroJSONEncoder" href="#msiempy.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="msiempy.NitroError"><code class="flex name class">
<span>class <span class="ident">NitroError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Base internal exception. It's used when the user/passwd is incorrect, or other specific ESM related errors.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NitroError(Exception):
    &#34;&#34;&#34;
    Base internal exception. It&#39;s used when the user/passwd is incorrect, or other specific ESM related errors.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="msiempy.NitroList"><code class="flex name class">
<span>class <span class="ident">NitroList</span></span>
<span>(</span><span>alist=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for NitroList objects. It offers callable execution management, searcb and other data list actions.</p>
<p>Parameters</p>
<p>alist : list object to wrap.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NitroList(collections.UserList, NitroObject):
    &#34;&#34;&#34;
    Base class for NitroList objects. It offers callable execution management, searcb and other data list actions.
    &#34;&#34;&#34;

    def __init__(self, alist=None):
        &#34;&#34;&#34;
            Parameters

            alist : list object to wrap.
        &#34;&#34;&#34;
        NitroObject.__init__(self)
        if alist is None:
            collections.UserList.__init__(self, [])
        
        elif isinstance(alist , (list, NitroList)):
            collections.UserList.__init__(
                self, alist #[NitroDict(adict=item) for item in alist if isinstance(item, (dict, NitroDict))] 
                #Can&#39;t instanciate NitroDict, so Concrete classes has to cast the items afterwards
                )
        else :
            raise ValueError(&#39;NitroList can only be initiated based on a list&#39;)

    @property
    def table_colums(self):
        &#34;&#34;&#34;Return the list of columns the table representation will have. This attribute is designed to overwritten.
        &#34;&#34;&#34;            
        return []

    def _norm_dicts(self):
        &#34;&#34;&#34;
        Internal method.
        All dict should have the same set of keys.
        Creating keys in dicts.
        &#34;&#34;&#34;
        for item in self.data :
            if isinstance(item, (dict, NitroDict)):
                for key in self.keys :
                    if key not in item :
                        item[key]=None

    @property
    def keys(self):
        &#34;&#34;&#34;Set of keys for all dict
        &#34;&#34;&#34;
        #If new fields are added it won&#39;t show on text repr. Only json.
        
        manager_keys=set()
        for item in self.data:
            if isinstance(item, (dict,NitroDict)):
                manager_keys.update(item.keys())

        return manager_keys


    def get_text(self, compact=False, fields=None, max_column_width=120):
        &#34;&#34;&#34;
        Return a acsii table string representation of the manager list

            Parameters

            compact : Returns a nice string table made with prettytable, else an &#39;|&#39; separated list.
            fields : list of fields you want in the table
                is None : default fields are returned by .keys attribute and sorted.
            max_column_width : when using prettytable (not compact)

        It&#39;s an expesive thing to do on big ammount of data !
        &#34;&#34;&#34;
        
        if not fields :
            fields=sorted(self.keys)

        if len(self) == 0 :
            return(&#39;The list is empty&#39;)

        if not compact : #Table
            table = prettytable.PrettyTable()
            table.set_style(MSWORD_FRIENDLY)
            table.field_names=fields
            self._norm_dicts()

            for item in self.data:
                if isinstance(item, (dict, NitroDict)):
                    table.add_row([&#39;\n&#39;.join(textwrap.wrap(str(item[field]), width=max_column_width))
                        if not isinstance(item[field], NitroList)
                        else item[field].get_text() for field in fields])
                else : log.warning(&#34;Unnapropriate list element type, doesn&#39;t show on the list : {}&#34;.format(str(item)))

            if len(self.table_colums) &gt;0 :
                try :
                    text =table.get_string(fields=self.table_colums)
                except Exception as err :
                    if &#34;Invalid field name&#34; in str(err):
                        text=table.get_string()
                        log.warning(&#34;Inconsistent manager state, some fields aren&#39;t present {}&#34;.format(str(err)))
                    else :
                        raise
            else: 
                text=table.get_string()

        elif compact is True :
            text=&#39;|_&#39;
            for field in fields :
                text+=field
                text+=&#39;_|_&#39;
            text=text[0:len(text)-1]
            text+=&#39;\n&#39;
            for item in self.data:
                if isinstance(item, (dict, NitroDict)):
                    text+=&#39;| &#39;
                    for field in fields :
                        if isinstance(item[field], NitroList):
                            text+=item[field].get_text(compact=True)
                        else:
                            text+=(str(item[field]))
                            text+=&#39; | &#39;
                    text=text[0:len(text)-1]
                else : log.warning(&#34;Unnapropriate list element type, doesn&#39;t show on the list : {}&#34;.format(str(item)))
                    #text+=textwrap.wrap(str(item),width=max_column_width)
                text+=&#39;\n&#39;
            text=text[0:len(text)-1]
        return text



    @property
    def text(self):
        &#34;&#34;&#34;The text properti is a shorcut to get_text() with no arguments.
        &#34;&#34;&#34;
        return self.get_text()
        
    @property
    def json(self):
        &#34;&#34;&#34;Dumps a JSON list of dicts representing the current list.
        &#34;&#34;&#34;
        return(json.dumps([dict(item) for item in self.data], indent=4, cls=NitroObject.NitroJSONEncoder))

    def search(self, invert=False, match_prop=&#39;json&#39;, *pattern):
        &#34;&#34;&#34;
        Return a list of elements that matches one or more regex patterns.
        Patterns are applied one after another. It&#39;s a logic AND.
        Use `|` inside patterns to search with logic OR.
        This method will return a new NitroList with matching data. NitroDicts in the returned NitroList do not
        references the items in the original NitroList.

            Parameters
            
            *pattern : List or string regex patterns to look for.
            invert : Weither or not to invert the search and return elements that doesn&#39;t not match search.
            match_prop : Propertie that is going to be called to search. Could be `text` or `json`.


        If you wish to apply more specific filters to NitroList list, please
        use filter(), list comprehension, or other filtering method.
            i.e. : `[item for item in list if item[&#39;cost&#39;] &gt; 50]`

        More on regex https://docs.python.org/3/library/re.html#re.Pattern.search
        &#34;&#34;&#34;
        if pattern is None :
            return self
        elif len(pattern) == 0 :
            return self
        else :
            pattern=list(pattern)
            apattern=pattern.pop()
        
        matching_items=list()
        
        if isinstance(apattern, str):
            for item in self.data :
                if regex_match(apattern, getattr(item, match_prop) if isinstance(item, NitroDict) else str(item)) is not invert :
                    matching_items.append(item)
            log.debug(&#34;You&#39;re search returned {} rows : {}&#34;.format(
                len(matching_items),
                str(matching_items)[:100]+&#39;...&#39;))
            #Apply AND reccursively
            return NitroList(alist=matching_items).search(*pattern, invert=invert, match_prop=match_prop)
        else:
            raise ValueError(&#39;pattern must be str&#39;)

    def refresh(self):
        &#34;&#34;&#34;
        Execute refresh function on all items.
        &#34;&#34;&#34;
        log.warning(&#34;The function NitroList.refresh hasn&#39;t been correctly tested&#34;)
        self.perform(NitroDict.refresh)

    def perform(self, func, data=None, func_args=None, confirm=False, asynch=False,  workers=None , progress=False, message=None):
        &#34;&#34;&#34;
        Wrapper arround executable and the data list of `msiempy.NitroList` object.
        Will execute the callable the list.

            Parameters
            
            func : callable stateless function. func is going to be called like func(item, **func_args) on all items in data.
            data : if stays None, will perform the action on all rows, else it will perfom the action on the data list.
            func_args : dict that will be passed by default to func in all calls.
            confirm : will ask interactively confirmation.
            asynch : execute the task asynchronously with `msiempy.NitroSession` executor.
            workers : mandatory if asynch is true.
            progress : to show progress bar with ETA (tqdm).
            message : To show to the user.

        Returns a list of returned results
        &#34;&#34;&#34;

        log.debug(&#39;Calling perform func=&#39;+str(func)+
            &#39; data=&#39;+str(data)[:100]+
            &#39; func_args=&#39;+str(func_args)+
            &#39; confirm=&#39;+str(confirm)+
            &#39; asynch=&#39;+str(asynch)+
            &#39; workers=&#39;+str(workers)+
            &#39; progress=&#39;+str(progress)+
            &#39; message=&#39;+str(message))

        if not callable(func) :
            raise ValueError(&#39;func must be callable&#39;)

        #Confirming with user if asked
        if confirm : self._confirm_func(func, str(self))

        #Setting the arguments on the function
        func = functools.partial(func, **(func_args if func_args is not None else {}))
        
        #The data returned by function
        returned=list()

        #Usethe self contained data if not speficed otherwise
        elements=self.data
        if isinstance(data, list) and data is not None:
            elements=data
        else :
            AttributeError(&#39;data must be a list&#39;)

        #Printing message if specified.
        tqdm_args=dict()
        #The message will appear on loading bar if progress is True
        if progress is True :
            tqdm_args=dict(desc=&#39;Loading...&#39;, total=len(elements))
            if message is not None:
                tqdm_args[&#39;desc&#39;]=message

        

        #Runs the callable on list on executor or by iterating
        if asynch == True :
            if isinstance(workers, int) :
                if progress==True :
                    if not self.nitro.config.quiet:
                        #Need to call tqdm to have better support for concurrent futures executor
                        # tqdm would load the whole bar intantaneously and not wait until the callable func returns. 
                        returned=list(tqdm.tqdm(concurrent.futures.ThreadPoolExecutor(
                        max_workers=workers ).map(
                            func, elements), **tqdm_args))
                    else:
                        log.warning(&#34;You requested to show perfrom progress but config&#39;s quiet value is True, not showing tqdm load bar.&#34;)
                        returned=list(concurrent.futures.ThreadPoolExecutor(
                        max_workers=workers ).map(
                            func, elements))
                else:
                    returned=list(concurrent.futures.ThreadPoolExecutor(
                    max_workers=workers ).map(
                        func, elements))
            else:
                raise AttributeError(&#39;When asynch == True : You must specify a integer value for workers&#39;)
        else :

            if progress==True:
                if not self.nitro.config.quiet:
                    elements=tqdm.tqdm(elements, **tqdm_args)
                else:
                    log.warning(&#34;You requested to show perform progress but config&#39;s quiet value is True, not showing tqdm load bar.&#34;)

            for index_or_item in elements:
                returned.append(func(index_or_item))

        return(returned)

    @staticmethod
    def _confirm_func(func, elements):
        &#34;&#34;&#34;
        Ask user inut to confirm the calling of `func` on `elements`.
        &#34;&#34;&#34;
        if not &#39;y&#39; in input(&#39;Are you sure you want to do this &#39;+str(func)+&#39; on &#39;+
        (&#39;\n&#39;+str(elements) if elements is not None else &#39;all elements&#39;)+&#39;? [y/n]: &#39;):
            raise InterruptedError(&#34;The action was cancelled by the user.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.UserList</li>
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="msiempy.NitroObject" href="#msiempy.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="msiempy.query.FilteredQueryList" href="query.html#msiempy.query.FilteredQueryList">FilteredQueryList</a></li>
<li><a title="msiempy.device.DevTree" href="device.html#msiempy.device.DevTree">DevTree</a></li>
<li><a title="msiempy.watchlist.WatchlistManager" href="watchlist.html#msiempy.watchlist.WatchlistManager">WatchlistManager</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.NitroList.json"><code class="name">var <span class="ident">json</span></code></dt>
<dd>
<section class="desc"><p>Dumps a JSON list of dicts representing the current list.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def json(self):
    &#34;&#34;&#34;Dumps a JSON list of dicts representing the current list.
    &#34;&#34;&#34;
    return(json.dumps([dict(item) for item in self.data], indent=4, cls=NitroObject.NitroJSONEncoder))</code></pre>
</details>
</dd>
<dt id="msiempy.NitroList.keys"><code class="name">var <span class="ident">keys</span></code></dt>
<dd>
<section class="desc"><p>Set of keys for all dict</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def keys(self):
    &#34;&#34;&#34;Set of keys for all dict
    &#34;&#34;&#34;
    #If new fields are added it won&#39;t show on text repr. Only json.
    
    manager_keys=set()
    for item in self.data:
        if isinstance(item, (dict,NitroDict)):
            manager_keys.update(item.keys())

    return manager_keys</code></pre>
</details>
</dd>
<dt id="msiempy.NitroList.table_colums"><code class="name">var <span class="ident">table_colums</span></code></dt>
<dd>
<section class="desc"><p>Return the list of columns the table representation will have. This attribute is designed to overwritten.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def table_colums(self):
    &#34;&#34;&#34;Return the list of columns the table representation will have. This attribute is designed to overwritten.
    &#34;&#34;&#34;            
    return []</code></pre>
</details>
</dd>
<dt id="msiempy.NitroList.text"><code class="name">var <span class="ident">text</span></code></dt>
<dd>
<section class="desc"><p>The text properti is a shorcut to get_text() with no arguments.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def text(self):
    &#34;&#34;&#34;The text properti is a shorcut to get_text() with no arguments.
    &#34;&#34;&#34;
    return self.get_text()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.NitroList.get_text"><code class="name flex">
<span>def <span class="ident">get_text</span></span>(<span>self, compact=False, fields=None, max_column_width=120)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a acsii table string representation of the manager list</p>
<pre><code>Parameters

compact : Returns a nice string table made with prettytable, else an '|' separated list.
fields : list of fields you want in the table
    is None : default fields are returned by .keys attribute and sorted.
max_column_width : when using prettytable (not compact)
</code></pre>
<p>It's an expesive thing to do on big ammount of data !</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_text(self, compact=False, fields=None, max_column_width=120):
    &#34;&#34;&#34;
    Return a acsii table string representation of the manager list

        Parameters

        compact : Returns a nice string table made with prettytable, else an &#39;|&#39; separated list.
        fields : list of fields you want in the table
            is None : default fields are returned by .keys attribute and sorted.
        max_column_width : when using prettytable (not compact)

    It&#39;s an expesive thing to do on big ammount of data !
    &#34;&#34;&#34;
    
    if not fields :
        fields=sorted(self.keys)

    if len(self) == 0 :
        return(&#39;The list is empty&#39;)

    if not compact : #Table
        table = prettytable.PrettyTable()
        table.set_style(MSWORD_FRIENDLY)
        table.field_names=fields
        self._norm_dicts()

        for item in self.data:
            if isinstance(item, (dict, NitroDict)):
                table.add_row([&#39;\n&#39;.join(textwrap.wrap(str(item[field]), width=max_column_width))
                    if not isinstance(item[field], NitroList)
                    else item[field].get_text() for field in fields])
            else : log.warning(&#34;Unnapropriate list element type, doesn&#39;t show on the list : {}&#34;.format(str(item)))

        if len(self.table_colums) &gt;0 :
            try :
                text =table.get_string(fields=self.table_colums)
            except Exception as err :
                if &#34;Invalid field name&#34; in str(err):
                    text=table.get_string()
                    log.warning(&#34;Inconsistent manager state, some fields aren&#39;t present {}&#34;.format(str(err)))
                else :
                    raise
        else: 
            text=table.get_string()

    elif compact is True :
        text=&#39;|_&#39;
        for field in fields :
            text+=field
            text+=&#39;_|_&#39;
        text=text[0:len(text)-1]
        text+=&#39;\n&#39;
        for item in self.data:
            if isinstance(item, (dict, NitroDict)):
                text+=&#39;| &#39;
                for field in fields :
                    if isinstance(item[field], NitroList):
                        text+=item[field].get_text(compact=True)
                    else:
                        text+=(str(item[field]))
                        text+=&#39; | &#39;
                text=text[0:len(text)-1]
            else : log.warning(&#34;Unnapropriate list element type, doesn&#39;t show on the list : {}&#34;.format(str(item)))
                #text+=textwrap.wrap(str(item),width=max_column_width)
            text+=&#39;\n&#39;
        text=text[0:len(text)-1]
    return text</code></pre>
</details>
</dd>
<dt id="msiempy.NitroList.perform"><code class="name flex">
<span>def <span class="ident">perform</span></span>(<span>self, func, data=None, func_args=None, confirm=False, asynch=False, workers=None, progress=False, message=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Wrapper arround executable and the data list of <a title="msiempy.NitroList" href="#msiempy.NitroList"><code>NitroList</code></a> object.
Will execute the callable the list.</p>
<pre><code>Parameters

func : callable stateless function. func is going to be called like func(item, **func_args) on all items in data.
data : if stays None, will perform the action on all rows, else it will perfom the action on the data list.
func_args : dict that will be passed by default to func in all calls.
confirm : will ask interactively confirmation.
asynch : execute the task asynchronously with &lt;a title="msiempy.NitroSession" href="#msiempy.NitroSession"&gt;`NitroSession`&lt;/a&gt; executor.
workers : mandatory if asynch is true.
progress : to show progress bar with ETA (tqdm).
message : To show to the user.
</code></pre>
<p>Returns a list of returned results</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def perform(self, func, data=None, func_args=None, confirm=False, asynch=False,  workers=None , progress=False, message=None):
    &#34;&#34;&#34;
    Wrapper arround executable and the data list of `msiempy.NitroList` object.
    Will execute the callable the list.

        Parameters
        
        func : callable stateless function. func is going to be called like func(item, **func_args) on all items in data.
        data : if stays None, will perform the action on all rows, else it will perfom the action on the data list.
        func_args : dict that will be passed by default to func in all calls.
        confirm : will ask interactively confirmation.
        asynch : execute the task asynchronously with `msiempy.NitroSession` executor.
        workers : mandatory if asynch is true.
        progress : to show progress bar with ETA (tqdm).
        message : To show to the user.

    Returns a list of returned results
    &#34;&#34;&#34;

    log.debug(&#39;Calling perform func=&#39;+str(func)+
        &#39; data=&#39;+str(data)[:100]+
        &#39; func_args=&#39;+str(func_args)+
        &#39; confirm=&#39;+str(confirm)+
        &#39; asynch=&#39;+str(asynch)+
        &#39; workers=&#39;+str(workers)+
        &#39; progress=&#39;+str(progress)+
        &#39; message=&#39;+str(message))

    if not callable(func) :
        raise ValueError(&#39;func must be callable&#39;)

    #Confirming with user if asked
    if confirm : self._confirm_func(func, str(self))

    #Setting the arguments on the function
    func = functools.partial(func, **(func_args if func_args is not None else {}))
    
    #The data returned by function
    returned=list()

    #Usethe self contained data if not speficed otherwise
    elements=self.data
    if isinstance(data, list) and data is not None:
        elements=data
    else :
        AttributeError(&#39;data must be a list&#39;)

    #Printing message if specified.
    tqdm_args=dict()
    #The message will appear on loading bar if progress is True
    if progress is True :
        tqdm_args=dict(desc=&#39;Loading...&#39;, total=len(elements))
        if message is not None:
            tqdm_args[&#39;desc&#39;]=message

    

    #Runs the callable on list on executor or by iterating
    if asynch == True :
        if isinstance(workers, int) :
            if progress==True :
                if not self.nitro.config.quiet:
                    #Need to call tqdm to have better support for concurrent futures executor
                    # tqdm would load the whole bar intantaneously and not wait until the callable func returns. 
                    returned=list(tqdm.tqdm(concurrent.futures.ThreadPoolExecutor(
                    max_workers=workers ).map(
                        func, elements), **tqdm_args))
                else:
                    log.warning(&#34;You requested to show perfrom progress but config&#39;s quiet value is True, not showing tqdm load bar.&#34;)
                    returned=list(concurrent.futures.ThreadPoolExecutor(
                    max_workers=workers ).map(
                        func, elements))
            else:
                returned=list(concurrent.futures.ThreadPoolExecutor(
                max_workers=workers ).map(
                    func, elements))
        else:
            raise AttributeError(&#39;When asynch == True : You must specify a integer value for workers&#39;)
    else :

        if progress==True:
            if not self.nitro.config.quiet:
                elements=tqdm.tqdm(elements, **tqdm_args)
            else:
                log.warning(&#34;You requested to show perform progress but config&#39;s quiet value is True, not showing tqdm load bar.&#34;)

        for index_or_item in elements:
            returned.append(func(index_or_item))

    return(returned)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroList.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Execute refresh function on all items.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;
    Execute refresh function on all items.
    &#34;&#34;&#34;
    log.warning(&#34;The function NitroList.refresh hasn&#39;t been correctly tested&#34;)
    self.perform(NitroDict.refresh)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroList.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self, invert=False, match_prop='json', *pattern)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a list of elements that matches one or more regex patterns.
Patterns are applied one after another. It's a logic AND.
Use <code>|</code> inside patterns to search with logic OR.
This method will return a new NitroList with matching data. NitroDicts in the returned NitroList do not
references the items in the original NitroList.</p>
<pre><code>Parameters

*pattern : List or string regex patterns to look for.
invert : Weither or not to invert the search and return elements that doesn't not match search.
match_prop : Propertie that is going to be called to search. Could be `text` or `json`.
</code></pre>
<p>If you wish to apply more specific filters to NitroList list, please
use filter(), list comprehension, or other filtering method.
i.e. : <code>[item for item in list if item['cost'] &gt; 50]</code></p>
<p>More on regex <a href="https://docs.python.org/3/library/re.html#re.Pattern.search">https://docs.python.org/3/library/re.html#re.Pattern.search</a></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def search(self, invert=False, match_prop=&#39;json&#39;, *pattern):
    &#34;&#34;&#34;
    Return a list of elements that matches one or more regex patterns.
    Patterns are applied one after another. It&#39;s a logic AND.
    Use `|` inside patterns to search with logic OR.
    This method will return a new NitroList with matching data. NitroDicts in the returned NitroList do not
    references the items in the original NitroList.

        Parameters
        
        *pattern : List or string regex patterns to look for.
        invert : Weither or not to invert the search and return elements that doesn&#39;t not match search.
        match_prop : Propertie that is going to be called to search. Could be `text` or `json`.


    If you wish to apply more specific filters to NitroList list, please
    use filter(), list comprehension, or other filtering method.
        i.e. : `[item for item in list if item[&#39;cost&#39;] &gt; 50]`

    More on regex https://docs.python.org/3/library/re.html#re.Pattern.search
    &#34;&#34;&#34;
    if pattern is None :
        return self
    elif len(pattern) == 0 :
        return self
    else :
        pattern=list(pattern)
        apattern=pattern.pop()
    
    matching_items=list()
    
    if isinstance(apattern, str):
        for item in self.data :
            if regex_match(apattern, getattr(item, match_prop) if isinstance(item, NitroDict) else str(item)) is not invert :
                matching_items.append(item)
        log.debug(&#34;You&#39;re search returned {} rows : {}&#34;.format(
            len(matching_items),
            str(matching_items)[:100]+&#39;...&#39;))
        #Apply AND reccursively
        return NitroList(alist=matching_items).search(*pattern, invert=invert, match_prop=match_prop)
    else:
        raise ValueError(&#39;pattern must be str&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.NitroObject" href="#msiempy.NitroObject">NitroObject</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.NitroObject.NitroJSONEncoder" href="#msiempy.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="msiempy.NitroObject"><code class="flex name class">
<span>class <span class="ident">NitroObject</span></span>
</code></dt>
<dd>
<section class="desc"><p>Base class for all nitro objects. All objects have a reference to the single <a title="msiempy.NitroSession" href="#msiempy.NitroSession"><code>NitroSession</code></a> object that handle the esm requests.</p>
<p>Creates the object session.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NitroObject(abc.ABC):
    &#34;&#34;&#34;
    Base class for all nitro objects. All objects have a reference to the single `msiempy.NitroSession` object that handle the esm requests.
    &#34;&#34;&#34;

    class NitroJSONEncoder(json.JSONEncoder):
        &#34;&#34;&#34;
        Custom JSON encoder that will use the approprtiate propertie depending of the type of NitroObject.
        TODO return meta info about the NitroList. Maybe create a section `manager` and `data`.
        TODO support json json dumping of QueryFilers, may be by making them inherits from NitroDict.
        &#34;&#34;&#34;
        def default(self, obj): # pylint: disable=E0202
            if isinstance(obj,(NitroDict, NitroList)):
                return obj.data
            #elif isinstance(obj, (QueryFilter)):
                #return obj.config_dict
            else:
                return json.JSONEncoder.default(self, obj) 

    @abc.abstractmethod
    def __init__(self):
        &#34;&#34;&#34;Creates the object session.
        &#34;&#34;&#34;
        self.nitro=NitroSession()

    def __str__(self):
        &#34;&#34;&#34;
        str(obj) -&gt; return text string.
        Can be a table if the object is a NitroList.
        &#34;&#34;&#34;
        return self.text

    def __repr__(self):
        &#34;&#34;&#34;
        repr(obj) -&gt; return json string.
        &#34;&#34;&#34;
        return self.json

    @abc.abstractproperty
    def text(self):
        &#34;&#34;&#34;
        Returns printable string.
        &#34;&#34;&#34;
        pass

    @abc.abstractproperty
    def json(self):
        &#34;&#34;&#34;
        Returns json string representation.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def refresh(self):
        &#34;&#34;&#34;
        Refresh the state of the object.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="msiempy.NitroDict" href="#msiempy.NitroDict">NitroDict</a></li>
<li><a title="msiempy.NitroList" href="#msiempy.NitroList">NitroList</a></li>
<li><a title="msiempy.query.QueryFilter" href="query.html#msiempy.query.QueryFilter">QueryFilter</a></li>
<li><a title="msiempy.device.Device" href="device.html#msiempy.device.Device">Device</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.NitroObject.NitroJSONEncoder"><code class="name">var <span class="ident">NitroJSONEncoder</span></code></dt>
<dd>
<section class="desc"><p>Custom JSON encoder that will use the approprtiate propertie depending of the type of NitroObject.
TODO return meta info about the NitroList. Maybe create a section <code>manager</code> and <code>data</code>.
TODO support json json dumping of QueryFilers, may be by making them inherits from NitroDict.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.NitroObject.json"><code class="name">var <span class="ident">json</span></code></dt>
<dd>
<section class="desc"><p>Returns json string representation.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@abc.abstractproperty
def json(self):
    &#34;&#34;&#34;
    Returns json string representation.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="msiempy.NitroObject.text"><code class="name">var <span class="ident">text</span></code></dt>
<dd>
<section class="desc"><p>Returns printable string.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@abc.abstractproperty
def text(self):
    &#34;&#34;&#34;
    Returns printable string.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.NitroObject.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Refresh the state of the object.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@abc.abstractmethod
def refresh(self):
    &#34;&#34;&#34;
    Refresh the state of the object.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="msiempy.NitroSession"><code class="flex name class">
<span>class <span class="ident">NitroSession</span></span>
<span>(</span><span>conf_path=None, conf_dict=None)</span>
</code></dt>
<dd>
<section class="desc"><p>NitroSession object represent the point of convergence of every request to the McFee ESM
It provides standard dialogue with the esm with agument interpolation with <a title="msiempy.params" href="params.html"><code>msiempy.params</code></a>.
Internal <code>__dict__</code> refers to a unique instance of dict and thus, properties can be instanciated only once.
Credentials and other configurations are read from a ./.msiem/conf.ini file.
If the ./msiem directory desn't exists in your current directory, will assume the file is your home directory
as ~/.msiem/conf.ini or %appdata%\Roaming.msiem\conf.ini.
Use NitroSession.config.read() - ConfigParser object - to read a new configuration file. </p>
<p>The init method is called every time you call NitroSession() constructor.
But the properties are actually initiated only once.
Use logout() to trash the obejct and re instanciate NitroSession.</p>
<pre><code>Parameters

conf_path : Configuration file path can be passed as conf_path attr.
conf_dict : attr ie : {'esm':{'host':'myhost.com','user':'username','passwd':''}...}.
See &lt;a title="msiempy.NitroConfig" href="#msiempy.NitroConfig"&gt;`NitroConfig`&lt;/a&gt; class to have full details.
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NitroSession():
    &#39;&#39;&#39;NitroSession object represent the point of convergence of every request to the McFee ESM
    It provides standard dialogue with the esm with agument interpolation with `msiempy.params`.
    Internal `__dict__` refers to a unique instance of dict and thus, properties can be instanciated only once.
    Credentials and other configurations are read from a ./.msiem/conf.ini file.
    If the ./msiem directory desn&#39;t exists in your current directory, will assume the file is your home directory
        as ~/.msiem/conf.ini or %appdata%\\Roaming\\.msiem\\conf.ini.
    Use NitroSession.config.read() - ConfigParser object - to read a new configuration file. 
    &#39;&#39;&#39;

    BASE_URL = &#39;https://{}/rs/esm/&#39;
    &#34;&#34;&#34;API v2 base url.
    &#34;&#34;&#34;

    BASE_URL_PRIV = &#39;https://{}/ess/&#39;
    &#34;&#34;&#34;Private API base URL.
    &#34;&#34;&#34;

    __initiated__ = False
    &#34;&#34;&#34;
    Weither the session has been intaciated. It&#39;s supposed to be a singleton.
    &#34;&#34;&#34;
    __unique_state__ = {}
    &#34;&#34;&#34;
    The singleton unique state.
    &#34;&#34;&#34;
    
    config = None
    &#34;&#34;&#34;
    NitroConfig object.
    &#34;&#34;&#34;
    
    executor = None
    &#34;&#34;&#34;
    Executor object.
    &#34;&#34;&#34;
        
    def __str__(self):
        &#34;&#34;&#34;
    &#34;&#34;&#34;
        return repr(self.__unique_state__) 

    def __init__(self, conf_path=None, conf_dict=None):
        &#34;&#34;&#34;
        The init method is called every time you call NitroSession() constructor.
        But the properties are actually initiated only once.
        Use logout() to trash the obejct and re instanciate NitroSession.

            Parameters

            conf_path : Configuration file path can be passed as conf_path attr.
            conf_dict : attr ie : {&#39;esm&#39;:{&#39;host&#39;:&#39;myhost.com&#39;,&#39;user&#39;:&#39;username&#39;,&#39;passwd&#39;:&#39;&#39;}...}.
            See `msiempy.NitroConfig` class to have full details.
        &#34;&#34;&#34;
        global log
        self.__dict__ = NitroSession.__unique_state__
        
        #Init properties only once
        if not self.__initiated__ :
            NitroSession.__initiated__ = True
            log.info(&#39;New NitroSession instance&#39;)
            
            #Private attributes
            self._headers={&#39;Content-Type&#39;: &#39;application/json&#39;}
            self._logged=False
            
            #Config parsing
            self.config = NitroConfig(path=conf_path, config=conf_dict)
            NitroSession.config=self.config

            #Set the logging configuration
            self._init_log(verbose=self.config.verbose,
                quiet=self.config.quiet,
                logfile=self.config.logfile)

    def _request(self, method, http, data=None, callback=None, raw=False, secure=False):
        &#34;&#34;&#34;
        Helper method that format the request, handle the basic parsing of the SIEM result 
        as well as other errors.        
        If method is all upper cases, it&#39;s a private API call.
        Private API is under /ess/ and public api is under /rs/esm
        Returns None if HTTP error, Timeout or TooManyRedirects if raw=False
        &#34;&#34;&#34;

        url=str()
        privateApiCall=False
        result=None

        #Handling private API calls formatting
        if method == method.upper():
            privateApiCall=True
            url = self.BASE_URL_PRIV
            data = self._format_params(method, **data)
            log.debug(&#39;Private API call : &#39;+str(method)+&#39; Formatted params : &#39;+str(data))
        
        #Normal API calls
        else:
            url = self.BASE_URL
            if data:
                data = json.dumps(data)

        #Logging the data request if not secure | Logs anyway the method
        log.debug(&#39;Requesting HTTP &#39;+http+&#39; &#39;+ method + 
            (&#39; with data &#39;+str(data) if (data is not None and not secure) else &#39;&#39;) )

        try :
            result = requests.request(
                http,
                urllib.parse.urljoin(url.format(self.config.host), method),
                data=data, 
                headers=self._headers,
                verify=self.config.ssl_verify,
                timeout=self.config.timeout
            )

            if raw :
                log.debug(&#39;Returning raw requests Response object :&#39;+str(result))
                return result

            else:
                try:
                    result.raise_for_status()

                except requests.HTTPError as e :
                    log.error(str(e)+&#39; &#39;+str(result.text))
                    return result.text
                    #TODO handle expired session error, result unavailable / other siem errors
                    # ERROR_InvalidFilter (228)
                    # Status Code 500: Error processing request, see server logs for more details 
                    # &lt;Response [400]&gt;
                    # Input Validation Error
                    # By creating a new class

                else: #
                    result = self._unpack_resp(result)

                    if privateApiCall :
                        result = self._format_priv_resp(result)

                    if callback:
                        result = callback(result)

                    log.debug(&#39;Result &#39;+str(result)[:100]+&#39;[...]&#39;)

                    return result

        #Soft errors
        except requests.exceptions.Timeout as e:
            log.error(e)
            return None
        except requests.exceptions.TooManyRedirects as e :
            log.error(e)
            return None
        
    def _login(self):
        &#34;&#34;&#34;
        Internal method that will be called when the user is not logged yet.
        Throws NitroError if login fails
        &#34;&#34;&#34;
        userb64 = tob64(self.config.user)
        passb64 = self.config.passwd
        
        resp = self.request(&#39;login&#39;, username=userb64, password=passb64, raw=True, secure=True)
        
        if resp is not None :
            if resp.status_code in [400, 401]:
                raise NitroError(&#39;Invalid username or password for the ESM&#39;)
            elif 402 &lt;= resp.status_code &lt;= 600:
                raise NitroError(&#39;ESM Login Error:&#39;, resp.text)
       
            self._headers[&#39;Cookie&#39;] = resp.headers.get(&#39;Set-Cookie&#39;)
            self._headers[&#39;X-Xsrf-Token&#39;] = resp.headers.get(&#39;Xsrf-Token&#39;)
    
            return True
        else:
            raise NitroError(&#39;ESM Login Error: Response empty&#39;)

    def request(self, request, http=&#39;post&#39;, callback=None, raw=False, secure=False, **params):
        &#34;&#34;&#34;
            This method is the centralized interface of all request coming to the SIEM.

                Parameters

                request :   keyword corresponding to the request name in `msiempy.params` mapping.
                http :      http method.
                callback :  a callable to execute on the returned object if needed.
                raw :       if true will return the Response object from requests module.
                secure :    if true will not log the content of the request.
                **params :  interpolation parameters that will be match to `msiempy.params` templates. Check the file to be sure of the keyword arguments.

            Returns None if HTTP error, Timeout or TooManyRedirects if raw=False
        &#34;&#34;&#34;
        log.debug(&#34;Calling nitro request : {} params={} http={} raw={} secure={} callback={}&#34;.format(
            str(request), str(params) if not secure else &#39;***&#39;, str(http), str(raw), str(secure), str(callback)
        ))

        method, data = PARAMS.get(request)

        if data is not None :
            data =  data % params
            data = ast.literal_eval((data.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\t&#39;,&#39;&#39;)))
           
        if method is not None:
            try :
                method = method % params
            except TypeError as err :
                if (&#39;must be real number, not dict&#39; in str(err)):
                    log.warning(&#34;Interpolation failed probably because of the private API calls formatting... Unexpected behaviours can happend.&#34;)

        if not self._logged and method != &#39;login&#39;:
            self._logged=self._login()

        try :
            return self._request(method, http, data, callback, raw, secure)

        except ConnectionError as e:
            log.critical(e)
            raise
        except Exception as e:
            log.error(e)
            raise 
        
    def logout(self):
        &#34;&#34;&#34; 
        This method will logout the session, clear headers and throw away the object,
            a new session will be instanciated next time.
        &#34;&#34;&#34;
        self.request(&#39;logout&#39;, http=&#39;delete&#39;)
        self._logged=False
        NitroSession.__initiated__ = False

    @staticmethod
    def _init_log(verbose=False, quiet=False, logfile=None):
        &#34;&#34;&#34;
        Private method. Inits the session&#39;s logger settings based on params
        All objects should be able to log stuff, so the logger is globaly accessible
        &#34;&#34;&#34;

        log.setLevel(logging.DEBUG)

        formatter = logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(message)s&#39;)

        std = logging.StreamHandler()
        std.setLevel(logging.DEBUG)
        std.setFormatter(formatter)

        if verbose :
            std.setLevel(logging.DEBUG)
        elif quiet :
            std.setLevel(logging.CRITICAL)
        else :
            std.setLevel(logging.INFO)

        
            
            
        log.handlers=[]
        
        log.addHandler(std)

        if logfile :
            fh = logging.FileHandler(logfile)
            fh.setLevel(logging.DEBUG)
            fh.setFormatter(logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(message)s&#39;))
            log.addHandler(fh)

        if verbose and quiet :
            log.warning(&#34;Verbose and quiet values are both set to True. This is a very inconsistent state. By default, verbose value has priority.&#34;)

        return (log)
    

    @staticmethod
    def _format_params(cmd, **params):
        &#34;&#34;&#34;
        Format private API call.
        From mfe_saw project at https://github.com/andywalden/mfe_saw
        &#34;&#34;&#34;
        params = {k: v for k, v in params.items() if v is not None}
        params = &#39;%14&#39;.join([k + &#39;%13&#39; + v + &#39;%13&#39; for (k, v) in params.items()])
        
        if params:
            params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39; + params + &#39;%14&#39;
        else:
            params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39;
        return params

    @staticmethod
    def _format_priv_resp(resp):
        &#34;&#34;&#34;
        Format response from private API
        From mfe_saw project at https://github.com/andywalden/mfe_saw
        &#34;&#34;&#34;
        resp = re.search(&#39;Response=(.*)&#39;, resp).group(1)
        resp = resp.replace(&#39;%14&#39;, &#39; &#39;)
        pairs = resp.split()
        formatted = {}
        for pair in pairs:
            pair = pair.replace(&#39;%13&#39;, &#39; &#39;)
            pair = pair.split()
            key = pair[0]
            if key == &#39;ITEMS&#39;:
                value = pair[-1]
            else:
                value = urllib.parse.unquote(pair[-1])
            formatted[key] = value
        return formatted

    @staticmethod
    def _unpack_resp(response) :
        &#34;&#34;&#34;Unpack data from response.
        Args: 
            response: requests.Response response object
        Returns a list, a dict or a string
        &#34;&#34;&#34;
        try :
            data = response.json()
            if isinstance(response.json(), dict):
                try:
                    data = data[&#39;value&#39;]
                except KeyError:
                    try:
                        data = data[&#39;return&#39;]
                    except KeyError:
                        pass
            
        except json.decoder.JSONDecodeError:
            data = response.text

        return data</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.NitroSession.BASE_URL"><code class="name">var <span class="ident">BASE_URL</span></code></dt>
<dd>
<section class="desc"><p>API v2 base url.</p></section>
</dd>
<dt id="msiempy.NitroSession.BASE_URL_PRIV"><code class="name">var <span class="ident">BASE_URL_PRIV</span></code></dt>
<dd>
<section class="desc"><p>Private API base URL.</p></section>
</dd>
<dt id="msiempy.NitroSession.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<section class="desc"><p>NitroConfig object.</p></section>
</dd>
<dt id="msiempy.NitroSession.executor"><code class="name">var <span class="ident">executor</span></code></dt>
<dd>
<section class="desc"><p>Executor object.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.NitroSession.logout"><code class="name flex">
<span>def <span class="ident">logout</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This method will logout the session, clear headers and throw away the object,
a new session will be instanciated next time.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def logout(self):
    &#34;&#34;&#34; 
    This method will logout the session, clear headers and throw away the object,
        a new session will be instanciated next time.
    &#34;&#34;&#34;
    self.request(&#39;logout&#39;, http=&#39;delete&#39;)
    self._logged=False
    NitroSession.__initiated__ = False</code></pre>
</details>
</dd>
<dt id="msiempy.NitroSession.request"><code class="name flex">
<span>def <span class="ident">request</span></span>(<span>self, request, http='post', callback=None, raw=False, secure=False, **params)</span>
</code></dt>
<dd>
<section class="desc"><p>This method is the centralized interface of all request coming to the SIEM.</p>
<pre><code>Parameters

request :   keyword corresponding to the request name in &lt;a title="msiempy.params" href="params.html"&gt;`msiempy.params`&lt;/a&gt; mapping.
http :      http method.
callback :  a callable to execute on the returned object if needed.
raw :       if true will return the Response object from requests module.
secure :    if true will not log the content of the request.
**params :  interpolation parameters that will be match to &lt;a title="msiempy.params" href="params.html"&gt;`msiempy.params`&lt;/a&gt; templates. Check the file to be sure of the keyword arguments.
</code></pre>
<p>Returns None if HTTP error, Timeout or TooManyRedirects if raw=False</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def request(self, request, http=&#39;post&#39;, callback=None, raw=False, secure=False, **params):
    &#34;&#34;&#34;
        This method is the centralized interface of all request coming to the SIEM.

            Parameters

            request :   keyword corresponding to the request name in `msiempy.params` mapping.
            http :      http method.
            callback :  a callable to execute on the returned object if needed.
            raw :       if true will return the Response object from requests module.
            secure :    if true will not log the content of the request.
            **params :  interpolation parameters that will be match to `msiempy.params` templates. Check the file to be sure of the keyword arguments.

        Returns None if HTTP error, Timeout or TooManyRedirects if raw=False
    &#34;&#34;&#34;
    log.debug(&#34;Calling nitro request : {} params={} http={} raw={} secure={} callback={}&#34;.format(
        str(request), str(params) if not secure else &#39;***&#39;, str(http), str(raw), str(secure), str(callback)
    ))

    method, data = PARAMS.get(request)

    if data is not None :
        data =  data % params
        data = ast.literal_eval((data.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\t&#39;,&#39;&#39;)))
       
    if method is not None:
        try :
            method = method % params
        except TypeError as err :
            if (&#39;must be real number, not dict&#39; in str(err)):
                log.warning(&#34;Interpolation failed probably because of the private API calls formatting... Unexpected behaviours can happend.&#34;)

    if not self._logged and method != &#39;login&#39;:
        self._logged=self._login()

    try :
        return self._request(method, http, data, callback, raw, secure)

    except ConnectionError as e:
        log.critical(e)
        raise
    except Exception as e:
        log.error(e)
        raise </code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="msiempy.alarm" href="alarm.html">msiempy.alarm</a></code></li>
<li><code><a title="msiempy.device" href="device.html">msiempy.device</a></code></li>
<li><code><a title="msiempy.event" href="event.html">msiempy.event</a></code></li>
<li><code><a title="msiempy.params" href="params.html">msiempy.params</a></code></li>
<li><code><a title="msiempy.query" href="query.html">msiempy.query</a></code></li>
<li><code><a title="msiempy.utils" href="utils.html">msiempy.utils</a></code></li>
<li><code><a title="msiempy.watchlist" href="watchlist.html">msiempy.watchlist</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="msiempy.NitroConfig" href="#msiempy.NitroConfig">NitroConfig</a></code></h4>
<ul class="two-column">
<li><code><a title="msiempy.NitroConfig.CONFIG_FILE_NAME" href="#msiempy.NitroConfig.CONFIG_FILE_NAME">CONFIG_FILE_NAME</a></code></li>
<li><code><a title="msiempy.NitroConfig.CONF_DIR" href="#msiempy.NitroConfig.CONF_DIR">CONF_DIR</a></code></li>
<li><code><a title="msiempy.NitroConfig.DEFAULT_CONF_DICT" href="#msiempy.NitroConfig.DEFAULT_CONF_DICT">DEFAULT_CONF_DICT</a></code></li>
<li><code><a title="msiempy.NitroConfig.host" href="#msiempy.NitroConfig.host">host</a></code></li>
<li><code><a title="msiempy.NitroConfig.iset" href="#msiempy.NitroConfig.iset">iset</a></code></li>
<li><code><a title="msiempy.NitroConfig.logfile" href="#msiempy.NitroConfig.logfile">logfile</a></code></li>
<li><code><a title="msiempy.NitroConfig.output" href="#msiempy.NitroConfig.output">output</a></code></li>
<li><code><a title="msiempy.NitroConfig.passwd" href="#msiempy.NitroConfig.passwd">passwd</a></code></li>
<li><code><a title="msiempy.NitroConfig.quiet" href="#msiempy.NitroConfig.quiet">quiet</a></code></li>
<li><code><a title="msiempy.NitroConfig.ssl_verify" href="#msiempy.NitroConfig.ssl_verify">ssl_verify</a></code></li>
<li><code><a title="msiempy.NitroConfig.timeout" href="#msiempy.NitroConfig.timeout">timeout</a></code></li>
<li><code><a title="msiempy.NitroConfig.user" href="#msiempy.NitroConfig.user">user</a></code></li>
<li><code><a title="msiempy.NitroConfig.verbose" href="#msiempy.NitroConfig.verbose">verbose</a></code></li>
<li><code><a title="msiempy.NitroConfig.write" href="#msiempy.NitroConfig.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.NitroDict" href="#msiempy.NitroDict">NitroDict</a></code></h4>
<ul class="">
<li><code><a title="msiempy.NitroDict.data_from_id" href="#msiempy.NitroDict.data_from_id">data_from_id</a></code></li>
<li><code><a title="msiempy.NitroDict.json" href="#msiempy.NitroDict.json">json</a></code></li>
<li><code><a title="msiempy.NitroDict.refresh" href="#msiempy.NitroDict.refresh">refresh</a></code></li>
<li><code><a title="msiempy.NitroDict.text" href="#msiempy.NitroDict.text">text</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.NitroError" href="#msiempy.NitroError">NitroError</a></code></h4>
</li>
<li>
<h4><code><a title="msiempy.NitroList" href="#msiempy.NitroList">NitroList</a></code></h4>
<ul class="two-column">
<li><code><a title="msiempy.NitroList.get_text" href="#msiempy.NitroList.get_text">get_text</a></code></li>
<li><code><a title="msiempy.NitroList.json" href="#msiempy.NitroList.json">json</a></code></li>
<li><code><a title="msiempy.NitroList.keys" href="#msiempy.NitroList.keys">keys</a></code></li>
<li><code><a title="msiempy.NitroList.perform" href="#msiempy.NitroList.perform">perform</a></code></li>
<li><code><a title="msiempy.NitroList.refresh" href="#msiempy.NitroList.refresh">refresh</a></code></li>
<li><code><a title="msiempy.NitroList.search" href="#msiempy.NitroList.search">search</a></code></li>
<li><code><a title="msiempy.NitroList.table_colums" href="#msiempy.NitroList.table_colums">table_colums</a></code></li>
<li><code><a title="msiempy.NitroList.text" href="#msiempy.NitroList.text">text</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.NitroObject" href="#msiempy.NitroObject">NitroObject</a></code></h4>
<ul class="">
<li><code><a title="msiempy.NitroObject.NitroJSONEncoder" href="#msiempy.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.NitroObject.json" href="#msiempy.NitroObject.json">json</a></code></li>
<li><code><a title="msiempy.NitroObject.refresh" href="#msiempy.NitroObject.refresh">refresh</a></code></li>
<li><code><a title="msiempy.NitroObject.text" href="#msiempy.NitroObject.text">text</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.NitroSession" href="#msiempy.NitroSession">NitroSession</a></code></h4>
<ul class="two-column">
<li><code><a title="msiempy.NitroSession.BASE_URL" href="#msiempy.NitroSession.BASE_URL">BASE_URL</a></code></li>
<li><code><a title="msiempy.NitroSession.BASE_URL_PRIV" href="#msiempy.NitroSession.BASE_URL_PRIV">BASE_URL_PRIV</a></code></li>
<li><code><a title="msiempy.NitroSession.config" href="#msiempy.NitroSession.config">config</a></code></li>
<li><code><a title="msiempy.NitroSession.executor" href="#msiempy.NitroSession.executor">executor</a></code></li>
<li><code><a title="msiempy.NitroSession.logout" href="#msiempy.NitroSession.logout">logout</a></code></li>
<li><code><a title="msiempy.NitroSession.request" href="#msiempy.NitroSession.request">request</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
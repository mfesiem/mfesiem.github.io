<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>msiempy API documentation</title>
<meta name="description" content=".. image:: https://avatars0.githubusercontent.com/u/50667087?s=200&amp;v=4
Welcome to the **msiempy** module documentation. The pythonic way to deal â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>msiempy</code></h1>
</header>
<section id="section-intro">
<p><img alt="" src="https://avatars0.githubusercontent.com/u/50667087?s=200&amp;v=4"></p>
<p>Welcome to the <strong>msiempy</strong> module documentation. The pythonic way to deal with McAfee SIEM API.<br>
Classes listed here are mostly handling low level interactions with the SIEM API. It provides a simple interface to other sub-modules that offers concrete objects and functions.
</p>
<hr>
<p>GitHub : <a href="https://github.com/mfesiem/msiempy">https://github.com/mfesiem/msiempy</a><br>
PyPI : <a href="https://pypi.org/project/msiempy/">https://pypi.org/project/msiempy/</a><br>
Class diagram : <a href="https://mfesiem.github.io/docs/msiempy/classes.png">https://mfesiem.github.io/docs/msiempy/classes.png</a><br>
Packages diagram : <a href="https://mfesiem.github.io/docs/msiempy/packages.png">https://mfesiem.github.io/docs/msiempy/packages.png</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
.. image:: https://avatars0.githubusercontent.com/u/50667087?s=200&amp;v=4  
Welcome to the **msiempy** module documentation. The pythonic way to deal with McAfee SIEM API.  
Classes listed here are mostly handling low level interactions with the SIEM API. It provides a simple interface to other sub-modules that offers concrete objects and functions.  

***

GitHub : https://github.com/mfesiem/msiempy  
PyPI : https://pypi.org/project/msiempy/  
Class diagram : https://mfesiem.github.io/docs/msiempy/classes.png  
Packages diagram : https://mfesiem.github.io/docs/msiempy/packages.png  
&#34;&#34;&#34;

import logging
import requests
import json
import ast
import re
import urllib.parse
import urllib3
import configparser
import os
import getpass
import abc
import collections
import tqdm
import copy
import csv
import sys
import concurrent.futures
import prettytable
from prettytable import MSWORD_FRIENDLY
import datetime
import functools
import textwrap
import inspect
import time

from io import StringIO
from .__utils__ import regex_match, tob64, format_esm_time, convert_to_time_obj, timerange_gettimes, parse_timedelta, divide_times

try :
    requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
except : pass

logging.getLogger(&#34;urllib3&#34;).setLevel(logging.WARNING)
log = logging.getLogger(&#39;msiempy&#39;)

__pdoc__={} #Init pdoc overwrite engine to document stuff dynamically

class NitroConfig(configparser.ConfigParser):
    &#34;&#34;&#34;

    Handles the configuration. Reads the config file `.msiem/conf.ini` where ever it is and make accessible it&#39;s values throught object properties. 
    If a `.msiem/` directory exists in your current directory, the program will assume the `conf.ini` file is there, if not, it will create it with default values. 
    Secondly, if no `.msiem/` directory exists in the current directory, it will be automatically placed in a appropriate place depending of your platform:  

    Default configuration file should look like this. Authentication is left empty.
    ```
    [esm]
    host = 
    user = 
    passwd = 

    [general]
    verbose = False
    quiet = False
    logfile = 
    timeout = 60
    ssl_verify = False
    ```

    For Windows: `%APPDATA%\.msiem\conf.ini`  
    For Mac : `$HOME/.msiem/conf.ini`  
    For Linux : `$XDG_CONFIG_HOME/.msiem/conf.ini` or : `$HOME/.msiem/conf.ini`  
    If `.msiem` folder exists in you local directory : `./.msiem/conf.ini`  

    You can setup the configuration by command line with `msiempy_setup.py` script at https://github.com/mfesiem/msiempy/blob/master/samples/msiempy_setup.py.  
    

    Arguments: 

    - `path`: Config file special path, if path is left None, will automatically look for it.  
    - `config`: Manual config dict. ex: `{&#39;general&#39;:{&#39;verbose&#39;:True}}`.  
    - `*args, **kwargs` : Passed to `configparser.ConfigParser.__init__()` method.

    &#34;&#34;&#34;
    def __init__(self, path=None, config=None, *arg, **kwarg):
        super().__init__(*arg, **kwarg)
        if not path : self._path = self.find_ini_location()
        else : self._path = path
        files=self.read(self._path)
        if len(files) == 0:
            log.info(&#34;Config file inexistant or currupted, applying defaults&#34;)
            self.read_dict(self.DEFAULT_CONF_DICT)
            if not os.path.exists(os.path.dirname(self._path)):
                os.makedirs(os.path.dirname(self._path))
            self.write()
        else:
            log.info(&#34;Successfuly read config file {}&#34;.format(files[0]))
        if config != None :
            log.info(&#34;Reading config_dict : &#34;+str(self))
            self.read_dict(config)

    CONFIG_FILE_NAME=&#39;.msiem/conf.ini&#39;
    &#34;&#34;&#34;`.msiem/conf.ini`&#34;&#34;&#34;

    CONF_DIR=&#39;.msiem/&#39;
    &#34;&#34;&#34;`.msiem/`&#34;&#34;&#34;

    DEFAULT_CONF_DICT={
        &#39;esm&#39;:{&#39;host&#39;:&#39;&#39;, 
            &#39;user&#39;:&#39;&#39;,
            &#39;passwd&#39;:&#39;&#39;},
        &#39;general&#39;:{&#39;verbose&#39;:False,
            &#39;quiet&#39;:False,
            &#39;logfile&#39;:&#39;&#39;,
            &#39;timeout&#39;:60,
            &#39;ssl_verify&#39;:False}
    }
    &#34;&#34;&#34;
    Default configuration values.
    &#34;&#34;&#34;

    def __str__(self):
        &#34;&#34;&#34;
        Custom str() method that lists all config fields.
        &#34;&#34;&#34;
        return(&#39;Configuration file : &#39;+ self._path+&#39;\n&#39;+str({section: dict(self[section]) for section in self.sections()}))

    def write(self):
        &#34;&#34;&#34;Write the config file to the predetermined path.
        &#34;&#34;&#34;
        with open(self._path, &#39;w&#39;) as conf:
            super().write(conf)
            log.info(&#34;Config file has been written at &#34;+self._path)

    def _iset(self, section, option, secure=False):
        &#34;&#34;&#34;Internal method to interactively set  a option in a section.
        &#34;&#34;&#34;
        msg=&#39;Enter [{}]{}&#39;
        value = self.get(section, option)
        newvalue=&#39;&#39;
        if option==&#39;passwd&#39;: secure=True
        if secure : newvalue = tob64(getpass.getpass(msg.format(section, option)+&#39;. Press &lt;Enter&gt; to skip: &#39;))
        else: newvalue = input(msg.format(section, option)+ &#39;. Press &lt;Enter&gt; to keep &#39;+ (value if (str(value) != &#39;&#39;) else &#39;empty&#39;) + &#39;: &#39;)
        if newvalue != &#39;&#39; : super().set(section, option, newvalue)

    def iset(self, section, option=None, secure=False):
        &#34;&#34;&#34;Interactively set the specified section/option by asking the user the input.  
        Arguments:  

        - `section`: Configuration&#39;s section. Exemple : &#39;esm&#39; or &#39;general&#39;.  
        - `option`: Configuraion&#39;s option. Leave to `None` to set the whole section one after another. Exemple : &#39;user&#39;, &#39;timeout&#39;.  
        - `secure`: Will use getpass to retreive the configuration value and won&#39;t print old value.
        &#34;&#34;&#34;
        if option is None :
            for key in self.options(section):
                self._iset(section, key, secure)
        else : self._iset(section, option, secure)

    @property
    def user(self): return self.get(&#39;esm&#39;, &#39;user&#39;)
    @property
    def host(self): return self.get(&#39;esm&#39;, &#39;host&#39;)
    @property
    def passwd(self): return self.get(&#39;esm&#39;, &#39;passwd&#39;)
    @property
    def verbose(self): return self.getboolean(&#39;general&#39;, &#39;verbose&#39;)
    @property
    def quiet(self): return self.getboolean(&#39;general&#39;, &#39;quiet&#39;)
    @property
    def logfile(self): return self.get(&#39;general&#39;, &#39;logfile&#39;)
    @property
    def timeout(self): return self.getint(&#39;general&#39;, &#39;timeout&#39;)
    @property
    def ssl_verify(self): return self.getboolean(&#39;general&#39;, &#39;ssl_verify&#39;)

    @staticmethod
    def find_ini_location():
        &#39;&#39;&#39;
        Returns the location of a supposed conf.ini file the `conf.ini` file.  
        If `.msiem` folder exists in you local directory, assume the `conf.ini` file is in there.  
        If the file doesn&#39;t exist, will still return the location.  
        Do not create a file nor directory, you must call `msiempy.NitroConfig.write`.  
        &#39;&#39;&#39;
        conf_path_dir=None
        if os.path.isdir(&#39;./&#39;+NitroConfig.CONF_DIR): conf_path_dir=&#39;./&#39;
        elif &#39;APPDATA&#39; in os.environ: conf_path_dir = os.environ[&#39;APPDATA&#39;]
        elif &#39;XDG_CONFIG_HOME&#39; in os.environ: conf_path_dir = os.environ[&#39;XDG_CONFIG_HOME&#39;]
        elif &#39;HOME&#39; in os.environ: conf_path_dir = os.path.join(os.environ[&#39;HOME&#39;])
        else: conf_path_dir=&#39;./&#39;
        #Join configuartion filename with supposed parent directory
        conf_path=(os.path.join(conf_path_dir, NitroConfig.CONFIG_FILE_NAME))
        return(conf_path)

class NitroSession():
    &#34;&#34;&#34;
    `msiempy.NitroSession` is the point of convergence of every request to the McAfee ESM.  
    It provides standard dialogue with the ESM by doing agument interpolation with `msiempy.NitroSession.PARAMS`.  
    Internal `__dict__` refers to a unique instance of dict and thus, properties can be instanciated only once.  
    It uses `msiempy.NitroConfig` to setup authentication, other configuration like verbosity, logfile, general timeout, are offered throught the config file.

    The init method is called every time you call NitroSession() constructor. But the properties are actually initiated only once.  
    Use `logout()` to reinstanciate NitroSession.  

    Arguments:  

    - `conf_path` : Configuration file path.  
    - `conf_dict` : Manual config dict. ex: `{&#39;general&#39;:{&#39;verbose&#39;:True}}`. See `msiempy.NitroConfig` class to have full details.

    Usages:
    ```

    ```
    &#34;&#34;&#34;
    def __init__(self, conf_path=None, conf_dict=None):
        global log
        self.__dict__ = NitroSession.__unique_state__
        
        #Init properties only once
        if NitroSession.__initiated__ == False :
            NitroSession.__initiated__ = True
            
            #Private attributes
            self._headers={&#39;Content-Type&#39;: &#39;application/json&#39;}
            
            #Config parsing
            self.config = NitroConfig(path=conf_path, config=conf_dict)
            NitroSession.config=self.config

            #Set the logging configuration
            self._init_log(verbose=self.config.verbose,
                quiet=self.config.quiet,
                logfile=self.config.logfile)

            self.api_v = 0
            self.logged_in=False
            self.login_info=dict()

    

    BASE_URL = &#39;https://{}/rs/esm/&#39;
    &#34;&#34;&#34;API v2 base url: &#39;https://{}/rs/esm/&#39;&#34;&#34;&#34;

    BASE_URL_PRIV = &#39;https://{}/ess/&#39;
    &#34;&#34;&#34;Private API base URL: &#39;https://{}/ess/&#39;&#34;&#34;&#34;

    __initiated__ = False
    &#34;&#34;&#34;
    Weither the session has been intaciated. It&#39;s supposed to be a singleton.
    &#34;&#34;&#34;
    __unique_state__ = {}
    &#34;&#34;&#34;
    The singleton unique state.
    &#34;&#34;&#34;
    
    config = None
    &#34;&#34;&#34;
    `msiempy.NitroConfig` object.  
    &#34;&#34;&#34;
    
    PARAMS = {
        &#34;login&#34;: (&#34;login&#34;,
                &#34;&#34;&#34;{&#34;username&#34;: &#34;%(username)s&#34;,
                    &#34;password&#34; : &#34;%(password)s&#34;,
                    &#34;locale&#34;: &#34;en_US&#34;,
                    &#34;os&#34;: &#34;Win32&#34;}
                    &#34;&#34;&#34;),

        &#34;get_devtree&#34;: (&#34;GRP_GETVIRTUALGROUPIPSLISTDATA&#34;,
                        &#34;&#34;&#34;{&#34;ITEMS&#34;: &#34;#{DC1 + DC2}&#34;,
                            &#34;DID&#34;: &#34;1&#34;,
                            &#34;HD&#34;: &#34;F&#34;,
                            &#34;NS&#34;: &#34;0&#34;}
                        &#34;&#34;&#34;),

        &#34;get_zones_devtree&#34;: (&#34;GRP_GETVIRTUALGROUPIPSLISTDATA&#34;,
                        &#34;&#34;&#34;{&#34;ITEMS&#34;: &#34;#{DC1 + DC2}&#34;,
                            &#34;DID&#34;: &#34;3&#34;,
                            &#34;HD&#34;: &#34;F&#34;,
                            &#34;NS&#34;: &#34;0&#34;}
                        &#34;&#34;&#34;),

        &#34;req_client_str&#34;: (&#34;DS_GETDSCLIENTLIST&#34;,
                            &#34;&#34;&#34;{&#34;DSID&#34;: &#34;%(ds_id)s&#34;,
                                &#34;SEARCH&#34;: &#34;&#34;}
                            &#34;&#34;&#34;),

        &#34;get_rfile&#34;: (&#34;MISC_READFILE&#34;,
                    &#34;&#34;&#34;{&#34;FNAME&#34;: &#34;%(ftoken)s&#34;,
                    &#34;SPOS&#34;: &#34;0&#34;,
                    &#34;NBYTES&#34;: &#34;0&#34;}
                    &#34;&#34;&#34;),

        &#34;del_rfile&#34;: (&#34;ESSMGT_DELETEFILE&#34;,
                    &#34;&#34;&#34;{&#34;FN&#34;: &#34;%(ftoken)s&#34;}&#34;&#34;&#34;),

        &#34;get_rfile2&#34;: (&#34;MISC_READFILE&#34;,
                    &#34;&#34;&#34;{&#34;FNAME&#34;: &#34;%(ftoken)s&#34;,
                    &#34;SPOS&#34;: &#34;%(pos)s&#34;,
                    &#34;NBYTES&#34;: &#34;%(nbytes)s&#34;}
                    &#34;&#34;&#34;),

        &#34;get_wfile&#34;: (&#34;MISC_WRITEFILE&#34;,
                    &#34;&#34;&#34;{&#34;DATA1&#34;: &#34;%(ds_id)s&#34;,
                         &#34;PATH&#34;: &#34;21&#34;,
                         &#34;ND&#34;: &#34;1&#34;} &#34;&#34;&#34;),
        
        &#34;get_rule_history&#34;: (&#34;PLCY_GETRULECHANGEINFO&#34;, 
                            &#34;&#34;&#34;{&#34;SHOW&#34;: &#34;F&#34;}&#34;&#34;&#34;),

        &#34;map_dtree&#34;: (&#34;map_dtree&#34;,
                    &#34;&#34;&#34;{&#34;dev_type&#34;: &#34;%(dev_type)s&#34;,
                    &#34;name&#34;: &#34;%(ds_name)s&#34;,
                    &#34;ds_id&#34;: &#34;%(ds_id)s&#34;,
                    &#34;enabled&#34;: &#34;%(enabled)s&#34;,
                    &#34;ds_ip&#34;: &#34;%(ds_ip)s&#34;,
                    &#34;hostname&#34; : &#34;%(hostname)s&#34;,
                    &#34;typeID&#34;: &#34;%(type_id)s&#34;,
                    &#34;vendor&#34;: &#34;&#34;,
                    &#34;model&#34;: &#34;&#34;,
                    &#34;tz_id&#34;: &#34;&#34;,
                    &#34;date_order&#34;: &#34;&#34;,
                    &#34;port&#34;: &#34;&#34;,
                    &#34;syslog_tls&#34;: &#34;&#34;,
                    &#34;client_groups&#34;: &#34;%(client_groups)s&#34;
                    }
                    &#34;&#34;&#34;),

        &#34;add_ds_11_1_3&#34;: (&#34;dsAddDataSource&#34;, 
                    &#34;&#34;&#34;{&#34;datasource&#34;: {
                            &#34;parentId&#34;: {&#34;id&#34;: &#34;%(parent_id)s&#34;},
                            &#34;name&#34;: &#34;%(name)s&#34;,
                            &#34;ipAddress&#34;: &#34;%(ds_ip)s&#34;,
                            &#34;typeId&#34;: {&#34;id&#34;: &#34;%(type_id)s&#34;},
                            &#34;zoneId&#34;: &#34;%(zone_id)s&#34;,
                            &#34;enabled&#34;: &#34;%(enabled)s&#34;,
                            &#34;url&#34;: &#34;%(url)s&#34;,
                            &#34;id&#34;: {&#34;id&#34;: &#34;%(ds_id)s&#34;},
                            &#34;childEnabled&#34;: &#34;%(child_enabled)s&#34;,
                            &#34;childCount&#34;: &#34;%(child_count)s&#34;,
                            &#34;childType&#34;: &#34;%(child_type)s&#34;,
                            &#34;idmId&#34;: &#34;%(idm_id)s&#34;,
                            &#34;parameters&#34;: %(parameters)s
                        }}&#34;&#34;&#34;),

        &#34;add_ds_11_2_1&#34;: (&#34;dsAddDataSources&#34;, 
                        &#34;&#34;&#34;{&#34;receiverId&#34;: &#34;%(parent_id)s&#34;,
                            &#34;datasources&#34;: [{
                                &#34;name&#34;: &#34;%(name)s&#34;,
                                &#34;ipAddress&#34;: &#34;%(ds_ip)s&#34;,
                                &#34;typeId&#34;: {&#34;id&#34;: &#34;%(type_id)s&#34;},
                                &#34;zoneId&#34;: &#34;%(zone_id)s&#34;,
                                &#34;enabled&#34;: &#34;%(enabled)s&#34;,
                                &#34;url&#34;: &#34;%(url)s&#34;,
                                &#34;parameters&#34;: %(parameters)s
                                }]}&#34;&#34;&#34;),

        &#34;add_client1&#34;: (&#34;DS_ADDDSCLIENT&#34;, 
                        &#34;&#34;&#34;{&#34;PID&#34;: &#34;%(parent_id)s&#34;,
                        &#34;NAME&#34;: &#34;%(name)s&#34;,
                        &#34;ENABLED&#34;: &#34;%(enabled)s&#34;,
                        &#34;IP&#34;: &#34;%(ds_ip)s&#34;,
                        &#34;HOST&#34;: &#34;%(hostname)s&#34;,
                        &#34;TYPE&#34;: &#34;%(type_id)s&#34;,
                        &#34;TZID&#34;: &#34;%(tz_id)s&#34;,
                        &#34;DORDER&#34;: &#34;%(dorder)s&#34;,
                        &#34;MASKFLAG&#34;: &#34;%(maskflag)s&#34;,
                        &#34;PORT&#34;: &#34;%(port)s&#34;,
                        &#34;USETLS&#34;: &#34;%(require_tls)s&#34;
                        }&#34;&#34;&#34;),
                        
        &#34;get_recs&#34;: (&#34;devGetDeviceList?filterByRights=false&#34;,
                        &#34;&#34;&#34;{&#34;types&#34;: [&#34;RECEIVER&#34;]}
                        &#34;&#34;&#34;),

        &#34;get_dstypes&#34;: (&#34;dsGetDataSourceTypes&#34;,
                        &#34;&#34;&#34;{&#34;receiverId&#34;: {&#34;id&#34;: &#34;%(rec_id)s&#34;}
                            }
                        &#34;&#34;&#34;),
                        
        &#34;del_ds1&#34;: (&#34;dsDeleteDataSource&#34;,
                    &#34;&#34;&#34;{&#34;receiverId&#34;: {&#34;id&#34;: &#34;%(parent_id)s&#34;},
                        &#34;datasourceId&#34;: {&#34;id&#34;: &#34;%(ds_id)s&#34;}}
                    &#34;&#34;&#34;),

        &#34;del_ds2&#34;: (&#34;dsDeleteDataSources&#34;,
                    &#34;&#34;&#34;{&#34;receiverId&#34;: {&#34;value&#34;: &#34;%(parent_id)s&#34;},
                        &#34;datasourceIds&#34;: [{&#34;value&#34;: &#34;%(ds_id)s&#34;}]}
                    &#34;&#34;&#34;),

        &#34;del_client&#34;: (&#34;DS_DELETEDSCLIENTS&#34;, 
                        &#34;&#34;&#34;{&#34;DID&#34;: &#34;%(parent_id)s&#34;,
                             &#34;FTOKEN&#34;: &#34;%(ftoken)s&#34;}&#34;&#34;&#34;
                        ),

        &#34;get_job_status&#34;: (&#34;MISC_JOBSTATUS&#34;,
                            &#34;&#34;&#34;{&#34;JID&#34;: &#34;%(job_id)s&#34;}&#34;&#34;&#34;),

        &#34;ds_last_times&#34;: (&#34;QRY_GETDEVICELASTALERTTIME&#34;,&#34;&#34;&#34;{}&#34;&#34;&#34;),
                        
        &#34;zonetree&#34;: (&#34;zoneGetZoneTree&#34;,None),
                        
        &#34;ds_by_type&#34;: (&#34;QRY_GETDEVICECOUNTBYTYPE&#34;,None),

        &#34;_dev_types&#34;:  (&#34;dev_type_map&#34;,
                            &#34;&#34;&#34;{&#34;1&#34;: &#34;zone&#34;,
                                &#34;2&#34;: &#34;ERC&#34;,
                                &#34;3&#34;: &#34;datasource&#34;,
                                &#34;4&#34;: &#34;Database Event Monitor (DBM)&#34;,
                                &#34;5&#34;: &#34;DBM Database&#34;,
                                &#34;7&#34;: &#34;Policy Auditor&#34;,
                                &#34;10&#34;: &#34;Application Data Monitor (ADM)&#34;,
                                &#34;12&#34;: &#34;ELM&#34;,
                                &#34;14&#34;: &#34;Local ESM&#34;,
                                &#34;15&#34;: &#34;Advanced Correlation Engine (ACE)&#34;,
                                &#34;16&#34;: &#34;Asset datasource&#34;,
                                &#34;17&#34;: &#34;Score-based Correlation&#34;,
                                &#34;19&#34;: &#34;McAfee ePolicy Orchestrator (ePO)&#34;,
                                &#34;20&#34;: &#34;EPO&#34;,
                                &#34;21&#34;: &#34;McAfee Network Security Manager (NSM)&#34;,
                                &#34;22&#34;: &#34;McAfee Network Security Platform (NSP)&#34;,
                                &#34;23&#34;: &#34;NSP Port&#34;,
                                &#34;24&#34;: &#34;McAfee Vulnerability Manager (MVM)&#34;,
                                &#34;25&#34;: &#34;Enterprise Log Search (ELS)&#34;,
                                &#34;254&#34;: &#34;client_group&#34;,
                                &#34;256&#34;: &#34;client&#34;}
                            &#34;&#34;&#34;),
                            
            &#34;ds_details1&#34;: (&#34;dsGetDataSourceDetail&#34;,
                            &#34;&#34;&#34;{&#34;datasourceId&#34;: 
                                {&#34;id&#34;: &#34;%(ds_id)s&#34;}}
                            &#34;&#34;&#34;),

            &#34;ds_details2&#34;: (&#34;dsGetDataSourceDetail&#34;,
                            &#34;&#34;&#34;{&#34;datasourceId&#34;: {&#34;value&#34;: &#34;%(ds_id)s&#34;}}&#34;&#34;&#34;),


            &#34;get_alarms_custom_time&#34;: (&#34;&#34;&#34;alarmGetTriggeredAlarms?triggeredTimeRange=%(time_range)s&amp;customStart=%(start_time)s&amp;customEnd=%(end_time)s&amp;status=%(status)s&amp;pageSize=%(page_size)s&amp;pageNumber=%(page_number)s&#34;&#34;&#34;,
                        None),

            &#34;get_alarms&#34;: (&#34;&#34;&#34;alarmGetTriggeredAlarms?triggeredTimeRange=%(time_range)s&amp;status=%(status)s&amp;pageSize=%(page_size)s&amp;pageNumber=%(page_number)s&#34;&#34;&#34;, None),

            &#34;get_alarm_details&#34;: (&#34;&#34;&#34;notifyGetTriggeredNotification&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;id&#34;:%(id)s}&#34;&#34;&#34;),

            &#34;get_alarm_details_int&#34;: (&#34;NOTIFY_GETTRIGGEREDNOTIFICATIONDETAIL&#34;, 
                                        &#34;&#34;&#34;{&#34;TID&#34;: &#34;%(id)s&#34;}&#34;&#34;&#34;),

            &#34;ack_alarms&#34;: (&#34;&#34;&#34;alarmAcknowledgeTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:[{&#34;value&#34;:%(ids)s}]}&#34;&#34;&#34;),

            &#34;ack_alarms_11_2_1&#34;: (&#34;&#34;&#34;alarmAcknowledgeTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:{&#34;alarmIdList&#34;:[%(ids)s]}}&#34;&#34;&#34;),

            &#34;unack_alarms&#34;: (&#34;&#34;&#34;alarmUnacknowledgeTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:[{&#34;value&#34;:%(ids)s}]}&#34;&#34;&#34;),

            &#34;unack_alarms_11_2_1&#34;: (&#34;&#34;&#34;alarmUnacknowledgeTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:{&#34;alarmIdList&#34;:[%(ids)s]}}&#34;&#34;&#34;),

            &#34;delete_alarms&#34;: (&#34;&#34;&#34;alarmDeleteTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:[{&#34;value&#34;:%(ids)s}]}&#34;&#34;&#34;),
            
            &#34;delete_alarms_11_2_1&#34;: (&#34;&#34;&#34;alarmDeleteTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:{&#34;alarmIdList&#34;:[%(ids)s]}}&#34;&#34;&#34;),

            &#34;get_possible_filters&#34; : ( &#34;&#34;&#34;qryGetFilterFields&#34;&#34;&#34;, None ),

            &#34;get_possible_fields&#34; : ( &#34;&#34;&#34;qryGetSelectFields?type=%(type)s&amp;groupType=%(groupType)s&#34;&#34;&#34;, None ),

            &#34;get_esm_time&#34; : ( &#34;&#34;&#34;essmgtGetESSTime&#34;&#34;&#34;,None),

            &#34;get_alerts_now&#34; : (&#34;&#34;&#34;IPS_GETALERTSNOW&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;IPSID&#34;: &#34;%(ds_id)s&#34;}&#34;&#34;&#34;),

            &#34;get_flows_now&#34; : (&#34;&#34;&#34;IPS_GETALERTSNOW&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;IPSID&#34;: &#34;%(ds_id)s&#34;}&#34;&#34;&#34;),

            &#34;logout&#34; : ( &#34;&#34;&#34;userLogout&#34;&#34;&#34;, None ),

            &#34;get_user_locale&#34; : ( &#34;&#34;&#34;getUserLocale&#34;&#34;&#34;, None ),

            &#34;event_query_custom_time&#34; : (&#34;&#34;&#34;qryExecuteDetail?type=EVENT&amp;reverse=false&#34;&#34;&#34;, &#34;&#34;&#34;{
                    &#34;config&#34;: {
                        &#34;timeRange&#34;: &#34;%(time_range)s&#34;,
                        &#34;customStart&#34;: &#34;%(start_time)s&#34;,
                        &#34;customEnd&#34;: &#34;%(end_time)s&#34;,
                        &#34;fields&#34;: %(fields)s,
                        &#34;filters&#34;: %(filters)s,
                        &#34;limit&#34;: %(limit)s,
                        &#34;offset&#34;: %(offset)s,
                        &#34;order&#34;: [{&#34;field&#34;: {&#34;name&#34;: &#34;%(order_field)s&#34;},
                                             &#34;direction&#34;: &#34;%(order_direction)s&#34;}]
                        }
                        }&#34;&#34;&#34;),

            &#34;event_query&#34; : (&#34;&#34;&#34;qryExecuteDetail?type=EVENT&amp;reverse=false&#34;&#34;&#34;, &#34;&#34;&#34;{
                    &#34;config&#34;: {
                        &#34;timeRange&#34;:&#34;%(time_range)s&#34;,
                        &#34;fields&#34;:%(fields)s,
                        &#34;filters&#34;:%(filters)s,
                        &#34;limit&#34;:%(limit)s,
                        &#34;offset&#34;:%(offset)s,
                        &#34;order&#34;: [{&#34;field&#34;: {&#34;name&#34;: &#34;%(order_field)s&#34;},
                                             &#34;direction&#34;: &#34;%(order_direction)s&#34;}]
                        }
                        }&#34;&#34;&#34;),

            &#34;query_status&#34; : (&#34;&#34;&#34;qryGetStatus&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;resultID&#34;: %(resultID)s}&#34;&#34;&#34;),

            &#34;query_result&#34; : (&#34;&#34;&#34;qryGetResults?startPos=%(startPos)s&amp;numRows=%(numRows)s&amp;reverse=false&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;resultID&#34;: %(resultID)s}&#34;&#34;&#34;),
            
            &#34;time_zones&#34; : (&#34;&#34;&#34;userGetTimeZones&#34;&#34;&#34;, None),

            &#34;logout&#34; : (&#34;&#34;&#34;logout&#34;&#34;&#34;, None),
            
            &#34;add_note_to_event&#34; : (&#34;&#34;&#34;ipsAddAlertNote&#34;&#34;&#34;, &#34;&#34;&#34;{
                &#34;id&#34;: {&#34;value&#34;: &#34;%(id)s&#34;},
                &#34;note&#34;: {&#34;note&#34;: &#34;%(note)s&#34;}
            }&#34;&#34;&#34;),

            &#34;add_note_to_event_int&#34;: (&#34;&#34;&#34;IPS_ADDALERTNOTE&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;AID&#34;: &#34;%(id)s&#34;,
                                                               &#34;NOTE&#34;: &#34;%(note)s&#34;}&#34;&#34;&#34;),

            &#34;get_wl_types&#34;: (&#34;&#34;&#34;sysGetWatchlistFields&#34;&#34;&#34;, None),
            &#34;get_watchlists_no_filters&#34; : (&#34;&#34;&#34;sysGetWatchlists?hidden=%(hidden)s&amp;dynamic=%(dynamic)s&amp;writeOnly=%(writeOnly)s&amp;indexedOnly=%(indexedOnly)s&#34;&#34;&#34;, 
                None),

            &#34;get_watchlist_details&#34;: (&#34;&#34;&#34;sysGetWatchlistDetails&#34;&#34;&#34;,&#34;&#34;&#34;{&#34;id&#34;: %(id)s}&#34;&#34;&#34;),

            &#34;add_watchlist&#34;: (&#34;&#34;&#34;sysAddWatchlist&#34;&#34;&#34;, &#34;&#34;&#34;{
                &#34;watchlist&#34;: {
                    &#34;name&#34;: &#34;%(name)s&#34;,
                    &#34;type&#34;: {&#34;name&#34;: &#34;%(wl_type)s&#34;,
                              &#34;id&#34;: 0},
                    &#34;customType&#34;: {&#34;name&#34;: &#34;&#34;,
                                   &#34;id&#34;: 0},
                    &#34;dynamic&#34;: &#34;False&#34;,
                    &#34;enabled&#34;: &#34;True&#34;,
                    &#34;search&#34;: &#34;&#34;,
                    &#34;source&#34;: 0,
                    &#34;updateType&#34;: &#34;EVERY_SO_MANY_MINUTES&#34;,
                    &#34;updateDay&#34;: 0,
                    &#34;updateMin&#34;: 0,
                    &#34;ipsid&#34;: &#34;0&#34;,
                    &#34;valueFile&#34;: {&#34;fileToken&#34;: &#34;&#34;},
                    &#34;dbUrl&#34;: &#34;&#34;,
                    &#34;mountPoint&#34;: &#34;&#34;,    
                    &#34;path&#34;: &#34;&#34;,
                    &#34;port&#34;: &#34;22&#34;,
                    &#34;username&#34;: &#34;&#34;,
                    &#34;password&#34;: &#34;&#34;,
                    &#34;query&#34;: &#34;&#34;,
                    &#34;lookup&#34;: &#34;&#34;,
                    &#34;jobTrackerURL&#34;: &#34;&#34;,
                    &#34;jobTrackerPort&#34;: &#34;&#34;,
                    &#34;postArgs&#34;: &#34;&#34;,
                    &#34;ignoreRegex&#34;: &#34;&#34;,
                    &#34;method&#34;: 0,
                    &#34;matchRegex&#34;: &#34;&#34;,
                    &#34;lineSkip&#34;: 0,
                    &#34;delimitRegex&#34;: &#34;&#34;,
                    &#34;groups&#34;: 1
                              }}&#34;&#34;&#34;),
                                                            
            &#34;add_watchlist_values&#34;: (&#34;&#34;&#34;sysAddWatchlistValues&#34;&#34;&#34;,&#34;&#34;&#34;{
                &#34;watchlist&#34;: %(watchlist)s,
                &#34;values&#34;: %(values)s,
                }&#34;&#34;&#34;),

            &#34;get_watchlist_values&#34;: (&#34;SYS_GETWATCHLISTDETAILS&#34;,
                                            &#34;&#34;&#34;{&#34;WID&#34;: &#34;%(id)s&#34;, &#34;LIM&#34;: &#34;T&#34;}&#34;&#34;&#34;),

            &#34;remove_watchlists&#34;: (&#34;&#34;&#34;sysRemoveWatchlist&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;ids&#34;: {&#34;watchlistIdList&#34;: [&#34;%(wl_id_list)s&#34;]}}&#34;&#34;&#34;),

            &#34;get_alert_data&#34;: (&#34;&#34;&#34;ipsGetAlertData&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;id&#34;: {&#34;value&#34;:&#34;%(id)s&#34;}}&#34;&#34;&#34;),
            
            &#34;get_sys_info&#34;  : (&#34;SYS_GETSYSINFO&#34;,&#34;&#34;&#34;{}&#34;&#34;&#34;),
            
            &#34;build_stamp&#34; : (&#34;essmgtGetBuildStamp&#34;,None)
    } #__pdoc__[&#39;NitroSession.PARAMS&#39;] = 
    &#39;&#39;&#39;This structure provide a central place to aggregate API methods and parameters.  
    The parameters are stored as docstrings to support string replacement.  

    Args:  
        - `method` (str): Dict key associated with desired function
        Use normal dict access, PARAMS[&#34;method&#34;], or PARAMS.get(&#34;method&#34;)

    Returns:  
        - `tuple `: (string, string) : The first string is the method name that is actually used as
        the URI or passed to the ESM. The second string is the params
        required for that method. Some params require variables be
        interpolated as documented in the data structure.
    
    Usage exemple in `msiempy.NitroSession.request` source code.  

    Important note : 
        Do not use sigle quotes (`&#39;`) to delimit data into the interpolated strings !

    Data structure example :  
    ```
    {
        &#34;login&#34;: (&#34;login&#34;,
                &#34;&#34;&#34;{&#34;username&#34;: &#34;%(username)s&#34;,
                    &#34;password&#34; : &#34;%(password)s&#34;,
                    &#34;locale&#34;: &#34;en_US&#34;,
                    &#34;os&#34;: &#34;Win32&#34;}
                    &#34;&#34;&#34;),
        
        &#34;add_watchlist_values&#34;: (&#34;&#34;&#34;sysAddWatchlistValues&#34;&#34;&#34;,&#34;&#34;&#34;{
                &#34;watchlist&#34;: %(watchlist)s,
                &#34;values&#34;: %(values)s,
                }&#34;&#34;&#34;),

        &#34;get_watchlist_values&#34;: (&#34;SYS_GETWATCHLISTDETAILS&#34;,
                                        &#34;&#34;&#34;{&#34;WID&#34;: &#34;%(id)s&#34;, &#34;LIM&#34;: &#34;T&#34;}&#34;&#34;&#34;),

        &#34;remove_watchlists&#34;: (&#34;&#34;&#34;sysRemoveWatchlist&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;ids&#34;: {&#34;watchlistIdList&#34;: [&#34;%(wl_id_list)s&#34;]}}&#34;&#34;&#34;),

        &#34;get_alert_data&#34;: (&#34;&#34;&#34;ipsGetAlertData&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;id&#34;: {&#34;value&#34;:&#34;%(id)s&#34;}}&#34;&#34;&#34;),
        
        &#34;get_sys_info&#34;  : (&#34;SYS_GETSYSINFO&#34;,&#34;&#34;&#34;{}&#34;&#34;&#34;),
        
        &#34;build_stamp&#34; : (&#34;essmgtGetBuildStamp&#34;,None),

        &#34;event_query&#34; : (&#34;&#34;&#34;qryExecuteDetail?type=EVENT&amp;reverse=false&#34;&#34;&#34;, &#34;&#34;&#34;{
                    &#34;config&#34;: {
                        &#34;timeRange&#34;:&#34;%(time_range)s&#34;,
                        &#34;fields&#34;:%(fields)s,
                        &#34;filters&#34;:%(filters)s,
                        &#34;limit&#34;:%(limit)s,
                        &#34;offset&#34;:%(offset)s,
                        &#34;order&#34;: [{&#34;field&#34;: {&#34;name&#34;: &#34;%(order_field)s&#34;}, &#34;direction&#34;: &#34;%(order_direction)s&#34;}]
                        }}&#34;&#34;&#34;),

       [...]
    }
    ```  
    Please see `dump_api_params.py` script at https://github.com/mfesiem/msiempy/blob/master/samples/dump_api_params.py to dump the complete structure.
    &#39;&#39;&#39;

    #% dict(content=pprint.pformat(PARAMS)[:3000]) + &#34;&#34;&#34; [...] and more, please consult source code.&#34;&#34;&#34;
        
    def __str__(self):
        return repr(self.__unique_state__) 

    def login(self, retry=1):
        &#34;&#34;&#34;Authentication is done lazily upon the first call to `msiempy.NitroSession.request` method, but you can still do it manually by calling this method.  
        Throws `msiempy.NitroError` if login fails
        &#34;&#34;&#34;
        userb64 = tob64(self.config.user)
        passb64 = self.config.passwd
        
        resp = self.request(&#39;login&#39;, username=userb64, password=passb64, raw=True, secure=True)
        
        if resp != None :
            try:
                resp.raise_for_status()
            except requests.HTTPError as e :
                if retry&gt;0:
                    time.sleep(0.2)
                    return self.login(retry=retry-1)
                else:
                    raise NitroError(&#39;ESM Login Error: &#39;, resp.text) from e
       
            self._headers[&#39;Cookie&#39;] = resp.headers.get(&#39;Set-Cookie&#39;)
            self._headers[&#39;X-Xsrf-Token&#39;] = resp.headers.get(&#39;Xsrf-Token&#39;)
            
            self.user_tz_id = dict(resp.json())[&#39;tzId&#39;]
            self.logged_in = True
            self.login_info=self.unpack_resp(resp)

            # Shorthanding the API version check 
            # 1 for pre 11.2.1, 2 for 11.2.1 and later
            # Not be confused with the ESM API v1 and v2 which are different.
            if str(self.version).startswith((&#39;9&#39;, &#39;10&#39;, &#39;11.0&#39;, &#39;11.1&#39;)):
                self.api_v = 1
            else:
                self.api_v = 2

            log.info(&#39;Logged into ESM {} with username {}. Last login {}&#39;.format(
                str(self.config.host),
                self.login_info[&#39;userName&#39;],
                self.login_info[&#39;lastLoginDate&#39;]))

            return True
        else:
            raise NitroError(&#39;ESM Login Error: Response empty&#39;)

    def logout(self):
        &#34;&#34;&#34; 
        This method will logout the session.
        &#34;&#34;&#34;
        self.api_v = 0
        self.request(&#39;logout&#39;, http=&#39;delete&#39;)
        self.logged_in=False
        self.login_info=dict()
        self._headers={&#39;Content-Type&#39;: &#39;application/json&#39;}
        self.user_tz_id = None

    def esm_request(self, method, data, http=&#39;post&#39;, callback=None, raw=False, secure=False, retry=1):
        &#34;&#34;&#34;
        Helper method that format the request, handle the basic parsing of the SIEM result as well as other errors.          
        If method is all upper cases, it&#39;s going to be formatted as a private API call. See `msiempy.NitroSession.format_params` and `msiempy.NitroSession.format_priv_resp` 
        In any way, the ESM response is unpacked by `msiempy.NitroSession.unpack_resp`.  


        Arguments :  

        - `method` : ESM API enpoint name and url parameters  
        - `http`: HTTP method.  
        - `data` : dict data to send  
        - `callback` : function to apply afterwards  
        - `raw` : If true will return the Response object from requests module. No retry when raw=True.     
        - `secure` : If true will not log the content of the request.   
        - `retry` : Number of time the request can be retried

        Returns : 

        - a `dict`, `list` or `str` object. 
        - the `resquest.Response` object if raw=True  
        - `None` if Timeout or TooManyRedirects if raw=False  

        Raises:

        - `NitroError` if any `HTTPError`

         Note : Private API is under /ess/ and public api is under /rs/esm  

        &#34;&#34;&#34;

        url=str()
        privateApiCall=False
        result=None

        #Logging the data request if not secure | Logs anyway the method
        log.debug(&#39;Requesting HTTP &#39;+str(http)+&#39; &#39;+ str(method) + 
            (&#39; with data &#39;+str(data) if not secure else &#39; ***&#39;) )
        
        http_data=str()

        #Handling private API calls formatting
        if method == method.upper():
            privateApiCall=True
            url = self.BASE_URL_PRIV
            http_data = self.format_params(method, **data)
            log.debug(&#39;Private API call : &#39;+str(method)+&#39; Formatted params : &#39;+str(http_data))
        
        #Normal API calls
        else:
            url = self.BASE_URL
            if data :
                http_data = json.dumps(data)

        try :
            result = requests.request(
                http,
                urllib.parse.urljoin(url.format(self.config.host), method),
                data=http_data, 
                headers=self._headers,
                verify=self.config.ssl_verify,
                timeout=self.config.timeout,
                # Uncomment for debugging.
                #proxies={&#34;http&#34;: &#34;http://127.0.0.1:8888&#34;, &#34;https&#34;:&#34;http:127.0.0.1:8888&#34;}
            )

            if raw :
                log.debug(&#39;Returning raw requests Response object : &#39;+str(result))
                return result

            else:
                try:
                    result.raise_for_status()

                except requests.HTTPError as e :
                    error=None

                    if retry&gt;0 :
                        # Invalid session handler -&gt; re-login
                        if any([match in result.text for match in [&#39;ERROR_InvalidSession&#39;, &#39;ERROR_INVALID_SESSION&#39;,
                            &#39;Not Authorized User&#39;, &#39;Invalid Session&#39;, &#39;Username and password cannot be null&#39;]]):
                            error = NitroError(&#39;Authentication error with method ({}) and data : {} logging in and retrying esm_request(). From requests.HTTPError {} {}&#39;.format(
                                method, data, e, result.text))
                            log.warning(error)
                            self.logged_in=False
                            self.login()
                        
                        else: log.warning(&#39;An HTTP error occured ({} {}), retrying esm_request()&#39;.format(e, result.text))
                        
                        # Retry request
                        time.sleep(0.2)
                        return self.esm_request(method, data, http, callback, raw, secure, retry=retry-1)
                    
                    else :
                        # # Data unavailable error -&gt; raise
                        # if any([match in result.text for match in [&#39;ERROR_IndexNotTurnedOn&#39;,
                        #     &#39;ERROR_NoData&#39;,&#39;ERROR_UnknownList&#39;,&#39;ERROR_JobEngine_GetQueryStatus_StatusNotFound&#39;]]):
                        #     error = NitroError(&#39;Data unavailable error with method ({}) and data : {}. From requests.HTTPError {} {}&#39;.format(
                        #         method, data, e, result.text))
                        #     log.error(error)
                        #     raise
                        # else :
                        #     # Other handlers
                        #     # if True : # Other HTTP errors... TODO
                        #         # _InvalidFilter (228)
                        #         # Status Code 500: Error processing request, see server logs for more details 
                        #         # Input Validation Error

                        # Raise error in the worst case
                        error = NitroError(&#39;Error with method ({}) and data : {}. From requests.HTTPError {} {}&#39;.format(
                            method, data, e, result.text))
                        log.error(error)
                        raise error from e

                else: # The result is not an HTTP Error
                    response = result
                    result = self.unpack_resp(result)

                    if privateApiCall :
                        result = self.format_priv_resp(result)

                    if callback:
                        result = callback(result)

                    log.debug(&#39;{} -&gt; Result ({}): {}&#39;.format(
                        str(response),
                        type(result),
                        str(result)[:100] + &#39;[...]&#39; if len(str(result))&gt;100 else &#39;&#39;
                    ))

                    return result

        #Hard errors, could retry
        except requests.exceptions.Timeout as e:
            log.error(e)
            raise
        except requests.exceptions.TooManyRedirects as e :
            log.error(e)
            raise
        
    # def _request_http_error_handler(self, error, method, data, http, callback, raw, secure, retry):
    #     pass

    def version(self):
        &#34;&#34;&#34;
        Returns: `str` ESM short version.  
        Example: &#39;10.0.2&#39;
        &#34;&#34;&#34;
        return self.buildstamp().split()[0]

    def buildstamp(self):
        &#34;&#34;&#34;
        Returns: `str` ESM buildstamp.  
        Example: &#39;10.0.2 20170516001031&#39;
        &#34;&#34;&#34;
        return self.request(&#39;build_stamp&#39;)[&#39;buildStamp&#39;]

    def get_internal_file(self, file_token):
        &#34;&#34;&#34;Uses the private API to retrieve, assemble and delete a temp file from the ESM.
        
        Arguments:  

        - `file_token` (`str`): File token ID
        &#34;&#34;&#34;
        pos = 0
        nbytes = 0
        resp = self.request(&#39;get_rfile2&#39;, ftoken=file_token, pos=pos, nbytes=nbytes)

        if resp[&#39;FSIZE&#39;] == resp[&#39;BREAD&#39;]:
            data = resp[&#39;DATA&#39;]
            self.request(&#39;del_rfile&#39;, ftoken=file_token)
            return data
        
        data = []
        data.append(resp[&#39;DATA&#39;])
        file_size = int(resp[&#39;FSIZE&#39;])
        collected = int(resp[&#39;BREAD&#39;])

        while file_size &gt; collected:
            pos += int(resp[&#39;BREAD&#39;])
            nbytes = file_size - collected
            resp = self.request(&#39;get_rfile2&#39;, ftoken=file_token, pos=pos, nbytes=nbytes)
            collected += int(resp[&#39;BREAD&#39;])
            data.append(resp[&#39;DATA&#39;])

        resp = self.request(&#39;del_rfile&#39;, ftoken=file_token)
        return &#39;&#39;.join(data)

    def request(self, request, **kwargs):
        &#34;&#34;&#34;
        This method is the centralized interface of all requests going to the SIEM.  
        It interpolates `**params` with `msiempy.NitroSession.PARAMS` docstrings and build a valid datastructure with `ast`.  
        Wrapper around the `msiempy.NitroSession.esm_request` method.  

        Arguments:  

        - `request`: Keyword corresponding to the request name in `msiempy.NitroSession.PARAMS` mapping.  
        - `http`: HTTP method.  
        - `callback` : function to apply afterwards  
        - `raw` : If true will return the Response object from requests module.   
        - `secure` : If true will not log the content of the request.   
        - `retry` : Number of time the request can be retried
        
        Interpolation parameters :  
        
        - `**kwargs` : Interpolation parameters that will be match to `msiempy.NitroSession.PARAMS` templates. Dynamic keyword arguments.  

        Returns :  

        - a `dict`, `list` or `str` object  
        - the `resquest.Response` object if raw=True  
        - `result.text` if `requests.HTTPError`,   
        - `None` if Timeout or TooManyRedirects if raw=False  
        &#34;&#34;&#34;
        log.debug(&#34;Calling nitro request : {} kwargs={}&#34;.format(
            str(request), &#39;***&#39; if &#39;secure&#39; in kwargs and kwargs[&#39;secure&#39;]==True else str(kwargs)))

        method, data = self.PARAMS.get(request)

        if data != None :
            data =  data % kwargs
            data = ast.literal_eval((data.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\t&#39;,&#39;&#39;)))
           
        if method != None:
            try :
                method = method % kwargs
            except TypeError as err :
                if (&#39;must be real number, not dict&#39; in str(err)):
                    log.warning(&#34;Interpolation failed probably because of the private API calls formatting... Unexpected behaviours can happend.&#34;)

        if not self.logged_in and method != &#39;login&#39;:
            # Autologin
            self.login()
            
    
        try :
            #Dynamically checking the esm_request arguments so additionnal parameters can be passed afterwards.
            esm_request_args = inspect.getfullargspec(self.esm_request)[0]
            params={}
            for arg in kwargs :
                if arg in esm_request_args:
                    params[arg]=kwargs[arg]
            return self.esm_request(method=method, data=data, **params)

        except ConnectionError as e:
            log.critical(e)
            raise
        except Exception as e:
            log.error(e)
            raise 

    @staticmethod
    def _init_log(verbose=False, quiet=False, logfile=None):
        &#34;&#34;&#34;
        Private method. Inits the session&#39;s logger settings based on params
        All objects should be able to log stuff, so the logger is globaly accessible
        &#34;&#34;&#34;

        log.setLevel(logging.DEBUG)

        std = logging.StreamHandler()
        std.setLevel(logging.DEBUG)
        std.setFormatter(logging.Formatter(&#39;%(levelname)s - %(message)s&#39;))

        if verbose :
            std.setLevel(logging.DEBUG)
        elif quiet :
            std.setLevel(logging.CRITICAL)
        else :
            std.setLevel(logging.INFO)

        log.handlers=[]
        
        log.addHandler(std)

        if logfile :
            fh = logging.FileHandler(logfile)
            fh.setLevel(logging.DEBUG)
            fh.setFormatter(logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(message)s&#39;))
            log.addHandler(fh)

        if verbose and quiet :
            log.warning(&#34;Verbose and quiet values are both set to True. This is a very inconsistent state. By default, verbose value has priority.&#34;)

        return (log)
    

    @staticmethod
    def format_params(cmd, **params):
        &#34;&#34;&#34;
        Format private API call.  
        From mfe_saw project at https://github.com/andywalden/mfe_saw
        &#34;&#34;&#34;
        params = {k: v for k, v in params.items() if v != None}
        params = &#39;%14&#39;.join([k + &#39;%13&#39; + v + &#39;%13&#39; for (k, v) in params.items()])
        
        if params:
            params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39; + params + &#39;%14&#39;
        else:
            params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39;
        return params

    @staticmethod
    def format_priv_resp(resp):
        &#34;&#34;&#34;
        Format response from private API.  
        From mfe_saw project at https://github.com/andywalden/mfe_saw
        &#34;&#34;&#34;
        resp = re.search(&#39;Response=(.*)&#39;, resp).group(1)
        resp = resp.replace(&#39;%14&#39;, &#39; &#39;)
        pairs = resp.split()
        formatted = {}
        for pair in pairs:
            pair = pair.replace(&#39;%13&#39;, &#39; &#39;)
            pair = pair.split()
            key = pair[0]
            if key == &#39;ITEMS&#39;:
                value = pair[-1]
            else:
                value = urllib.parse.unquote(pair[-1])
            formatted[key] = value
        return formatted

    @staticmethod
    def unpack_resp(response) :
        &#34;&#34;&#34;Unpack data from response.
        Args: 
            response: requests.Response response object
        Returns a list, a dict or a string
        &#34;&#34;&#34;
        try :
            data = response.json()
            if isinstance(response.json(), dict):
                try:
                    data = data[&#39;value&#39;]
                except KeyError:
                    try:
                        data = data[&#39;return&#39;]
                    except KeyError:
                        pass
            
        except ValueError :
            data = response.text

        return data

class NitroObject(abc.ABC):
    &#34;&#34;&#34;
    Base class for all nitro objects. All objects have a reference to the single `msiempy.NitroSession` object that handle the esm requests.  
    Creates the object session.
    &#34;&#34;&#34;

    class NitroJSONEncoder(json.JSONEncoder):
        &#34;&#34;&#34;
        Custom JSON encoder that will use the approprtiate propertie depending of the type of NitroObject.  
        TODO return meta info about the NitroList. Maybe create a section `manager` and `data`.  
        TODO support json json dumping of QueryFilers, may be by making them inherits from NitroDict.  
        &#34;&#34;&#34;
        def default(self, obj): # pylint: disable=E0202
            if isinstance(obj,(NitroDict, NitroList)):
                return obj.data
            else:
                return json.JSONEncoder.default(self, obj) 


    nitro=NitroSession()
    &#34;&#34;&#34;
    `msiempy.NitroSession` object. Interface to the SIEM.
    &#34;&#34;&#34;

    @abc.abstractproperty
    def text(self):
        &#34;&#34;&#34;
        Returns printable string.  
        Abstract declaration.
        &#34;&#34;&#34;
        pass

    @abc.abstractproperty
    def json(self):
        &#34;&#34;&#34;
        Returns json string representation.  
        Abstract declaration.
        &#34;&#34;&#34;
    
    @abc.abstractmethod
    def refresh(self):
        &#34;&#34;&#34;
        Re-load the object.  
        Abstract declaration.
        &#34;&#34;&#34;
        pass

class NitroDict(collections.UserDict, NitroObject):
    &#34;&#34;&#34;
    Base class that represent any SIEM data that can be represented as a item of a list.
    Exemple : Event, Alarm, etc...
    Inherits from dict.
    Initiate the NitroObject and UserDict objects, load the data if id is specified, use adict agument and update dict values accordingly.

    This classe and subclasses fully implements `dict` interface and is suitable for dictionnary operations, see: https://docs.python.org/3/library/stdtypes.html#mapping-types-dict

    Arguments:  

    - `adict`: dict object to wrap.  
    - `id`: ESM obejct unique identifier. Alert.IPSIDAlertID for exemple. 
    &#34;&#34;&#34;
    def __init__(self, adict=None, id=None):
        NitroObject.__init__(self)
        collections.UserDict.__init__(self, adict)

        if adict : self.data=adict
        if id : self.data=self.data_from_id(id)

        for key in list(self) :
            if isinstance(self[key], list):
                self[key]=NitroList(alist=self[key])

    def __str__(self):
        &#34;&#34;&#34;str(obj) -&gt; return text string.
        &#34;&#34;&#34;
        return self.text

    def __repr__(self):
        &#34;&#34;&#34;repr(obj) -&gt; return json string.
        &#34;&#34;&#34;
        return self.json

    @property
    def json(self):
        &#34;&#34;&#34;JSON representation of a item
        &#34;&#34;&#34;
        return(json.dumps(dict(self), indent=4, cls=NitroObject.NitroJSONEncoder))

    @property
    def text(self):
        &#34;&#34;&#34;Text list of item&#39;s values
        &#34;&#34;&#34;
        return(&#39;, &#39;.join([str(val) for val in self.values()]))

    @abc.abstractmethod
    def data_from_id(self, id):
        &#34;&#34;&#34;This method retreive the item infos from an object ID.  
        Abstract declaration.
        &#34;&#34;&#34;
        pass

class NitroList(collections.UserList, NitroObject):
    &#34;&#34;&#34;
    Base class for NitroList objects. It offers callable execution management, search and other data list actions.  
    
    Concrete classes have to cast the items after !   

    This classe and subclasses fully implements `list` interface and is suitable for list operations, see: https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range
    
    Subclassing requirements: Subclasses of UserList are expected to offer a constructor which can be called with either no arguments or one argument. List operations which return a new sequence attempt to create an instance of the actual implementation class. To do so, it assumes that the constructor can be called with a single parameter, which is a sequence object used as a data source.
    If a derived class does not wish to comply with this requirement, all of the special methods supported by this class will need to be overridden; please consult the sources for information about the methods which need to be provided in that case.
    See: https://docs.python.org/3.8/library/collections.html?highlight=userdict#userlist-objects  

    Arguments:  

    - `alist`: list object to wrap.
    &#34;&#34;&#34;

    # TODO better polymorphism to cast every sub-NitroList class&#39;s item dynamcally in `__init__` method.  
    def __init__(self, alist=None):
        NitroObject.__init__(self)
        if alist : collections.UserList.__init__(self, alist)
        else : collections.UserList.__init__(self, [])

    def __str__(self):
        &#34;&#34;&#34;str(obj) -&gt; return text string.
        &#34;&#34;&#34;
        return &#34;{} containing {} elements ; keys={}&#34;.format(str(super()), len(list(self)), self.keys())

    def keys(self):
        &#34;&#34;&#34;Set of keys for all dict&#34;&#34;&#34;
        #If new fields are added it won&#39;t show on text repr. Only json.
        manager_keys=set()
        for item in list(self): manager_keys.update(getattr(item, &#39;keys&#39;, set)())
        return manager_keys

    def get_text(self, format=&#39;prettytable&#39;, fields=None, 
                        max_column_width=80, get_text_nest_attr={} ):
        &#34;&#34;&#34;
        Return a csv or table string representation of the list

        Arguments:  

        - `format`: 
              prettytable: Returns a table generated by prettytable
              csv: Returns data with header and comma separated values. 
        - `fields`: list of fields you want in the table. If `None` : default fields are returned by .keys attribute and sorted.  
        - `max_column_width`: when using prettytable only 
        - `get_text_nest_attr`: attributes passed to the nested `msiempy.NitroList.get_text` elements. Useful to control events appearence.
        &#34;&#34;&#34;

        text=str()
        
        if not fields :
            fields=sorted(self.keys())

        if format == &#39;csv&#39;:
            file = StringIO()
            dw = csv.DictWriter(file, fields, extrasaction=&#39;ignore&#39;)
            dw.writeheader()
            dw.writerows(list(self))
            text = file.getvalue()

        elif format == &#39;prettytable&#39;:
            table = prettytable.PrettyTable()
            table.set_style(MSWORD_FRIENDLY)

            table.field_names=fields

            for item in list(self):
                if isinstance(item, (dict, NitroDict)):
                    values=list()
                    for field in fields:
                        obj=None
                        try:obj=item[field]
                        except KeyError : pass

                        if isinstance(obj, NitroList):
                            values.append(obj.get_text(**get_text_nest_attr))
                        else:
                            values.append(&#39;\n&#39;.join(textwrap.wrap(str(obj), width=max_column_width)))

                    table.add_row(values)
                    
                else : log.warning(&#34;Unnapropriate list element type, won&#39;t show on the prettytable : {}&#34;.format(str(item)))

            text=table.get_string()
        
        else :
            raise AttributeError(&#34;Unknown `NitroList.get_text` format : {}. Accepted values are &#39;prettytable&#39; or &#39;csv&#39;.&#34;.format(format))

        return text


    @property
    def text(self):
        &#34;&#34;&#34;Defaut table string, a shorcut to `get_text()` with no arguments.
        &#34;&#34;&#34;
        return self.get_text()
        
    @property
    def json(self):
        &#34;&#34;&#34;JSON list of dicts representing the list.
        &#34;&#34;&#34;
        return(json.dumps([dict(item) for item in list(self)], indent=4, cls=NitroObject.NitroJSONEncoder))

    def search(self, invert=False, match_prop=&#39;json&#39;, *pattern):
        &#34;&#34;&#34;
        Return a list of elements that matches one or more regex patterns.
        Patterns are applied one after another. It&#39;s a logic AND.
        Use `|` inside patterns to search with logic OR.
        This method will return a new NitroList with matching data. NitroDicts in the returned NitroList do not
        references the items in the original NitroList.  

        Arguments:  

        - `*pattern`: List or string regex patterns to look for.
        - `invert`: Weither or not to invert the search and return elements that doesn&#39;t not match search.
        - `match_prop`: Propertie that is going to be called to search. Could be `text` or `json`.


        If you wish to apply more specific filters to NitroList list, please
        use filter(), list comprehension, or other filtering method.
            i.e. : `[item for item in list if item[&#39;cost&#39;] &gt; 50]`

        More on regex https://docs.python.org/3/library/re.html#re.Pattern.search
        &#34;&#34;&#34;
        if pattern is None :
            return self
        elif len(pattern) == 0 :
            return self
        else :
            pattern=list(pattern)
            apattern=pattern.pop()
        
        matching_items=list()
        
        if isinstance(apattern, str):
            for item in list(self) :
                if regex_match(apattern, getattr(item, match_prop) if isinstance(item, NitroDict) else str(item)) != invert :
                    matching_items.append(item)
            log.debug(&#34;You&#39;re search returned {} rows : {}&#34;.format(
                len(matching_items),
                str(matching_items)[:100]+&#39;...&#39;))
            #Apply AND reccursively
            return NitroList(alist=matching_items).search(*pattern, invert=invert, match_prop=match_prop)
        else:
            raise ValueError(&#39;pattern must be str&#39;)

    def refresh(self):
        &#34;&#34;&#34;
        Execute refresh function on all items.
        &#34;&#34;&#34;
        log.warning(&#34;The function NitroList.refresh hasn&#39;t been correctly tested&#34;)
        self.perform(NitroDict.refresh, message=&#39;Refreshing all items...&#39;)

    def perform(self, func, data=None, func_args=None, confirm=False, asynch=False,  workers=None , progress=False, message=None):
        &#34;&#34;&#34;
        Wrapper arround executable and the a list of elements, typically `msiempy.NitroList` object.  

        Arguments:  
        
        - `func`: callable function. `func` is going to be called like `func(item, **func_args)` on all items in data.  This function can be stateless (static) or statefull (first argument is `self`),
        it doesn&#39;t really matter as the element will always be passed as the first argument of the function. On thing really important, the function must not
        set/delete/change any global variable, as a result, you&#39;ll see your varible beeing potentially corrupted or chalenged with conccurent accesses.
        - `data`: if stays `None`, will perform the action on itself (`list(self)`) else it will perfom the action on the `data` list.
        - `func_args`: arguments that will be passed by default to `func` in all calls.
        - `confirm`: will ask interactively confirmation.
        - `asynch`: execute the task asynchronously with `concurrent.futures.ThreadPoolExecutor`. It will create a new executor object, so be carefull not to nest 2 asynchronous executions within eachother,
        it will be a mess.
        - `workers`: number of parrallel tasks, mandatory if asynch is true.
        - `progress`: to show progress bar with ETA (tqdm).
        - `message` : To show to the user.  

        This method is where the core of asynchronous tasks resides. `func` will be executed on all `data` elements.  
        Basically, if `asynch==True`, will return :  
            returned=list(concurrent.futures.ThreadPoolExecutor(
                        max_workers=workers ).map(
                            func, data))  

        if `asynch==False`, will iterate and return :
            for index_or_item in data:
                returned.append(func(index_or_item))

        Returns a list of returned results.
        &#34;&#34;&#34;

        log.debug(&#39;Calling perform func=&#39;+str(func)+
            &#39; data=&#39;+str(data)[:100]+
            &#39; func_args=&#39;+str(func_args)+
            &#39; confirm=&#39;+str(confirm)+
            &#39; asynch=&#39;+str(asynch)+
            &#39; workers=&#39;+str(workers)+
            &#39; progress=&#39;+str(progress)+
            &#39; message=&#39;+str(message))

        if not callable(func) :
            raise ValueError(&#39;func must be callable&#39;)

        #Confirming with user if asked
        if confirm : self._confirm_func(func, str(self))

        #Setting the arguments on the function
        func = functools.partial(func, **(func_args if func_args != None else {}))
        
        #The data returned by function
        returned=list()

        #Usethe self contained data if not speficed otherwise
        elements=list(self)
        if isinstance(data, list) and data != None:
            elements=data
        else :
            AttributeError(&#39;data must be a list&#39;)

        #Printing message if specified.
        tqdm_args=dict()

        #The message will appear on loading bar if progress is True
        if progress is True :
            tqdm_args=dict(desc=&#39;Loading...&#39;, total=len(elements))
            if message != None:
                tqdm_args[&#39;desc&#39;]=message
        elif message != None:
            log.info(message)

        #Runs the callable on list on executor or by iterating
        if asynch == True :
            if isinstance(workers, int) :
                if progress==True :
                    if not self.nitro.config.quiet:
                        #Need to call tqdm to have better support for concurrent futures executor
                        # tqdm would load the whole bar intantaneously and not wait until the callable func returns. 
                        returned=list(tqdm.tqdm(concurrent.futures.ThreadPoolExecutor(
                        max_workers=workers ).map(
                            func, elements), **tqdm_args))
                    else:
                        log.warning(&#34;You requested to show perfrom progress but config&#39;s quiet value is True, not showing tqdm load bar.&#34;)
                        returned=list(concurrent.futures.ThreadPoolExecutor(
                        max_workers=workers ).map(
                            func, elements))
                else:
                    returned=list(concurrent.futures.ThreadPoolExecutor(
                    max_workers=workers ).map(
                        func, elements))
            else:
                raise AttributeError(&#39;When asynch == True : You must specify a integer value for workers&#39;)
        else :

            if progress==True:
                if not self.nitro.config.quiet:
                    elements=tqdm.tqdm(elements, **tqdm_args)
                else:
                    log.warning(&#34;You requested to show perform progress but config&#39;s quiet value is True, not showing tqdm load bar.&#34;)

            for index_or_item in elements:
                returned.append(func(index_or_item))

        return(returned)

    @staticmethod
    def _confirm_func(func, elements):
        &#34;&#34;&#34;
        Ask user inut to confirm the calling of `func` on `elements`.
        &#34;&#34;&#34;
        if not &#39;y&#39; in input(&#39;Are you sure you want to do this &#39;+str(func)+&#39; on &#39;+
        (&#39;\n&#39;+str(elements) if elements != None else &#39;all elements&#39;)+&#39;? [y/n]: &#39;):
            raise InterruptedError(&#34;The action was cancelled by the user.&#34;)

class FilteredQueryList(NitroList):
    &#34;&#34;&#34;
    Base class for query based managers : `msiempy.alarm.AlarmManager`, `msiempy.event.EventManager`.  
    FilteredQueryList object can handle time_ranges and time splitting.  
    Abstract base class that provide time ranged filtered query wrapper.  

    Arguments:  

    - `time_range` : Query time range. String representation of a time range. 
        See `msiempy.FilteredQueryList.POSSIBLE_TIME_RANGE`.  
    - `start_time` : Query starting time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  
    - `end_time` : Query endding time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  
    - `filters` : List of filters applied to the query.  
    &#34;&#34;&#34;
    def __init__(self, *arg, time_range=None, start_time=None, end_time=None, filters=None, **kwargs):

        # Handled eventual deprecated arguments
        if &#39;max_query_depth&#39; in kwargs :
            log.warning(&#39;Deprecated : `max_query_depth` argument has been removed from the object declaration for more clarty, it\&#39;s now a specilized EventManager.load_data() argument only. This argument will be ignored.&#39;)
            del kwargs[&#39;max_query_depth&#39;]
        if &#39;requests_size&#39; in kwargs :
            log.warning(&#39;Deprecated : `requests_size` argument has been removed from FilteredQueryList, use `page_size` for AlarmManager or `limit` for EventManager arguments.&#39;)
            del kwargs[&#39;requests_size&#39;]
        if &#39;load_async&#39; in kwargs :
            log.warning(&#39;Deprecated : `load_async` argument has been removed from FilteredQueryList. Queries are now always loaded asynchronously.&#39;)
            del kwargs[&#39;load_async&#39;]

        super().__init__(*arg, **kwargs)

        
        self.not_completed=False

        #self.nitro.config.default_rows #nb rows per request : eq limit/page_size = requests_size
        #self.nitro.config.max_rows #max nb rows 

        #Declaring attributes and types
        self._time_range=str()
        self._start_time=None
        self._end_time=None

        #self.filters=filters filter property setter should be called in the concrete class
        #TODO find a better solution to integrate the filter propertie

        if start_time != None and end_time != None :
            self.start_time=start_time
            self.end_time=end_time
            self.time_range=&#39;CUSTOM&#39;
        else :
            self.time_range=time_range
    
    DEFAULT_TIME_RANGE=&#34;CURRENT_DAY&#34;
    __pdoc__[&#39;FilteredQueryList.DEFAULT_TIME_RANGE&#39;]=&#34;&#34;&#34;Default time range : %(default)s&#34;&#34;&#34; % dict(default=DEFAULT_TIME_RANGE)

    POSSIBLE_TIME_RANGE=[
            &#34;CUSTOM&#34;,
            &#34;LAST_MINUTE&#34;,
            &#34;LAST_10_MINUTES&#34;,
            &#34;LAST_30_MINUTES&#34;,
            &#34;LAST_HOUR&#34;,
            &#34;CURRENT_DAY&#34;,
            &#34;PREVIOUS_DAY&#34;,
            &#34;LAST_24_HOURS&#34;,
            &#34;LAST_2_DAYS&#34;,
            &#34;LAST_3_DAYS&#34;,
            &#34;CURRENT_WEEK&#34;,
            &#34;PREVIOUS_WEEK&#34;,
            &#34;CURRENT_MONTH&#34;,
            &#34;PREVIOUS_MONTH&#34;,
            &#34;CURRENT_QUARTER&#34;,
            &#34;PREVIOUS_QUARTER&#34;,
            &#34;CURRENT_YEAR&#34;,
            &#34;PREVIOUS_YEAR&#34;
    ]
    __pdoc__[&#39;FilteredQueryList.POSSIBLE_TIME_RANGE&#39;]=&#34;&#34;&#34;
    List of possible time ranges : `%(timeranges)s`&#34;&#34;&#34; % dict(timeranges=&#39;, &#39;.join(POSSIBLE_TIME_RANGE))

    @property
    def time_range(self):
        &#34;&#34;&#34;
        Query time range. See `msiempy.FilteredQueryList.POSSIBLE_TIME_RANGE`.
        Default to `msiempy.FilteredQueryList.DEFAULT_TIME_RANGE` (CURRENT_DAY).
        Note that the time range is upper cased automatically.
        Raises `VallueError` if unrecognized time range is set and `AttributeError` if not the right type.
        &#34;&#34;&#34;
        return self._time_range.upper()

    @time_range.setter
    def time_range(self, time_range):
        if not time_range :
            self.time_range=self.DEFAULT_TIME_RANGE

        elif isinstance(time_range, str):
            time_range=time_range.upper()
            if time_range in self.POSSIBLE_TIME_RANGE :
                if time_range != &#39;CUSTOM&#39;:
                    self.start_time=None
                    self.end_time=None
                self._time_range=time_range
            else:
                raise ValueError(&#34;The time range must be in &#34;+str(self.POSSIBLE_TIME_RANGE))
        else:
            raise AttributeError(&#39;time_range must be a string or None&#39;)

    @property
    def start_time(self):
        &#34;&#34;&#34;
        Start time of the query in the right SIEM format.  
        Use `_start_time` to get the datetime object. You can set the `star_time` as a `str` or a `datetime`.  
        If `None`, equivalent CURRENT_DAY start 00:00:00.  
        Raises: `ValueError` if not the right type.  
        &#34;&#34;&#34;
        return format_esm_time(self._start_time)

    @start_time.setter
    def start_time(self, start_time):
        if isinstance(start_time, str):
            self.start_time = convert_to_time_obj(start_time)
        elif isinstance(start_time, datetime.datetime):
            self._start_time = start_time
        elif start_time==None:
             self._start_time=None #raise ValueError(&#34;Time must be string or datetime object, not None&#34;)#self.start_time = datetime.datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        else:
            raise ValueError(&#34;Time must be string or datetime object.&#34;)

    @property
    def end_time(self):
        &#34;&#34;&#34;
        End time of the query in the right SIEM format.  
        Use `_end_time` property to get the datetime object. You can set the `end_time` as a `str` or a `datetime`.  
        If `None`, equivalent CURRENT_DAY.  
        Raises `ValueError` if not the right type.
        &#34;&#34;&#34;
        return format_esm_time(self._end_time)

    @end_time.setter
    def end_time(self, end_time):       
        if isinstance(end_time, str):
            self.end_time = convert_to_time_obj(end_time)
        elif isinstance(end_time, datetime.datetime):
            self._end_time = end_time
        elif end_time==None:
             self._end_time=None #raise ValueError(&#34;Time must be string or datetime object, not None&#34;)
        else:
            raise ValueError(&#34;Time must be string or datetime object.&#34;)

    @abc.abstractproperty
    def filters(self):
        &#34;&#34;&#34; 
        Filter property : Returns a list of filters.
        Can be set with list of tuple(field, [values]), a `msiempy.event.FieldFilter` or `msiempy.event.GroupFilter` in the case of a `msiempy.event.EventManager` query. A single tuple is also accepted.  
        `None` value will trigger `msiempy.FilteredQueryList.clear_filters()`.  
        Raises : `AttributeError` if type not supported.
        Abstract declaration.
        TODO find a better solution to integrate the filter property
        &#34;&#34;&#34;
        pass

    @filters.setter
    def filters(self, filters):
        if isinstance(filters, list):
            for f in filters :
                self.add_filter(f)

        elif isinstance(filters, tuple):
            self.add_filter(filters)

        elif filters == None :
            self.clear_filters()
        
        else :
            raise AttributeError(&#34;Illegal type for the filter object, it must be a list, a tuple or None.&#34;)

    
    @abc.abstractmethod
    def add_filter(self, filter):
        &#34;&#34;&#34;Add a filter to the query.  
        Abstract declaration.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def clear_filters(self):
        &#34;&#34;&#34;Remove all filters to the query.  
        Abstract declaration.
        &#34;&#34;&#34;
        pass 

    @abc.abstractmethod
    def qry_load_data(self, *args, **kwargs):
        &#34;&#34;&#34;
        Method to load the data from the SIEM.  
        Rturns a `tuple ((items, completed))`.  
        Abstract declaration.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def load_data(self, *args, **kwargs):
        &#34;&#34;&#34;Load the data from the SIEM into the manager list.  
        Abstract declaration.&#34;&#34;&#34;
        pass

class NitroError(Exception):
    &#34;&#34;&#34;
    Base internal exception.  
    It&#39;s used when the user/passwd is incorrect, or other specific ESM related errors.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="msiempy.alarm" href="alarm.html">msiempy.alarm</a></code></dt>
<dd>
<div class="desc"><p>Provide alarm management.</p></div>
</dd>
<dt><code class="name"><a title="msiempy.device" href="device.html">msiempy.device</a></code></dt>
<dd>
<div class="desc"><p>Provide ESM, ERC and data source management.</p></div>
</dd>
<dt><code class="name"><a title="msiempy.event" href="event.html">msiempy.event</a></code></dt>
<dd>
<div class="desc"><p>Provide event management.</p></div>
</dd>
<dt><code class="name"><a title="msiempy.watchlist" href="watchlist.html">msiempy.watchlist</a></code></dt>
<dd>
<div class="desc"><p>Provide watchlist management.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="msiempy.NitroConfig"><code class="flex name class">
<span>class <span class="ident">NitroConfig</span></span>
<span>(</span><span>path=None, config=None, *arg, **kwarg)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles the configuration. Reads the config file <code>.msiem/conf.ini</code> where ever it is and make accessible it's values throught object properties.
If a <code>.msiem/</code> directory exists in your current directory, the program will assume the <code>conf.ini</code> file is there, if not, it will create it with default values.
Secondly, if no <code>.msiem/</code> directory exists in the current directory, it will be automatically placed in a appropriate place depending of your platform:
</p>
<p>Default configuration file should look like this. Authentication is left empty.</p>
<pre><code>[esm]
host = 
user = 
passwd = 

[general]
verbose = False
quiet = False
logfile = 
timeout = 60
ssl_verify = False
</code></pre>
<p>For Windows: <code>%APPDATA%\.msiem\conf.ini</code><br>
For Mac : <code>$HOME/.msiem/conf.ini</code><br>
For Linux : <code>$XDG_CONFIG_HOME/.msiem/conf.ini</code> or : <code>$HOME/.msiem/conf.ini</code><br>
If <code>.msiem</code> folder exists in you local directory : <code>./.msiem/conf.ini</code>
</p>
<p>You can setup the configuration by command line with <code>msiempy_setup.py</code> script at <a href="https://github.com/mfesiem/msiempy/blob/master/samples/msiempy_setup.py.">https://github.com/mfesiem/msiempy/blob/master/samples/msiempy_setup.py.</a>
</p>
<p>Arguments: </p>
<ul>
<li><code>path</code>: Config file special path, if path is left None, will automatically look for it.
</li>
<li><code>config</code>: Manual config dict. ex: <code>{'general':{'verbose':True}}</code>.
</li>
<li><code>*args, **kwargs</code> : Passed to <code>configparser.ConfigParser.__init__()</code> method.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NitroConfig(configparser.ConfigParser):
    &#34;&#34;&#34;

    Handles the configuration. Reads the config file `.msiem/conf.ini` where ever it is and make accessible it&#39;s values throught object properties. 
    If a `.msiem/` directory exists in your current directory, the program will assume the `conf.ini` file is there, if not, it will create it with default values. 
    Secondly, if no `.msiem/` directory exists in the current directory, it will be automatically placed in a appropriate place depending of your platform:  

    Default configuration file should look like this. Authentication is left empty.
    ```
    [esm]
    host = 
    user = 
    passwd = 

    [general]
    verbose = False
    quiet = False
    logfile = 
    timeout = 60
    ssl_verify = False
    ```

    For Windows: `%APPDATA%\.msiem\conf.ini`  
    For Mac : `$HOME/.msiem/conf.ini`  
    For Linux : `$XDG_CONFIG_HOME/.msiem/conf.ini` or : `$HOME/.msiem/conf.ini`  
    If `.msiem` folder exists in you local directory : `./.msiem/conf.ini`  

    You can setup the configuration by command line with `msiempy_setup.py` script at https://github.com/mfesiem/msiempy/blob/master/samples/msiempy_setup.py.  
    

    Arguments: 

    - `path`: Config file special path, if path is left None, will automatically look for it.  
    - `config`: Manual config dict. ex: `{&#39;general&#39;:{&#39;verbose&#39;:True}}`.  
    - `*args, **kwargs` : Passed to `configparser.ConfigParser.__init__()` method.

    &#34;&#34;&#34;
    def __init__(self, path=None, config=None, *arg, **kwarg):
        super().__init__(*arg, **kwarg)
        if not path : self._path = self.find_ini_location()
        else : self._path = path
        files=self.read(self._path)
        if len(files) == 0:
            log.info(&#34;Config file inexistant or currupted, applying defaults&#34;)
            self.read_dict(self.DEFAULT_CONF_DICT)
            if not os.path.exists(os.path.dirname(self._path)):
                os.makedirs(os.path.dirname(self._path))
            self.write()
        else:
            log.info(&#34;Successfuly read config file {}&#34;.format(files[0]))
        if config != None :
            log.info(&#34;Reading config_dict : &#34;+str(self))
            self.read_dict(config)

    CONFIG_FILE_NAME=&#39;.msiem/conf.ini&#39;
    &#34;&#34;&#34;`.msiem/conf.ini`&#34;&#34;&#34;

    CONF_DIR=&#39;.msiem/&#39;
    &#34;&#34;&#34;`.msiem/`&#34;&#34;&#34;

    DEFAULT_CONF_DICT={
        &#39;esm&#39;:{&#39;host&#39;:&#39;&#39;, 
            &#39;user&#39;:&#39;&#39;,
            &#39;passwd&#39;:&#39;&#39;},
        &#39;general&#39;:{&#39;verbose&#39;:False,
            &#39;quiet&#39;:False,
            &#39;logfile&#39;:&#39;&#39;,
            &#39;timeout&#39;:60,
            &#39;ssl_verify&#39;:False}
    }
    &#34;&#34;&#34;
    Default configuration values.
    &#34;&#34;&#34;

    def __str__(self):
        &#34;&#34;&#34;
        Custom str() method that lists all config fields.
        &#34;&#34;&#34;
        return(&#39;Configuration file : &#39;+ self._path+&#39;\n&#39;+str({section: dict(self[section]) for section in self.sections()}))

    def write(self):
        &#34;&#34;&#34;Write the config file to the predetermined path.
        &#34;&#34;&#34;
        with open(self._path, &#39;w&#39;) as conf:
            super().write(conf)
            log.info(&#34;Config file has been written at &#34;+self._path)

    def _iset(self, section, option, secure=False):
        &#34;&#34;&#34;Internal method to interactively set  a option in a section.
        &#34;&#34;&#34;
        msg=&#39;Enter [{}]{}&#39;
        value = self.get(section, option)
        newvalue=&#39;&#39;
        if option==&#39;passwd&#39;: secure=True
        if secure : newvalue = tob64(getpass.getpass(msg.format(section, option)+&#39;. Press &lt;Enter&gt; to skip: &#39;))
        else: newvalue = input(msg.format(section, option)+ &#39;. Press &lt;Enter&gt; to keep &#39;+ (value if (str(value) != &#39;&#39;) else &#39;empty&#39;) + &#39;: &#39;)
        if newvalue != &#39;&#39; : super().set(section, option, newvalue)

    def iset(self, section, option=None, secure=False):
        &#34;&#34;&#34;Interactively set the specified section/option by asking the user the input.  
        Arguments:  

        - `section`: Configuration&#39;s section. Exemple : &#39;esm&#39; or &#39;general&#39;.  
        - `option`: Configuraion&#39;s option. Leave to `None` to set the whole section one after another. Exemple : &#39;user&#39;, &#39;timeout&#39;.  
        - `secure`: Will use getpass to retreive the configuration value and won&#39;t print old value.
        &#34;&#34;&#34;
        if option is None :
            for key in self.options(section):
                self._iset(section, key, secure)
        else : self._iset(section, option, secure)

    @property
    def user(self): return self.get(&#39;esm&#39;, &#39;user&#39;)
    @property
    def host(self): return self.get(&#39;esm&#39;, &#39;host&#39;)
    @property
    def passwd(self): return self.get(&#39;esm&#39;, &#39;passwd&#39;)
    @property
    def verbose(self): return self.getboolean(&#39;general&#39;, &#39;verbose&#39;)
    @property
    def quiet(self): return self.getboolean(&#39;general&#39;, &#39;quiet&#39;)
    @property
    def logfile(self): return self.get(&#39;general&#39;, &#39;logfile&#39;)
    @property
    def timeout(self): return self.getint(&#39;general&#39;, &#39;timeout&#39;)
    @property
    def ssl_verify(self): return self.getboolean(&#39;general&#39;, &#39;ssl_verify&#39;)

    @staticmethod
    def find_ini_location():
        &#39;&#39;&#39;
        Returns the location of a supposed conf.ini file the `conf.ini` file.  
        If `.msiem` folder exists in you local directory, assume the `conf.ini` file is in there.  
        If the file doesn&#39;t exist, will still return the location.  
        Do not create a file nor directory, you must call `msiempy.NitroConfig.write`.  
        &#39;&#39;&#39;
        conf_path_dir=None
        if os.path.isdir(&#39;./&#39;+NitroConfig.CONF_DIR): conf_path_dir=&#39;./&#39;
        elif &#39;APPDATA&#39; in os.environ: conf_path_dir = os.environ[&#39;APPDATA&#39;]
        elif &#39;XDG_CONFIG_HOME&#39; in os.environ: conf_path_dir = os.environ[&#39;XDG_CONFIG_HOME&#39;]
        elif &#39;HOME&#39; in os.environ: conf_path_dir = os.path.join(os.environ[&#39;HOME&#39;])
        else: conf_path_dir=&#39;./&#39;
        #Join configuartion filename with supposed parent directory
        conf_path=(os.path.join(conf_path_dir, NitroConfig.CONFIG_FILE_NAME))
        return(conf_path)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>configparser.ConfigParser</li>
<li>configparser.RawConfigParser</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.NitroConfig.CONFIG_FILE_NAME"><code class="name">var <span class="ident">CONFIG_FILE_NAME</span></code></dt>
<dd>
<div class="desc"><p><code>.msiem/conf.ini</code></p></div>
</dd>
<dt id="msiempy.NitroConfig.CONF_DIR"><code class="name">var <span class="ident">CONF_DIR</span></code></dt>
<dd>
<div class="desc"><p><code>.msiem/</code></p></div>
</dd>
<dt id="msiempy.NitroConfig.DEFAULT_CONF_DICT"><code class="name">var <span class="ident">DEFAULT_CONF_DICT</span></code></dt>
<dd>
<div class="desc"><p>Default configuration values.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="msiempy.NitroConfig.find_ini_location"><code class="name flex">
<span>def <span class="ident">find_ini_location</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the location of a supposed conf.ini file the <code>conf.ini</code> file.<br>
If <code>.msiem</code> folder exists in you local directory, assume the <code>conf.ini</code> file is in there.<br>
If the file doesn't exist, will still return the location.<br>
Do not create a file nor directory, you must call <code><a title="msiempy.NitroConfig.write" href="#msiempy.NitroConfig.write">NitroConfig.write()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def find_ini_location():
    &#39;&#39;&#39;
    Returns the location of a supposed conf.ini file the `conf.ini` file.  
    If `.msiem` folder exists in you local directory, assume the `conf.ini` file is in there.  
    If the file doesn&#39;t exist, will still return the location.  
    Do not create a file nor directory, you must call `msiempy.NitroConfig.write`.  
    &#39;&#39;&#39;
    conf_path_dir=None
    if os.path.isdir(&#39;./&#39;+NitroConfig.CONF_DIR): conf_path_dir=&#39;./&#39;
    elif &#39;APPDATA&#39; in os.environ: conf_path_dir = os.environ[&#39;APPDATA&#39;]
    elif &#39;XDG_CONFIG_HOME&#39; in os.environ: conf_path_dir = os.environ[&#39;XDG_CONFIG_HOME&#39;]
    elif &#39;HOME&#39; in os.environ: conf_path_dir = os.path.join(os.environ[&#39;HOME&#39;])
    else: conf_path_dir=&#39;./&#39;
    #Join configuartion filename with supposed parent directory
    conf_path=(os.path.join(conf_path_dir, NitroConfig.CONFIG_FILE_NAME))
    return(conf_path)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.NitroConfig.user"><code class="name">var <span class="ident">user</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def user(self): return self.get(&#39;esm&#39;, &#39;user&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.host"><code class="name">var <span class="ident">host</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def host(self): return self.get(&#39;esm&#39;, &#39;host&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.passwd"><code class="name">var <span class="ident">passwd</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def passwd(self): return self.get(&#39;esm&#39;, &#39;passwd&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def verbose(self): return self.getboolean(&#39;general&#39;, &#39;verbose&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.quiet"><code class="name">var <span class="ident">quiet</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def quiet(self): return self.getboolean(&#39;general&#39;, &#39;quiet&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.logfile"><code class="name">var <span class="ident">logfile</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def logfile(self): return self.get(&#39;general&#39;, &#39;logfile&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.timeout"><code class="name">var <span class="ident">timeout</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def timeout(self): return self.getint(&#39;general&#39;, &#39;timeout&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.ssl_verify"><code class="name">var <span class="ident">ssl_verify</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ssl_verify(self): return self.getboolean(&#39;general&#39;, &#39;ssl_verify&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.NitroConfig.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the config file to the predetermined path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self):
    &#34;&#34;&#34;Write the config file to the predetermined path.
    &#34;&#34;&#34;
    with open(self._path, &#39;w&#39;) as conf:
        super().write(conf)
        log.info(&#34;Config file has been written at &#34;+self._path)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroConfig.iset"><code class="name flex">
<span>def <span class="ident">iset</span></span>(<span>self, section, option=None, secure=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Interactively set the specified section/option by asking the user the input.<br>
Arguments:
</p>
<ul>
<li><code>section</code>: Configuration's section. Exemple : 'esm' or 'general'.
</li>
<li><code>option</code>: Configuraion's option. Leave to <code>None</code> to set the whole section one after another. Exemple : 'user', 'timeout'.
</li>
<li><code>secure</code>: Will use getpass to retreive the configuration value and won't print old value.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iset(self, section, option=None, secure=False):
    &#34;&#34;&#34;Interactively set the specified section/option by asking the user the input.  
    Arguments:  

    - `section`: Configuration&#39;s section. Exemple : &#39;esm&#39; or &#39;general&#39;.  
    - `option`: Configuraion&#39;s option. Leave to `None` to set the whole section one after another. Exemple : &#39;user&#39;, &#39;timeout&#39;.  
    - `secure`: Will use getpass to retreive the configuration value and won&#39;t print old value.
    &#34;&#34;&#34;
    if option is None :
        for key in self.options(section):
            self._iset(section, key, secure)
    else : self._iset(section, option, secure)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="msiempy.NitroSession"><code class="flex name class">
<span>class <span class="ident">NitroSession</span></span>
<span>(</span><span>conf_path=None, conf_dict=None)</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="msiempy.NitroSession" href="#msiempy.NitroSession">NitroSession</a></code> is the point of convergence of every request to the McAfee ESM.<br>
It provides standard dialogue with the ESM by doing agument interpolation with <code><a title="msiempy.NitroSession.PARAMS" href="#msiempy.NitroSession.PARAMS">NitroSession.PARAMS</a></code>.<br>
Internal <code>__dict__</code> refers to a unique instance of dict and thus, properties can be instanciated only once.<br>
It uses <code><a title="msiempy.NitroConfig" href="#msiempy.NitroConfig">NitroConfig</a></code> to setup authentication, other configuration like verbosity, logfile, general timeout, are offered throught the config file.</p>
<p>The init method is called every time you call NitroSession() constructor. But the properties are actually initiated only once.<br>
Use <code>logout()</code> to reinstanciate NitroSession.
</p>
<p>Arguments:
</p>
<ul>
<li><code>conf_path</code> : Configuration file path.
</li>
<li><code>conf_dict</code> : Manual config dict. ex: <code>{'general':{'verbose':True}}</code>. See <code><a title="msiempy.NitroConfig" href="#msiempy.NitroConfig">NitroConfig</a></code> class to have full details.</li>
</ul>
<p>Usages:</p>
<pre><code>
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NitroSession():
    &#34;&#34;&#34;
    `msiempy.NitroSession` is the point of convergence of every request to the McAfee ESM.  
    It provides standard dialogue with the ESM by doing agument interpolation with `msiempy.NitroSession.PARAMS`.  
    Internal `__dict__` refers to a unique instance of dict and thus, properties can be instanciated only once.  
    It uses `msiempy.NitroConfig` to setup authentication, other configuration like verbosity, logfile, general timeout, are offered throught the config file.

    The init method is called every time you call NitroSession() constructor. But the properties are actually initiated only once.  
    Use `logout()` to reinstanciate NitroSession.  

    Arguments:  

    - `conf_path` : Configuration file path.  
    - `conf_dict` : Manual config dict. ex: `{&#39;general&#39;:{&#39;verbose&#39;:True}}`. See `msiempy.NitroConfig` class to have full details.

    Usages:
    ```

    ```
    &#34;&#34;&#34;
    def __init__(self, conf_path=None, conf_dict=None):
        global log
        self.__dict__ = NitroSession.__unique_state__
        
        #Init properties only once
        if NitroSession.__initiated__ == False :
            NitroSession.__initiated__ = True
            
            #Private attributes
            self._headers={&#39;Content-Type&#39;: &#39;application/json&#39;}
            
            #Config parsing
            self.config = NitroConfig(path=conf_path, config=conf_dict)
            NitroSession.config=self.config

            #Set the logging configuration
            self._init_log(verbose=self.config.verbose,
                quiet=self.config.quiet,
                logfile=self.config.logfile)

            self.api_v = 0
            self.logged_in=False
            self.login_info=dict()

    

    BASE_URL = &#39;https://{}/rs/esm/&#39;
    &#34;&#34;&#34;API v2 base url: &#39;https://{}/rs/esm/&#39;&#34;&#34;&#34;

    BASE_URL_PRIV = &#39;https://{}/ess/&#39;
    &#34;&#34;&#34;Private API base URL: &#39;https://{}/ess/&#39;&#34;&#34;&#34;

    __initiated__ = False
    &#34;&#34;&#34;
    Weither the session has been intaciated. It&#39;s supposed to be a singleton.
    &#34;&#34;&#34;
    __unique_state__ = {}
    &#34;&#34;&#34;
    The singleton unique state.
    &#34;&#34;&#34;
    
    config = None
    &#34;&#34;&#34;
    `msiempy.NitroConfig` object.  
    &#34;&#34;&#34;
    
    PARAMS = {
        &#34;login&#34;: (&#34;login&#34;,
                &#34;&#34;&#34;{&#34;username&#34;: &#34;%(username)s&#34;,
                    &#34;password&#34; : &#34;%(password)s&#34;,
                    &#34;locale&#34;: &#34;en_US&#34;,
                    &#34;os&#34;: &#34;Win32&#34;}
                    &#34;&#34;&#34;),

        &#34;get_devtree&#34;: (&#34;GRP_GETVIRTUALGROUPIPSLISTDATA&#34;,
                        &#34;&#34;&#34;{&#34;ITEMS&#34;: &#34;#{DC1 + DC2}&#34;,
                            &#34;DID&#34;: &#34;1&#34;,
                            &#34;HD&#34;: &#34;F&#34;,
                            &#34;NS&#34;: &#34;0&#34;}
                        &#34;&#34;&#34;),

        &#34;get_zones_devtree&#34;: (&#34;GRP_GETVIRTUALGROUPIPSLISTDATA&#34;,
                        &#34;&#34;&#34;{&#34;ITEMS&#34;: &#34;#{DC1 + DC2}&#34;,
                            &#34;DID&#34;: &#34;3&#34;,
                            &#34;HD&#34;: &#34;F&#34;,
                            &#34;NS&#34;: &#34;0&#34;}
                        &#34;&#34;&#34;),

        &#34;req_client_str&#34;: (&#34;DS_GETDSCLIENTLIST&#34;,
                            &#34;&#34;&#34;{&#34;DSID&#34;: &#34;%(ds_id)s&#34;,
                                &#34;SEARCH&#34;: &#34;&#34;}
                            &#34;&#34;&#34;),

        &#34;get_rfile&#34;: (&#34;MISC_READFILE&#34;,
                    &#34;&#34;&#34;{&#34;FNAME&#34;: &#34;%(ftoken)s&#34;,
                    &#34;SPOS&#34;: &#34;0&#34;,
                    &#34;NBYTES&#34;: &#34;0&#34;}
                    &#34;&#34;&#34;),

        &#34;del_rfile&#34;: (&#34;ESSMGT_DELETEFILE&#34;,
                    &#34;&#34;&#34;{&#34;FN&#34;: &#34;%(ftoken)s&#34;}&#34;&#34;&#34;),

        &#34;get_rfile2&#34;: (&#34;MISC_READFILE&#34;,
                    &#34;&#34;&#34;{&#34;FNAME&#34;: &#34;%(ftoken)s&#34;,
                    &#34;SPOS&#34;: &#34;%(pos)s&#34;,
                    &#34;NBYTES&#34;: &#34;%(nbytes)s&#34;}
                    &#34;&#34;&#34;),

        &#34;get_wfile&#34;: (&#34;MISC_WRITEFILE&#34;,
                    &#34;&#34;&#34;{&#34;DATA1&#34;: &#34;%(ds_id)s&#34;,
                         &#34;PATH&#34;: &#34;21&#34;,
                         &#34;ND&#34;: &#34;1&#34;} &#34;&#34;&#34;),
        
        &#34;get_rule_history&#34;: (&#34;PLCY_GETRULECHANGEINFO&#34;, 
                            &#34;&#34;&#34;{&#34;SHOW&#34;: &#34;F&#34;}&#34;&#34;&#34;),

        &#34;map_dtree&#34;: (&#34;map_dtree&#34;,
                    &#34;&#34;&#34;{&#34;dev_type&#34;: &#34;%(dev_type)s&#34;,
                    &#34;name&#34;: &#34;%(ds_name)s&#34;,
                    &#34;ds_id&#34;: &#34;%(ds_id)s&#34;,
                    &#34;enabled&#34;: &#34;%(enabled)s&#34;,
                    &#34;ds_ip&#34;: &#34;%(ds_ip)s&#34;,
                    &#34;hostname&#34; : &#34;%(hostname)s&#34;,
                    &#34;typeID&#34;: &#34;%(type_id)s&#34;,
                    &#34;vendor&#34;: &#34;&#34;,
                    &#34;model&#34;: &#34;&#34;,
                    &#34;tz_id&#34;: &#34;&#34;,
                    &#34;date_order&#34;: &#34;&#34;,
                    &#34;port&#34;: &#34;&#34;,
                    &#34;syslog_tls&#34;: &#34;&#34;,
                    &#34;client_groups&#34;: &#34;%(client_groups)s&#34;
                    }
                    &#34;&#34;&#34;),

        &#34;add_ds_11_1_3&#34;: (&#34;dsAddDataSource&#34;, 
                    &#34;&#34;&#34;{&#34;datasource&#34;: {
                            &#34;parentId&#34;: {&#34;id&#34;: &#34;%(parent_id)s&#34;},
                            &#34;name&#34;: &#34;%(name)s&#34;,
                            &#34;ipAddress&#34;: &#34;%(ds_ip)s&#34;,
                            &#34;typeId&#34;: {&#34;id&#34;: &#34;%(type_id)s&#34;},
                            &#34;zoneId&#34;: &#34;%(zone_id)s&#34;,
                            &#34;enabled&#34;: &#34;%(enabled)s&#34;,
                            &#34;url&#34;: &#34;%(url)s&#34;,
                            &#34;id&#34;: {&#34;id&#34;: &#34;%(ds_id)s&#34;},
                            &#34;childEnabled&#34;: &#34;%(child_enabled)s&#34;,
                            &#34;childCount&#34;: &#34;%(child_count)s&#34;,
                            &#34;childType&#34;: &#34;%(child_type)s&#34;,
                            &#34;idmId&#34;: &#34;%(idm_id)s&#34;,
                            &#34;parameters&#34;: %(parameters)s
                        }}&#34;&#34;&#34;),

        &#34;add_ds_11_2_1&#34;: (&#34;dsAddDataSources&#34;, 
                        &#34;&#34;&#34;{&#34;receiverId&#34;: &#34;%(parent_id)s&#34;,
                            &#34;datasources&#34;: [{
                                &#34;name&#34;: &#34;%(name)s&#34;,
                                &#34;ipAddress&#34;: &#34;%(ds_ip)s&#34;,
                                &#34;typeId&#34;: {&#34;id&#34;: &#34;%(type_id)s&#34;},
                                &#34;zoneId&#34;: &#34;%(zone_id)s&#34;,
                                &#34;enabled&#34;: &#34;%(enabled)s&#34;,
                                &#34;url&#34;: &#34;%(url)s&#34;,
                                &#34;parameters&#34;: %(parameters)s
                                }]}&#34;&#34;&#34;),

        &#34;add_client1&#34;: (&#34;DS_ADDDSCLIENT&#34;, 
                        &#34;&#34;&#34;{&#34;PID&#34;: &#34;%(parent_id)s&#34;,
                        &#34;NAME&#34;: &#34;%(name)s&#34;,
                        &#34;ENABLED&#34;: &#34;%(enabled)s&#34;,
                        &#34;IP&#34;: &#34;%(ds_ip)s&#34;,
                        &#34;HOST&#34;: &#34;%(hostname)s&#34;,
                        &#34;TYPE&#34;: &#34;%(type_id)s&#34;,
                        &#34;TZID&#34;: &#34;%(tz_id)s&#34;,
                        &#34;DORDER&#34;: &#34;%(dorder)s&#34;,
                        &#34;MASKFLAG&#34;: &#34;%(maskflag)s&#34;,
                        &#34;PORT&#34;: &#34;%(port)s&#34;,
                        &#34;USETLS&#34;: &#34;%(require_tls)s&#34;
                        }&#34;&#34;&#34;),
                        
        &#34;get_recs&#34;: (&#34;devGetDeviceList?filterByRights=false&#34;,
                        &#34;&#34;&#34;{&#34;types&#34;: [&#34;RECEIVER&#34;]}
                        &#34;&#34;&#34;),

        &#34;get_dstypes&#34;: (&#34;dsGetDataSourceTypes&#34;,
                        &#34;&#34;&#34;{&#34;receiverId&#34;: {&#34;id&#34;: &#34;%(rec_id)s&#34;}
                            }
                        &#34;&#34;&#34;),
                        
        &#34;del_ds1&#34;: (&#34;dsDeleteDataSource&#34;,
                    &#34;&#34;&#34;{&#34;receiverId&#34;: {&#34;id&#34;: &#34;%(parent_id)s&#34;},
                        &#34;datasourceId&#34;: {&#34;id&#34;: &#34;%(ds_id)s&#34;}}
                    &#34;&#34;&#34;),

        &#34;del_ds2&#34;: (&#34;dsDeleteDataSources&#34;,
                    &#34;&#34;&#34;{&#34;receiverId&#34;: {&#34;value&#34;: &#34;%(parent_id)s&#34;},
                        &#34;datasourceIds&#34;: [{&#34;value&#34;: &#34;%(ds_id)s&#34;}]}
                    &#34;&#34;&#34;),

        &#34;del_client&#34;: (&#34;DS_DELETEDSCLIENTS&#34;, 
                        &#34;&#34;&#34;{&#34;DID&#34;: &#34;%(parent_id)s&#34;,
                             &#34;FTOKEN&#34;: &#34;%(ftoken)s&#34;}&#34;&#34;&#34;
                        ),

        &#34;get_job_status&#34;: (&#34;MISC_JOBSTATUS&#34;,
                            &#34;&#34;&#34;{&#34;JID&#34;: &#34;%(job_id)s&#34;}&#34;&#34;&#34;),

        &#34;ds_last_times&#34;: (&#34;QRY_GETDEVICELASTALERTTIME&#34;,&#34;&#34;&#34;{}&#34;&#34;&#34;),
                        
        &#34;zonetree&#34;: (&#34;zoneGetZoneTree&#34;,None),
                        
        &#34;ds_by_type&#34;: (&#34;QRY_GETDEVICECOUNTBYTYPE&#34;,None),

        &#34;_dev_types&#34;:  (&#34;dev_type_map&#34;,
                            &#34;&#34;&#34;{&#34;1&#34;: &#34;zone&#34;,
                                &#34;2&#34;: &#34;ERC&#34;,
                                &#34;3&#34;: &#34;datasource&#34;,
                                &#34;4&#34;: &#34;Database Event Monitor (DBM)&#34;,
                                &#34;5&#34;: &#34;DBM Database&#34;,
                                &#34;7&#34;: &#34;Policy Auditor&#34;,
                                &#34;10&#34;: &#34;Application Data Monitor (ADM)&#34;,
                                &#34;12&#34;: &#34;ELM&#34;,
                                &#34;14&#34;: &#34;Local ESM&#34;,
                                &#34;15&#34;: &#34;Advanced Correlation Engine (ACE)&#34;,
                                &#34;16&#34;: &#34;Asset datasource&#34;,
                                &#34;17&#34;: &#34;Score-based Correlation&#34;,
                                &#34;19&#34;: &#34;McAfee ePolicy Orchestrator (ePO)&#34;,
                                &#34;20&#34;: &#34;EPO&#34;,
                                &#34;21&#34;: &#34;McAfee Network Security Manager (NSM)&#34;,
                                &#34;22&#34;: &#34;McAfee Network Security Platform (NSP)&#34;,
                                &#34;23&#34;: &#34;NSP Port&#34;,
                                &#34;24&#34;: &#34;McAfee Vulnerability Manager (MVM)&#34;,
                                &#34;25&#34;: &#34;Enterprise Log Search (ELS)&#34;,
                                &#34;254&#34;: &#34;client_group&#34;,
                                &#34;256&#34;: &#34;client&#34;}
                            &#34;&#34;&#34;),
                            
            &#34;ds_details1&#34;: (&#34;dsGetDataSourceDetail&#34;,
                            &#34;&#34;&#34;{&#34;datasourceId&#34;: 
                                {&#34;id&#34;: &#34;%(ds_id)s&#34;}}
                            &#34;&#34;&#34;),

            &#34;ds_details2&#34;: (&#34;dsGetDataSourceDetail&#34;,
                            &#34;&#34;&#34;{&#34;datasourceId&#34;: {&#34;value&#34;: &#34;%(ds_id)s&#34;}}&#34;&#34;&#34;),


            &#34;get_alarms_custom_time&#34;: (&#34;&#34;&#34;alarmGetTriggeredAlarms?triggeredTimeRange=%(time_range)s&amp;customStart=%(start_time)s&amp;customEnd=%(end_time)s&amp;status=%(status)s&amp;pageSize=%(page_size)s&amp;pageNumber=%(page_number)s&#34;&#34;&#34;,
                        None),

            &#34;get_alarms&#34;: (&#34;&#34;&#34;alarmGetTriggeredAlarms?triggeredTimeRange=%(time_range)s&amp;status=%(status)s&amp;pageSize=%(page_size)s&amp;pageNumber=%(page_number)s&#34;&#34;&#34;, None),

            &#34;get_alarm_details&#34;: (&#34;&#34;&#34;notifyGetTriggeredNotification&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;id&#34;:%(id)s}&#34;&#34;&#34;),

            &#34;get_alarm_details_int&#34;: (&#34;NOTIFY_GETTRIGGEREDNOTIFICATIONDETAIL&#34;, 
                                        &#34;&#34;&#34;{&#34;TID&#34;: &#34;%(id)s&#34;}&#34;&#34;&#34;),

            &#34;ack_alarms&#34;: (&#34;&#34;&#34;alarmAcknowledgeTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:[{&#34;value&#34;:%(ids)s}]}&#34;&#34;&#34;),

            &#34;ack_alarms_11_2_1&#34;: (&#34;&#34;&#34;alarmAcknowledgeTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:{&#34;alarmIdList&#34;:[%(ids)s]}}&#34;&#34;&#34;),

            &#34;unack_alarms&#34;: (&#34;&#34;&#34;alarmUnacknowledgeTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:[{&#34;value&#34;:%(ids)s}]}&#34;&#34;&#34;),

            &#34;unack_alarms_11_2_1&#34;: (&#34;&#34;&#34;alarmUnacknowledgeTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:{&#34;alarmIdList&#34;:[%(ids)s]}}&#34;&#34;&#34;),

            &#34;delete_alarms&#34;: (&#34;&#34;&#34;alarmDeleteTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:[{&#34;value&#34;:%(ids)s}]}&#34;&#34;&#34;),
            
            &#34;delete_alarms_11_2_1&#34;: (&#34;&#34;&#34;alarmDeleteTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:{&#34;alarmIdList&#34;:[%(ids)s]}}&#34;&#34;&#34;),

            &#34;get_possible_filters&#34; : ( &#34;&#34;&#34;qryGetFilterFields&#34;&#34;&#34;, None ),

            &#34;get_possible_fields&#34; : ( &#34;&#34;&#34;qryGetSelectFields?type=%(type)s&amp;groupType=%(groupType)s&#34;&#34;&#34;, None ),

            &#34;get_esm_time&#34; : ( &#34;&#34;&#34;essmgtGetESSTime&#34;&#34;&#34;,None),

            &#34;get_alerts_now&#34; : (&#34;&#34;&#34;IPS_GETALERTSNOW&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;IPSID&#34;: &#34;%(ds_id)s&#34;}&#34;&#34;&#34;),

            &#34;get_flows_now&#34; : (&#34;&#34;&#34;IPS_GETALERTSNOW&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;IPSID&#34;: &#34;%(ds_id)s&#34;}&#34;&#34;&#34;),

            &#34;logout&#34; : ( &#34;&#34;&#34;userLogout&#34;&#34;&#34;, None ),

            &#34;get_user_locale&#34; : ( &#34;&#34;&#34;getUserLocale&#34;&#34;&#34;, None ),

            &#34;event_query_custom_time&#34; : (&#34;&#34;&#34;qryExecuteDetail?type=EVENT&amp;reverse=false&#34;&#34;&#34;, &#34;&#34;&#34;{
                    &#34;config&#34;: {
                        &#34;timeRange&#34;: &#34;%(time_range)s&#34;,
                        &#34;customStart&#34;: &#34;%(start_time)s&#34;,
                        &#34;customEnd&#34;: &#34;%(end_time)s&#34;,
                        &#34;fields&#34;: %(fields)s,
                        &#34;filters&#34;: %(filters)s,
                        &#34;limit&#34;: %(limit)s,
                        &#34;offset&#34;: %(offset)s,
                        &#34;order&#34;: [{&#34;field&#34;: {&#34;name&#34;: &#34;%(order_field)s&#34;},
                                             &#34;direction&#34;: &#34;%(order_direction)s&#34;}]
                        }
                        }&#34;&#34;&#34;),

            &#34;event_query&#34; : (&#34;&#34;&#34;qryExecuteDetail?type=EVENT&amp;reverse=false&#34;&#34;&#34;, &#34;&#34;&#34;{
                    &#34;config&#34;: {
                        &#34;timeRange&#34;:&#34;%(time_range)s&#34;,
                        &#34;fields&#34;:%(fields)s,
                        &#34;filters&#34;:%(filters)s,
                        &#34;limit&#34;:%(limit)s,
                        &#34;offset&#34;:%(offset)s,
                        &#34;order&#34;: [{&#34;field&#34;: {&#34;name&#34;: &#34;%(order_field)s&#34;},
                                             &#34;direction&#34;: &#34;%(order_direction)s&#34;}]
                        }
                        }&#34;&#34;&#34;),

            &#34;query_status&#34; : (&#34;&#34;&#34;qryGetStatus&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;resultID&#34;: %(resultID)s}&#34;&#34;&#34;),

            &#34;query_result&#34; : (&#34;&#34;&#34;qryGetResults?startPos=%(startPos)s&amp;numRows=%(numRows)s&amp;reverse=false&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;resultID&#34;: %(resultID)s}&#34;&#34;&#34;),
            
            &#34;time_zones&#34; : (&#34;&#34;&#34;userGetTimeZones&#34;&#34;&#34;, None),

            &#34;logout&#34; : (&#34;&#34;&#34;logout&#34;&#34;&#34;, None),
            
            &#34;add_note_to_event&#34; : (&#34;&#34;&#34;ipsAddAlertNote&#34;&#34;&#34;, &#34;&#34;&#34;{
                &#34;id&#34;: {&#34;value&#34;: &#34;%(id)s&#34;},
                &#34;note&#34;: {&#34;note&#34;: &#34;%(note)s&#34;}
            }&#34;&#34;&#34;),

            &#34;add_note_to_event_int&#34;: (&#34;&#34;&#34;IPS_ADDALERTNOTE&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;AID&#34;: &#34;%(id)s&#34;,
                                                               &#34;NOTE&#34;: &#34;%(note)s&#34;}&#34;&#34;&#34;),

            &#34;get_wl_types&#34;: (&#34;&#34;&#34;sysGetWatchlistFields&#34;&#34;&#34;, None),
            &#34;get_watchlists_no_filters&#34; : (&#34;&#34;&#34;sysGetWatchlists?hidden=%(hidden)s&amp;dynamic=%(dynamic)s&amp;writeOnly=%(writeOnly)s&amp;indexedOnly=%(indexedOnly)s&#34;&#34;&#34;, 
                None),

            &#34;get_watchlist_details&#34;: (&#34;&#34;&#34;sysGetWatchlistDetails&#34;&#34;&#34;,&#34;&#34;&#34;{&#34;id&#34;: %(id)s}&#34;&#34;&#34;),

            &#34;add_watchlist&#34;: (&#34;&#34;&#34;sysAddWatchlist&#34;&#34;&#34;, &#34;&#34;&#34;{
                &#34;watchlist&#34;: {
                    &#34;name&#34;: &#34;%(name)s&#34;,
                    &#34;type&#34;: {&#34;name&#34;: &#34;%(wl_type)s&#34;,
                              &#34;id&#34;: 0},
                    &#34;customType&#34;: {&#34;name&#34;: &#34;&#34;,
                                   &#34;id&#34;: 0},
                    &#34;dynamic&#34;: &#34;False&#34;,
                    &#34;enabled&#34;: &#34;True&#34;,
                    &#34;search&#34;: &#34;&#34;,
                    &#34;source&#34;: 0,
                    &#34;updateType&#34;: &#34;EVERY_SO_MANY_MINUTES&#34;,
                    &#34;updateDay&#34;: 0,
                    &#34;updateMin&#34;: 0,
                    &#34;ipsid&#34;: &#34;0&#34;,
                    &#34;valueFile&#34;: {&#34;fileToken&#34;: &#34;&#34;},
                    &#34;dbUrl&#34;: &#34;&#34;,
                    &#34;mountPoint&#34;: &#34;&#34;,    
                    &#34;path&#34;: &#34;&#34;,
                    &#34;port&#34;: &#34;22&#34;,
                    &#34;username&#34;: &#34;&#34;,
                    &#34;password&#34;: &#34;&#34;,
                    &#34;query&#34;: &#34;&#34;,
                    &#34;lookup&#34;: &#34;&#34;,
                    &#34;jobTrackerURL&#34;: &#34;&#34;,
                    &#34;jobTrackerPort&#34;: &#34;&#34;,
                    &#34;postArgs&#34;: &#34;&#34;,
                    &#34;ignoreRegex&#34;: &#34;&#34;,
                    &#34;method&#34;: 0,
                    &#34;matchRegex&#34;: &#34;&#34;,
                    &#34;lineSkip&#34;: 0,
                    &#34;delimitRegex&#34;: &#34;&#34;,
                    &#34;groups&#34;: 1
                              }}&#34;&#34;&#34;),
                                                            
            &#34;add_watchlist_values&#34;: (&#34;&#34;&#34;sysAddWatchlistValues&#34;&#34;&#34;,&#34;&#34;&#34;{
                &#34;watchlist&#34;: %(watchlist)s,
                &#34;values&#34;: %(values)s,
                }&#34;&#34;&#34;),

            &#34;get_watchlist_values&#34;: (&#34;SYS_GETWATCHLISTDETAILS&#34;,
                                            &#34;&#34;&#34;{&#34;WID&#34;: &#34;%(id)s&#34;, &#34;LIM&#34;: &#34;T&#34;}&#34;&#34;&#34;),

            &#34;remove_watchlists&#34;: (&#34;&#34;&#34;sysRemoveWatchlist&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;ids&#34;: {&#34;watchlistIdList&#34;: [&#34;%(wl_id_list)s&#34;]}}&#34;&#34;&#34;),

            &#34;get_alert_data&#34;: (&#34;&#34;&#34;ipsGetAlertData&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;id&#34;: {&#34;value&#34;:&#34;%(id)s&#34;}}&#34;&#34;&#34;),
            
            &#34;get_sys_info&#34;  : (&#34;SYS_GETSYSINFO&#34;,&#34;&#34;&#34;{}&#34;&#34;&#34;),
            
            &#34;build_stamp&#34; : (&#34;essmgtGetBuildStamp&#34;,None)
    } #__pdoc__[&#39;NitroSession.PARAMS&#39;] = 
    &#39;&#39;&#39;This structure provide a central place to aggregate API methods and parameters.  
    The parameters are stored as docstrings to support string replacement.  

    Args:  
        - `method` (str): Dict key associated with desired function
        Use normal dict access, PARAMS[&#34;method&#34;], or PARAMS.get(&#34;method&#34;)

    Returns:  
        - `tuple `: (string, string) : The first string is the method name that is actually used as
        the URI or passed to the ESM. The second string is the params
        required for that method. Some params require variables be
        interpolated as documented in the data structure.
    
    Usage exemple in `msiempy.NitroSession.request` source code.  

    Important note : 
        Do not use sigle quotes (`&#39;`) to delimit data into the interpolated strings !

    Data structure example :  
    ```
    {
        &#34;login&#34;: (&#34;login&#34;,
                &#34;&#34;&#34;{&#34;username&#34;: &#34;%(username)s&#34;,
                    &#34;password&#34; : &#34;%(password)s&#34;,
                    &#34;locale&#34;: &#34;en_US&#34;,
                    &#34;os&#34;: &#34;Win32&#34;}
                    &#34;&#34;&#34;),
        
        &#34;add_watchlist_values&#34;: (&#34;&#34;&#34;sysAddWatchlistValues&#34;&#34;&#34;,&#34;&#34;&#34;{
                &#34;watchlist&#34;: %(watchlist)s,
                &#34;values&#34;: %(values)s,
                }&#34;&#34;&#34;),

        &#34;get_watchlist_values&#34;: (&#34;SYS_GETWATCHLISTDETAILS&#34;,
                                        &#34;&#34;&#34;{&#34;WID&#34;: &#34;%(id)s&#34;, &#34;LIM&#34;: &#34;T&#34;}&#34;&#34;&#34;),

        &#34;remove_watchlists&#34;: (&#34;&#34;&#34;sysRemoveWatchlist&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;ids&#34;: {&#34;watchlistIdList&#34;: [&#34;%(wl_id_list)s&#34;]}}&#34;&#34;&#34;),

        &#34;get_alert_data&#34;: (&#34;&#34;&#34;ipsGetAlertData&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;id&#34;: {&#34;value&#34;:&#34;%(id)s&#34;}}&#34;&#34;&#34;),
        
        &#34;get_sys_info&#34;  : (&#34;SYS_GETSYSINFO&#34;,&#34;&#34;&#34;{}&#34;&#34;&#34;),
        
        &#34;build_stamp&#34; : (&#34;essmgtGetBuildStamp&#34;,None),

        &#34;event_query&#34; : (&#34;&#34;&#34;qryExecuteDetail?type=EVENT&amp;reverse=false&#34;&#34;&#34;, &#34;&#34;&#34;{
                    &#34;config&#34;: {
                        &#34;timeRange&#34;:&#34;%(time_range)s&#34;,
                        &#34;fields&#34;:%(fields)s,
                        &#34;filters&#34;:%(filters)s,
                        &#34;limit&#34;:%(limit)s,
                        &#34;offset&#34;:%(offset)s,
                        &#34;order&#34;: [{&#34;field&#34;: {&#34;name&#34;: &#34;%(order_field)s&#34;}, &#34;direction&#34;: &#34;%(order_direction)s&#34;}]
                        }}&#34;&#34;&#34;),

       [...]
    }
    ```  
    Please see `dump_api_params.py` script at https://github.com/mfesiem/msiempy/blob/master/samples/dump_api_params.py to dump the complete structure.
    &#39;&#39;&#39;

    #% dict(content=pprint.pformat(PARAMS)[:3000]) + &#34;&#34;&#34; [...] and more, please consult source code.&#34;&#34;&#34;
        
    def __str__(self):
        return repr(self.__unique_state__) 

    def login(self, retry=1):
        &#34;&#34;&#34;Authentication is done lazily upon the first call to `msiempy.NitroSession.request` method, but you can still do it manually by calling this method.  
        Throws `msiempy.NitroError` if login fails
        &#34;&#34;&#34;
        userb64 = tob64(self.config.user)
        passb64 = self.config.passwd
        
        resp = self.request(&#39;login&#39;, username=userb64, password=passb64, raw=True, secure=True)
        
        if resp != None :
            try:
                resp.raise_for_status()
            except requests.HTTPError as e :
                if retry&gt;0:
                    time.sleep(0.2)
                    return self.login(retry=retry-1)
                else:
                    raise NitroError(&#39;ESM Login Error: &#39;, resp.text) from e
       
            self._headers[&#39;Cookie&#39;] = resp.headers.get(&#39;Set-Cookie&#39;)
            self._headers[&#39;X-Xsrf-Token&#39;] = resp.headers.get(&#39;Xsrf-Token&#39;)
            
            self.user_tz_id = dict(resp.json())[&#39;tzId&#39;]
            self.logged_in = True
            self.login_info=self.unpack_resp(resp)

            # Shorthanding the API version check 
            # 1 for pre 11.2.1, 2 for 11.2.1 and later
            # Not be confused with the ESM API v1 and v2 which are different.
            if str(self.version).startswith((&#39;9&#39;, &#39;10&#39;, &#39;11.0&#39;, &#39;11.1&#39;)):
                self.api_v = 1
            else:
                self.api_v = 2

            log.info(&#39;Logged into ESM {} with username {}. Last login {}&#39;.format(
                str(self.config.host),
                self.login_info[&#39;userName&#39;],
                self.login_info[&#39;lastLoginDate&#39;]))

            return True
        else:
            raise NitroError(&#39;ESM Login Error: Response empty&#39;)

    def logout(self):
        &#34;&#34;&#34; 
        This method will logout the session.
        &#34;&#34;&#34;
        self.api_v = 0
        self.request(&#39;logout&#39;, http=&#39;delete&#39;)
        self.logged_in=False
        self.login_info=dict()
        self._headers={&#39;Content-Type&#39;: &#39;application/json&#39;}
        self.user_tz_id = None

    def esm_request(self, method, data, http=&#39;post&#39;, callback=None, raw=False, secure=False, retry=1):
        &#34;&#34;&#34;
        Helper method that format the request, handle the basic parsing of the SIEM result as well as other errors.          
        If method is all upper cases, it&#39;s going to be formatted as a private API call. See `msiempy.NitroSession.format_params` and `msiempy.NitroSession.format_priv_resp` 
        In any way, the ESM response is unpacked by `msiempy.NitroSession.unpack_resp`.  


        Arguments :  

        - `method` : ESM API enpoint name and url parameters  
        - `http`: HTTP method.  
        - `data` : dict data to send  
        - `callback` : function to apply afterwards  
        - `raw` : If true will return the Response object from requests module. No retry when raw=True.     
        - `secure` : If true will not log the content of the request.   
        - `retry` : Number of time the request can be retried

        Returns : 

        - a `dict`, `list` or `str` object. 
        - the `resquest.Response` object if raw=True  
        - `None` if Timeout or TooManyRedirects if raw=False  

        Raises:

        - `NitroError` if any `HTTPError`

         Note : Private API is under /ess/ and public api is under /rs/esm  

        &#34;&#34;&#34;

        url=str()
        privateApiCall=False
        result=None

        #Logging the data request if not secure | Logs anyway the method
        log.debug(&#39;Requesting HTTP &#39;+str(http)+&#39; &#39;+ str(method) + 
            (&#39; with data &#39;+str(data) if not secure else &#39; ***&#39;) )
        
        http_data=str()

        #Handling private API calls formatting
        if method == method.upper():
            privateApiCall=True
            url = self.BASE_URL_PRIV
            http_data = self.format_params(method, **data)
            log.debug(&#39;Private API call : &#39;+str(method)+&#39; Formatted params : &#39;+str(http_data))
        
        #Normal API calls
        else:
            url = self.BASE_URL
            if data :
                http_data = json.dumps(data)

        try :
            result = requests.request(
                http,
                urllib.parse.urljoin(url.format(self.config.host), method),
                data=http_data, 
                headers=self._headers,
                verify=self.config.ssl_verify,
                timeout=self.config.timeout,
                # Uncomment for debugging.
                #proxies={&#34;http&#34;: &#34;http://127.0.0.1:8888&#34;, &#34;https&#34;:&#34;http:127.0.0.1:8888&#34;}
            )

            if raw :
                log.debug(&#39;Returning raw requests Response object : &#39;+str(result))
                return result

            else:
                try:
                    result.raise_for_status()

                except requests.HTTPError as e :
                    error=None

                    if retry&gt;0 :
                        # Invalid session handler -&gt; re-login
                        if any([match in result.text for match in [&#39;ERROR_InvalidSession&#39;, &#39;ERROR_INVALID_SESSION&#39;,
                            &#39;Not Authorized User&#39;, &#39;Invalid Session&#39;, &#39;Username and password cannot be null&#39;]]):
                            error = NitroError(&#39;Authentication error with method ({}) and data : {} logging in and retrying esm_request(). From requests.HTTPError {} {}&#39;.format(
                                method, data, e, result.text))
                            log.warning(error)
                            self.logged_in=False
                            self.login()
                        
                        else: log.warning(&#39;An HTTP error occured ({} {}), retrying esm_request()&#39;.format(e, result.text))
                        
                        # Retry request
                        time.sleep(0.2)
                        return self.esm_request(method, data, http, callback, raw, secure, retry=retry-1)
                    
                    else :
                        # # Data unavailable error -&gt; raise
                        # if any([match in result.text for match in [&#39;ERROR_IndexNotTurnedOn&#39;,
                        #     &#39;ERROR_NoData&#39;,&#39;ERROR_UnknownList&#39;,&#39;ERROR_JobEngine_GetQueryStatus_StatusNotFound&#39;]]):
                        #     error = NitroError(&#39;Data unavailable error with method ({}) and data : {}. From requests.HTTPError {} {}&#39;.format(
                        #         method, data, e, result.text))
                        #     log.error(error)
                        #     raise
                        # else :
                        #     # Other handlers
                        #     # if True : # Other HTTP errors... TODO
                        #         # _InvalidFilter (228)
                        #         # Status Code 500: Error processing request, see server logs for more details 
                        #         # Input Validation Error

                        # Raise error in the worst case
                        error = NitroError(&#39;Error with method ({}) and data : {}. From requests.HTTPError {} {}&#39;.format(
                            method, data, e, result.text))
                        log.error(error)
                        raise error from e

                else: # The result is not an HTTP Error
                    response = result
                    result = self.unpack_resp(result)

                    if privateApiCall :
                        result = self.format_priv_resp(result)

                    if callback:
                        result = callback(result)

                    log.debug(&#39;{} -&gt; Result ({}): {}&#39;.format(
                        str(response),
                        type(result),
                        str(result)[:100] + &#39;[...]&#39; if len(str(result))&gt;100 else &#39;&#39;
                    ))

                    return result

        #Hard errors, could retry
        except requests.exceptions.Timeout as e:
            log.error(e)
            raise
        except requests.exceptions.TooManyRedirects as e :
            log.error(e)
            raise
        
    # def _request_http_error_handler(self, error, method, data, http, callback, raw, secure, retry):
    #     pass

    def version(self):
        &#34;&#34;&#34;
        Returns: `str` ESM short version.  
        Example: &#39;10.0.2&#39;
        &#34;&#34;&#34;
        return self.buildstamp().split()[0]

    def buildstamp(self):
        &#34;&#34;&#34;
        Returns: `str` ESM buildstamp.  
        Example: &#39;10.0.2 20170516001031&#39;
        &#34;&#34;&#34;
        return self.request(&#39;build_stamp&#39;)[&#39;buildStamp&#39;]

    def get_internal_file(self, file_token):
        &#34;&#34;&#34;Uses the private API to retrieve, assemble and delete a temp file from the ESM.
        
        Arguments:  

        - `file_token` (`str`): File token ID
        &#34;&#34;&#34;
        pos = 0
        nbytes = 0
        resp = self.request(&#39;get_rfile2&#39;, ftoken=file_token, pos=pos, nbytes=nbytes)

        if resp[&#39;FSIZE&#39;] == resp[&#39;BREAD&#39;]:
            data = resp[&#39;DATA&#39;]
            self.request(&#39;del_rfile&#39;, ftoken=file_token)
            return data
        
        data = []
        data.append(resp[&#39;DATA&#39;])
        file_size = int(resp[&#39;FSIZE&#39;])
        collected = int(resp[&#39;BREAD&#39;])

        while file_size &gt; collected:
            pos += int(resp[&#39;BREAD&#39;])
            nbytes = file_size - collected
            resp = self.request(&#39;get_rfile2&#39;, ftoken=file_token, pos=pos, nbytes=nbytes)
            collected += int(resp[&#39;BREAD&#39;])
            data.append(resp[&#39;DATA&#39;])

        resp = self.request(&#39;del_rfile&#39;, ftoken=file_token)
        return &#39;&#39;.join(data)

    def request(self, request, **kwargs):
        &#34;&#34;&#34;
        This method is the centralized interface of all requests going to the SIEM.  
        It interpolates `**params` with `msiempy.NitroSession.PARAMS` docstrings and build a valid datastructure with `ast`.  
        Wrapper around the `msiempy.NitroSession.esm_request` method.  

        Arguments:  

        - `request`: Keyword corresponding to the request name in `msiempy.NitroSession.PARAMS` mapping.  
        - `http`: HTTP method.  
        - `callback` : function to apply afterwards  
        - `raw` : If true will return the Response object from requests module.   
        - `secure` : If true will not log the content of the request.   
        - `retry` : Number of time the request can be retried
        
        Interpolation parameters :  
        
        - `**kwargs` : Interpolation parameters that will be match to `msiempy.NitroSession.PARAMS` templates. Dynamic keyword arguments.  

        Returns :  

        - a `dict`, `list` or `str` object  
        - the `resquest.Response` object if raw=True  
        - `result.text` if `requests.HTTPError`,   
        - `None` if Timeout or TooManyRedirects if raw=False  
        &#34;&#34;&#34;
        log.debug(&#34;Calling nitro request : {} kwargs={}&#34;.format(
            str(request), &#39;***&#39; if &#39;secure&#39; in kwargs and kwargs[&#39;secure&#39;]==True else str(kwargs)))

        method, data = self.PARAMS.get(request)

        if data != None :
            data =  data % kwargs
            data = ast.literal_eval((data.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\t&#39;,&#39;&#39;)))
           
        if method != None:
            try :
                method = method % kwargs
            except TypeError as err :
                if (&#39;must be real number, not dict&#39; in str(err)):
                    log.warning(&#34;Interpolation failed probably because of the private API calls formatting... Unexpected behaviours can happend.&#34;)

        if not self.logged_in and method != &#39;login&#39;:
            # Autologin
            self.login()
            
    
        try :
            #Dynamically checking the esm_request arguments so additionnal parameters can be passed afterwards.
            esm_request_args = inspect.getfullargspec(self.esm_request)[0]
            params={}
            for arg in kwargs :
                if arg in esm_request_args:
                    params[arg]=kwargs[arg]
            return self.esm_request(method=method, data=data, **params)

        except ConnectionError as e:
            log.critical(e)
            raise
        except Exception as e:
            log.error(e)
            raise 

    @staticmethod
    def _init_log(verbose=False, quiet=False, logfile=None):
        &#34;&#34;&#34;
        Private method. Inits the session&#39;s logger settings based on params
        All objects should be able to log stuff, so the logger is globaly accessible
        &#34;&#34;&#34;

        log.setLevel(logging.DEBUG)

        std = logging.StreamHandler()
        std.setLevel(logging.DEBUG)
        std.setFormatter(logging.Formatter(&#39;%(levelname)s - %(message)s&#39;))

        if verbose :
            std.setLevel(logging.DEBUG)
        elif quiet :
            std.setLevel(logging.CRITICAL)
        else :
            std.setLevel(logging.INFO)

        log.handlers=[]
        
        log.addHandler(std)

        if logfile :
            fh = logging.FileHandler(logfile)
            fh.setLevel(logging.DEBUG)
            fh.setFormatter(logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(message)s&#39;))
            log.addHandler(fh)

        if verbose and quiet :
            log.warning(&#34;Verbose and quiet values are both set to True. This is a very inconsistent state. By default, verbose value has priority.&#34;)

        return (log)
    

    @staticmethod
    def format_params(cmd, **params):
        &#34;&#34;&#34;
        Format private API call.  
        From mfe_saw project at https://github.com/andywalden/mfe_saw
        &#34;&#34;&#34;
        params = {k: v for k, v in params.items() if v != None}
        params = &#39;%14&#39;.join([k + &#39;%13&#39; + v + &#39;%13&#39; for (k, v) in params.items()])
        
        if params:
            params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39; + params + &#39;%14&#39;
        else:
            params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39;
        return params

    @staticmethod
    def format_priv_resp(resp):
        &#34;&#34;&#34;
        Format response from private API.  
        From mfe_saw project at https://github.com/andywalden/mfe_saw
        &#34;&#34;&#34;
        resp = re.search(&#39;Response=(.*)&#39;, resp).group(1)
        resp = resp.replace(&#39;%14&#39;, &#39; &#39;)
        pairs = resp.split()
        formatted = {}
        for pair in pairs:
            pair = pair.replace(&#39;%13&#39;, &#39; &#39;)
            pair = pair.split()
            key = pair[0]
            if key == &#39;ITEMS&#39;:
                value = pair[-1]
            else:
                value = urllib.parse.unquote(pair[-1])
            formatted[key] = value
        return formatted

    @staticmethod
    def unpack_resp(response) :
        &#34;&#34;&#34;Unpack data from response.
        Args: 
            response: requests.Response response object
        Returns a list, a dict or a string
        &#34;&#34;&#34;
        try :
            data = response.json()
            if isinstance(response.json(), dict):
                try:
                    data = data[&#39;value&#39;]
                except KeyError:
                    try:
                        data = data[&#39;return&#39;]
                    except KeyError:
                        pass
            
        except ValueError :
            data = response.text

        return data</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.NitroSession.BASE_URL"><code class="name">var <span class="ident">BASE_URL</span></code></dt>
<dd>
<div class="desc"><p>API v2 base url: 'https://{}/rs/esm/'</p></div>
</dd>
<dt id="msiempy.NitroSession.BASE_URL_PRIV"><code class="name">var <span class="ident">BASE_URL_PRIV</span></code></dt>
<dd>
<div class="desc"><p>Private API base URL: 'https://{}/ess/'</p></div>
</dd>
<dt id="msiempy.NitroSession.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"><p><code><a title="msiempy.NitroConfig" href="#msiempy.NitroConfig">NitroConfig</a></code> object.</p></div>
</dd>
<dt id="msiempy.NitroSession.PARAMS"><code class="name">var <span class="ident">PARAMS</span></code></dt>
<dd>
<div class="desc"><p>This structure provide a central place to aggregate API methods and parameters.<br>
The parameters are stored as docstrings to support string replacement.
</p>
<p>Args:<br>
- <code>method</code> (str): Dict key associated with desired function
Use normal dict access, PARAMS["method"], or PARAMS.get("method")</p>
<p>Returns:<br>
- <code>tuple </code>: (string, string) : The first string is the method name that is actually used as
the URI or passed to the ESM. The second string is the params
required for that method. Some params require variables be
interpolated as documented in the data structure.</p>
<p>Usage exemple in <code><a title="msiempy.NitroSession.request" href="#msiempy.NitroSession.request">NitroSession.request()</a></code> source code.
</p>
<p>Important note :
Do not use sigle quotes (<code>'</code>) to delimit data into the interpolated strings !</p>
<p>Data structure example :
</p>
<pre><code>{
    &quot;login&quot;: (&quot;login&quot;,
            &quot;&quot;&quot;{&quot;username&quot;: &quot;%(username)s&quot;,
                &quot;password&quot; : &quot;%(password)s&quot;,
                &quot;locale&quot;: &quot;en_US&quot;,
                &quot;os&quot;: &quot;Win32&quot;}
                &quot;&quot;&quot;),

    &quot;add_watchlist_values&quot;: (&quot;&quot;&quot;sysAddWatchlistValues&quot;&quot;&quot;,&quot;&quot;&quot;{
            &quot;watchlist&quot;: %(watchlist)s,
            &quot;values&quot;: %(values)s,
            }&quot;&quot;&quot;),

    &quot;get_watchlist_values&quot;: (&quot;SYS_GETWATCHLISTDETAILS&quot;,
                                    &quot;&quot;&quot;{&quot;WID&quot;: &quot;%(id)s&quot;, &quot;LIM&quot;: &quot;T&quot;}&quot;&quot;&quot;),

    &quot;remove_watchlists&quot;: (&quot;&quot;&quot;sysRemoveWatchlist&quot;&quot;&quot;, &quot;&quot;&quot;{&quot;ids&quot;: {&quot;watchlistIdList&quot;: [&quot;%(wl_id_list)s&quot;]}}&quot;&quot;&quot;),

    &quot;get_alert_data&quot;: (&quot;&quot;&quot;ipsGetAlertData&quot;&quot;&quot;, &quot;&quot;&quot;{&quot;id&quot;: {&quot;value&quot;:&quot;%(id)s&quot;}}&quot;&quot;&quot;),

    &quot;get_sys_info&quot;  : (&quot;SYS_GETSYSINFO&quot;,&quot;&quot;&quot;{}&quot;&quot;&quot;),

    &quot;build_stamp&quot; : (&quot;essmgtGetBuildStamp&quot;,None),

    &quot;event_query&quot; : (&quot;&quot;&quot;qryExecuteDetail?type=EVENT&amp;reverse=false&quot;&quot;&quot;, &quot;&quot;&quot;{
                &quot;config&quot;: {
                    &quot;timeRange&quot;:&quot;%(time_range)s&quot;,
                    &quot;fields&quot;:%(fields)s,
                    &quot;filters&quot;:%(filters)s,
                    &quot;limit&quot;:%(limit)s,
                    &quot;offset&quot;:%(offset)s,
                    &quot;order&quot;: [{&quot;field&quot;: {&quot;name&quot;: &quot;%(order_field)s&quot;}, &quot;direction&quot;: &quot;%(order_direction)s&quot;}]
                    }}&quot;&quot;&quot;),

   [...]
}
</code></pre>
<p>Please see <code>dump_api_params.py</code> script at <a href="https://github.com/mfesiem/msiempy/blob/master/samples/dump_api_params.py">https://github.com/mfesiem/msiempy/blob/master/samples/dump_api_params.py</a> to dump the complete structure.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="msiempy.NitroSession.format_params"><code class="name flex">
<span>def <span class="ident">format_params</span></span>(<span>cmd, **params)</span>
</code></dt>
<dd>
<div class="desc"><p>Format private API call.<br>
From mfe_saw project at <a href="https://github.com/andywalden/mfe_saw">https://github.com/andywalden/mfe_saw</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def format_params(cmd, **params):
    &#34;&#34;&#34;
    Format private API call.  
    From mfe_saw project at https://github.com/andywalden/mfe_saw
    &#34;&#34;&#34;
    params = {k: v for k, v in params.items() if v != None}
    params = &#39;%14&#39;.join([k + &#39;%13&#39; + v + &#39;%13&#39; for (k, v) in params.items()])
    
    if params:
        params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39; + params + &#39;%14&#39;
    else:
        params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39;
    return params</code></pre>
</details>
</dd>
<dt id="msiempy.NitroSession.format_priv_resp"><code class="name flex">
<span>def <span class="ident">format_priv_resp</span></span>(<span>resp)</span>
</code></dt>
<dd>
<div class="desc"><p>Format response from private API.<br>
From mfe_saw project at <a href="https://github.com/andywalden/mfe_saw">https://github.com/andywalden/mfe_saw</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def format_priv_resp(resp):
    &#34;&#34;&#34;
    Format response from private API.  
    From mfe_saw project at https://github.com/andywalden/mfe_saw
    &#34;&#34;&#34;
    resp = re.search(&#39;Response=(.*)&#39;, resp).group(1)
    resp = resp.replace(&#39;%14&#39;, &#39; &#39;)
    pairs = resp.split()
    formatted = {}
    for pair in pairs:
        pair = pair.replace(&#39;%13&#39;, &#39; &#39;)
        pair = pair.split()
        key = pair[0]
        if key == &#39;ITEMS&#39;:
            value = pair[-1]
        else:
            value = urllib.parse.unquote(pair[-1])
        formatted[key] = value
    return formatted</code></pre>
</details>
</dd>
<dt id="msiempy.NitroSession.unpack_resp"><code class="name flex">
<span>def <span class="ident">unpack_resp</span></span>(<span>response)</span>
</code></dt>
<dd>
<div class="desc"><p>Unpack data from response.
Args:
response: requests.Response response object
Returns a list, a dict or a string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def unpack_resp(response) :
    &#34;&#34;&#34;Unpack data from response.
    Args: 
        response: requests.Response response object
    Returns a list, a dict or a string
    &#34;&#34;&#34;
    try :
        data = response.json()
        if isinstance(response.json(), dict):
            try:
                data = data[&#39;value&#39;]
            except KeyError:
                try:
                    data = data[&#39;return&#39;]
                except KeyError:
                    pass
        
    except ValueError :
        data = response.text

    return data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.NitroSession.login"><code class="name flex">
<span>def <span class="ident">login</span></span>(<span>self, retry=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Authentication is done lazily upon the first call to <code><a title="msiempy.NitroSession.request" href="#msiempy.NitroSession.request">NitroSession.request()</a></code> method, but you can still do it manually by calling this method.<br>
Throws <code><a title="msiempy.NitroError" href="#msiempy.NitroError">NitroError</a></code> if login fails</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def login(self, retry=1):
    &#34;&#34;&#34;Authentication is done lazily upon the first call to `msiempy.NitroSession.request` method, but you can still do it manually by calling this method.  
    Throws `msiempy.NitroError` if login fails
    &#34;&#34;&#34;
    userb64 = tob64(self.config.user)
    passb64 = self.config.passwd
    
    resp = self.request(&#39;login&#39;, username=userb64, password=passb64, raw=True, secure=True)
    
    if resp != None :
        try:
            resp.raise_for_status()
        except requests.HTTPError as e :
            if retry&gt;0:
                time.sleep(0.2)
                return self.login(retry=retry-1)
            else:
                raise NitroError(&#39;ESM Login Error: &#39;, resp.text) from e
   
        self._headers[&#39;Cookie&#39;] = resp.headers.get(&#39;Set-Cookie&#39;)
        self._headers[&#39;X-Xsrf-Token&#39;] = resp.headers.get(&#39;Xsrf-Token&#39;)
        
        self.user_tz_id = dict(resp.json())[&#39;tzId&#39;]
        self.logged_in = True
        self.login_info=self.unpack_resp(resp)

        # Shorthanding the API version check 
        # 1 for pre 11.2.1, 2 for 11.2.1 and later
        # Not be confused with the ESM API v1 and v2 which are different.
        if str(self.version).startswith((&#39;9&#39;, &#39;10&#39;, &#39;11.0&#39;, &#39;11.1&#39;)):
            self.api_v = 1
        else:
            self.api_v = 2

        log.info(&#39;Logged into ESM {} with username {}. Last login {}&#39;.format(
            str(self.config.host),
            self.login_info[&#39;userName&#39;],
            self.login_info[&#39;lastLoginDate&#39;]))

        return True
    else:
        raise NitroError(&#39;ESM Login Error: Response empty&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroSession.logout"><code class="name flex">
<span>def <span class="ident">logout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method will logout the session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logout(self):
    &#34;&#34;&#34; 
    This method will logout the session.
    &#34;&#34;&#34;
    self.api_v = 0
    self.request(&#39;logout&#39;, http=&#39;delete&#39;)
    self.logged_in=False
    self.login_info=dict()
    self._headers={&#39;Content-Type&#39;: &#39;application/json&#39;}
    self.user_tz_id = None</code></pre>
</details>
</dd>
<dt id="msiempy.NitroSession.esm_request"><code class="name flex">
<span>def <span class="ident">esm_request</span></span>(<span>self, method, data, http='post', callback=None, raw=False, secure=False, retry=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper method that format the request, handle the basic parsing of the SIEM result as well as other errors.
<br>
If method is all upper cases, it's going to be formatted as a private API call. See <code><a title="msiempy.NitroSession.format_params" href="#msiempy.NitroSession.format_params">NitroSession.format_params()</a></code> and <code><a title="msiempy.NitroSession.format_priv_resp" href="#msiempy.NitroSession.format_priv_resp">NitroSession.format_priv_resp()</a></code>
In any way, the ESM response is unpacked by <code><a title="msiempy.NitroSession.unpack_resp" href="#msiempy.NitroSession.unpack_resp">NitroSession.unpack_resp()</a></code>.
</p>
<p>Arguments :
</p>
<ul>
<li><code>method</code> : ESM API enpoint name and url parameters
</li>
<li><code>http</code>: HTTP method.
</li>
<li><code>data</code> : dict data to send
</li>
<li><code>callback</code> : function to apply afterwards
</li>
<li><code>raw</code> : If true will return the Response object from requests module. No retry when raw=True.
</li>
<li><code>secure</code> : If true will not log the content of the request.
</li>
<li><code>retry</code> : Number of time the request can be retried</li>
</ul>
<p>Returns : </p>
<ul>
<li>a <code>dict</code>, <code>list</code> or <code>str</code> object. </li>
<li>the <code>resquest.Response</code> object if raw=True
</li>
<li><code>None</code> if Timeout or TooManyRedirects if raw=False
</li>
</ul>
<p>Raises:</p>
<ul>
<li><code><a title="msiempy.NitroError" href="#msiempy.NitroError">NitroError</a></code> if any <code>HTTPError</code></li>
</ul>
<p>Note : Private API is under /ess/ and public api is under /rs/esm</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esm_request(self, method, data, http=&#39;post&#39;, callback=None, raw=False, secure=False, retry=1):
    &#34;&#34;&#34;
    Helper method that format the request, handle the basic parsing of the SIEM result as well as other errors.          
    If method is all upper cases, it&#39;s going to be formatted as a private API call. See `msiempy.NitroSession.format_params` and `msiempy.NitroSession.format_priv_resp` 
    In any way, the ESM response is unpacked by `msiempy.NitroSession.unpack_resp`.  


    Arguments :  

    - `method` : ESM API enpoint name and url parameters  
    - `http`: HTTP method.  
    - `data` : dict data to send  
    - `callback` : function to apply afterwards  
    - `raw` : If true will return the Response object from requests module. No retry when raw=True.     
    - `secure` : If true will not log the content of the request.   
    - `retry` : Number of time the request can be retried

    Returns : 

    - a `dict`, `list` or `str` object. 
    - the `resquest.Response` object if raw=True  
    - `None` if Timeout or TooManyRedirects if raw=False  

    Raises:

    - `NitroError` if any `HTTPError`

     Note : Private API is under /ess/ and public api is under /rs/esm  

    &#34;&#34;&#34;

    url=str()
    privateApiCall=False
    result=None

    #Logging the data request if not secure | Logs anyway the method
    log.debug(&#39;Requesting HTTP &#39;+str(http)+&#39; &#39;+ str(method) + 
        (&#39; with data &#39;+str(data) if not secure else &#39; ***&#39;) )
    
    http_data=str()

    #Handling private API calls formatting
    if method == method.upper():
        privateApiCall=True
        url = self.BASE_URL_PRIV
        http_data = self.format_params(method, **data)
        log.debug(&#39;Private API call : &#39;+str(method)+&#39; Formatted params : &#39;+str(http_data))
    
    #Normal API calls
    else:
        url = self.BASE_URL
        if data :
            http_data = json.dumps(data)

    try :
        result = requests.request(
            http,
            urllib.parse.urljoin(url.format(self.config.host), method),
            data=http_data, 
            headers=self._headers,
            verify=self.config.ssl_verify,
            timeout=self.config.timeout,
            # Uncomment for debugging.
            #proxies={&#34;http&#34;: &#34;http://127.0.0.1:8888&#34;, &#34;https&#34;:&#34;http:127.0.0.1:8888&#34;}
        )

        if raw :
            log.debug(&#39;Returning raw requests Response object : &#39;+str(result))
            return result

        else:
            try:
                result.raise_for_status()

            except requests.HTTPError as e :
                error=None

                if retry&gt;0 :
                    # Invalid session handler -&gt; re-login
                    if any([match in result.text for match in [&#39;ERROR_InvalidSession&#39;, &#39;ERROR_INVALID_SESSION&#39;,
                        &#39;Not Authorized User&#39;, &#39;Invalid Session&#39;, &#39;Username and password cannot be null&#39;]]):
                        error = NitroError(&#39;Authentication error with method ({}) and data : {} logging in and retrying esm_request(). From requests.HTTPError {} {}&#39;.format(
                            method, data, e, result.text))
                        log.warning(error)
                        self.logged_in=False
                        self.login()
                    
                    else: log.warning(&#39;An HTTP error occured ({} {}), retrying esm_request()&#39;.format(e, result.text))
                    
                    # Retry request
                    time.sleep(0.2)
                    return self.esm_request(method, data, http, callback, raw, secure, retry=retry-1)
                
                else :
                    # # Data unavailable error -&gt; raise
                    # if any([match in result.text for match in [&#39;ERROR_IndexNotTurnedOn&#39;,
                    #     &#39;ERROR_NoData&#39;,&#39;ERROR_UnknownList&#39;,&#39;ERROR_JobEngine_GetQueryStatus_StatusNotFound&#39;]]):
                    #     error = NitroError(&#39;Data unavailable error with method ({}) and data : {}. From requests.HTTPError {} {}&#39;.format(
                    #         method, data, e, result.text))
                    #     log.error(error)
                    #     raise
                    # else :
                    #     # Other handlers
                    #     # if True : # Other HTTP errors... TODO
                    #         # _InvalidFilter (228)
                    #         # Status Code 500: Error processing request, see server logs for more details 
                    #         # Input Validation Error

                    # Raise error in the worst case
                    error = NitroError(&#39;Error with method ({}) and data : {}. From requests.HTTPError {} {}&#39;.format(
                        method, data, e, result.text))
                    log.error(error)
                    raise error from e

            else: # The result is not an HTTP Error
                response = result
                result = self.unpack_resp(result)

                if privateApiCall :
                    result = self.format_priv_resp(result)

                if callback:
                    result = callback(result)

                log.debug(&#39;{} -&gt; Result ({}): {}&#39;.format(
                    str(response),
                    type(result),
                    str(result)[:100] + &#39;[...]&#39; if len(str(result))&gt;100 else &#39;&#39;
                ))

                return result

    #Hard errors, could retry
    except requests.exceptions.Timeout as e:
        log.error(e)
        raise
    except requests.exceptions.TooManyRedirects as e :
        log.error(e)
        raise</code></pre>
</details>
</dd>
<dt id="msiempy.NitroSession.version"><code class="name flex">
<span>def <span class="ident">version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns: <code>str</code> ESM short version.<br>
Example: '10.0.2'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def version(self):
    &#34;&#34;&#34;
    Returns: `str` ESM short version.  
    Example: &#39;10.0.2&#39;
    &#34;&#34;&#34;
    return self.buildstamp().split()[0]</code></pre>
</details>
</dd>
<dt id="msiempy.NitroSession.buildstamp"><code class="name flex">
<span>def <span class="ident">buildstamp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns: <code>str</code> ESM buildstamp.<br>
Example: '10.0.2 20170516001031'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildstamp(self):
    &#34;&#34;&#34;
    Returns: `str` ESM buildstamp.  
    Example: &#39;10.0.2 20170516001031&#39;
    &#34;&#34;&#34;
    return self.request(&#39;build_stamp&#39;)[&#39;buildStamp&#39;]</code></pre>
</details>
</dd>
<dt id="msiempy.NitroSession.get_internal_file"><code class="name flex">
<span>def <span class="ident">get_internal_file</span></span>(<span>self, file_token)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the private API to retrieve, assemble and delete a temp file from the ESM.</p>
<p>Arguments:
</p>
<ul>
<li><code>file_token</code> (<code>str</code>): File token ID</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_internal_file(self, file_token):
    &#34;&#34;&#34;Uses the private API to retrieve, assemble and delete a temp file from the ESM.
    
    Arguments:  

    - `file_token` (`str`): File token ID
    &#34;&#34;&#34;
    pos = 0
    nbytes = 0
    resp = self.request(&#39;get_rfile2&#39;, ftoken=file_token, pos=pos, nbytes=nbytes)

    if resp[&#39;FSIZE&#39;] == resp[&#39;BREAD&#39;]:
        data = resp[&#39;DATA&#39;]
        self.request(&#39;del_rfile&#39;, ftoken=file_token)
        return data
    
    data = []
    data.append(resp[&#39;DATA&#39;])
    file_size = int(resp[&#39;FSIZE&#39;])
    collected = int(resp[&#39;BREAD&#39;])

    while file_size &gt; collected:
        pos += int(resp[&#39;BREAD&#39;])
        nbytes = file_size - collected
        resp = self.request(&#39;get_rfile2&#39;, ftoken=file_token, pos=pos, nbytes=nbytes)
        collected += int(resp[&#39;BREAD&#39;])
        data.append(resp[&#39;DATA&#39;])

    resp = self.request(&#39;del_rfile&#39;, ftoken=file_token)
    return &#39;&#39;.join(data)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroSession.request"><code class="name flex">
<span>def <span class="ident">request</span></span>(<span>self, request, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is the centralized interface of all requests going to the SIEM.<br>
It interpolates <code>**params</code> with <code><a title="msiempy.NitroSession.PARAMS" href="#msiempy.NitroSession.PARAMS">NitroSession.PARAMS</a></code> docstrings and build a valid datastructure with <code>ast</code>.<br>
Wrapper around the <code><a title="msiempy.NitroSession.esm_request" href="#msiempy.NitroSession.esm_request">NitroSession.esm_request()</a></code> method.
</p>
<p>Arguments:
</p>
<ul>
<li><code>request</code>: Keyword corresponding to the request name in <code><a title="msiempy.NitroSession.PARAMS" href="#msiempy.NitroSession.PARAMS">NitroSession.PARAMS</a></code> mapping.
</li>
<li><code>http</code>: HTTP method.
</li>
<li><code>callback</code> : function to apply afterwards
</li>
<li><code>raw</code> : If true will return the Response object from requests module.
</li>
<li><code>secure</code> : If true will not log the content of the request.
</li>
<li><code>retry</code> : Number of time the request can be retried</li>
</ul>
<p>Interpolation parameters :
</p>
<ul>
<li><code>**kwargs</code> : Interpolation parameters that will be match to <code><a title="msiempy.NitroSession.PARAMS" href="#msiempy.NitroSession.PARAMS">NitroSession.PARAMS</a></code> templates. Dynamic keyword arguments.
</li>
</ul>
<p>Returns :
</p>
<ul>
<li>a <code>dict</code>, <code>list</code> or <code>str</code> object
</li>
<li>the <code>resquest.Response</code> object if raw=True
</li>
<li><code>result.text</code> if <code>requests.HTTPError</code>,
</li>
<li><code>None</code> if Timeout or TooManyRedirects if raw=False</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request(self, request, **kwargs):
    &#34;&#34;&#34;
    This method is the centralized interface of all requests going to the SIEM.  
    It interpolates `**params` with `msiempy.NitroSession.PARAMS` docstrings and build a valid datastructure with `ast`.  
    Wrapper around the `msiempy.NitroSession.esm_request` method.  

    Arguments:  

    - `request`: Keyword corresponding to the request name in `msiempy.NitroSession.PARAMS` mapping.  
    - `http`: HTTP method.  
    - `callback` : function to apply afterwards  
    - `raw` : If true will return the Response object from requests module.   
    - `secure` : If true will not log the content of the request.   
    - `retry` : Number of time the request can be retried
    
    Interpolation parameters :  
    
    - `**kwargs` : Interpolation parameters that will be match to `msiempy.NitroSession.PARAMS` templates. Dynamic keyword arguments.  

    Returns :  

    - a `dict`, `list` or `str` object  
    - the `resquest.Response` object if raw=True  
    - `result.text` if `requests.HTTPError`,   
    - `None` if Timeout or TooManyRedirects if raw=False  
    &#34;&#34;&#34;
    log.debug(&#34;Calling nitro request : {} kwargs={}&#34;.format(
        str(request), &#39;***&#39; if &#39;secure&#39; in kwargs and kwargs[&#39;secure&#39;]==True else str(kwargs)))

    method, data = self.PARAMS.get(request)

    if data != None :
        data =  data % kwargs
        data = ast.literal_eval((data.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\t&#39;,&#39;&#39;)))
       
    if method != None:
        try :
            method = method % kwargs
        except TypeError as err :
            if (&#39;must be real number, not dict&#39; in str(err)):
                log.warning(&#34;Interpolation failed probably because of the private API calls formatting... Unexpected behaviours can happend.&#34;)

    if not self.logged_in and method != &#39;login&#39;:
        # Autologin
        self.login()
        

    try :
        #Dynamically checking the esm_request arguments so additionnal parameters can be passed afterwards.
        esm_request_args = inspect.getfullargspec(self.esm_request)[0]
        params={}
        for arg in kwargs :
            if arg in esm_request_args:
                params[arg]=kwargs[arg]
        return self.esm_request(method=method, data=data, **params)

    except ConnectionError as e:
        log.critical(e)
        raise
    except Exception as e:
        log.error(e)
        raise </code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="msiempy.NitroObject"><code class="flex name class">
<span>class <span class="ident">NitroObject</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all nitro objects. All objects have a reference to the single <code><a title="msiempy.NitroSession" href="#msiempy.NitroSession">NitroSession</a></code> object that handle the esm requests.<br>
Creates the object session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NitroObject(abc.ABC):
    &#34;&#34;&#34;
    Base class for all nitro objects. All objects have a reference to the single `msiempy.NitroSession` object that handle the esm requests.  
    Creates the object session.
    &#34;&#34;&#34;

    class NitroJSONEncoder(json.JSONEncoder):
        &#34;&#34;&#34;
        Custom JSON encoder that will use the approprtiate propertie depending of the type of NitroObject.  
        TODO return meta info about the NitroList. Maybe create a section `manager` and `data`.  
        TODO support json json dumping of QueryFilers, may be by making them inherits from NitroDict.  
        &#34;&#34;&#34;
        def default(self, obj): # pylint: disable=E0202
            if isinstance(obj,(NitroDict, NitroList)):
                return obj.data
            else:
                return json.JSONEncoder.default(self, obj) 


    nitro=NitroSession()
    &#34;&#34;&#34;
    `msiempy.NitroSession` object. Interface to the SIEM.
    &#34;&#34;&#34;

    @abc.abstractproperty
    def text(self):
        &#34;&#34;&#34;
        Returns printable string.  
        Abstract declaration.
        &#34;&#34;&#34;
        pass

    @abc.abstractproperty
    def json(self):
        &#34;&#34;&#34;
        Returns json string representation.  
        Abstract declaration.
        &#34;&#34;&#34;
    
    @abc.abstractmethod
    def refresh(self):
        &#34;&#34;&#34;
        Re-load the object.  
        Abstract declaration.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="msiempy.NitroDict" href="#msiempy.NitroDict">NitroDict</a></li>
<li><a title="msiempy.NitroList" href="#msiempy.NitroList">NitroList</a></li>
<li><a title="msiempy.device.ESM" href="device.html#msiempy.device.ESM">ESM</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.NitroObject.NitroJSONEncoder"><code class="name">var <span class="ident">NitroJSONEncoder</span></code></dt>
<dd>
<div class="desc"><p>Custom JSON encoder that will use the approprtiate propertie depending of the type of NitroObject.<br>
TODO return meta info about the NitroList. Maybe create a section <code>manager</code> and <code>data</code>.<br>
TODO support json json dumping of QueryFilers, may be by making them inherits from NitroDict.</p></div>
</dd>
<dt id="msiempy.NitroObject.nitro"><code class="name">var <span class="ident">nitro</span></code></dt>
<dd>
<div class="desc"><p><code><a title="msiempy.NitroSession" href="#msiempy.NitroSession">NitroSession</a></code> object. Interface to the SIEM.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.NitroObject.text"><code class="name">var <span class="ident">text</span></code></dt>
<dd>
<div class="desc"><p>Returns printable string.<br>
Abstract declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractproperty
def text(self):
    &#34;&#34;&#34;
    Returns printable string.  
    Abstract declaration.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="msiempy.NitroObject.json"><code class="name">var <span class="ident">json</span></code></dt>
<dd>
<div class="desc"><p>Returns json string representation.<br>
Abstract declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractproperty
def json(self):
    &#34;&#34;&#34;
    Returns json string representation.  
    Abstract declaration.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.NitroObject.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-load the object.<br>
Abstract declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def refresh(self):
    &#34;&#34;&#34;
    Re-load the object.  
    Abstract declaration.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="msiempy.NitroDict"><code class="flex name class">
<span>class <span class="ident">NitroDict</span></span>
<span>(</span><span>adict=None, id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class that represent any SIEM data that can be represented as a item of a list.
Exemple : Event, Alarm, etc&hellip;
Inherits from dict.
Initiate the NitroObject and UserDict objects, load the data if id is specified, use adict agument and update dict values accordingly.</p>
<p>This classe and subclasses fully implements <code>dict</code> interface and is suitable for dictionnary operations, see: <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict">https://docs.python.org/3/library/stdtypes.html#mapping-types-dict</a></p>
<p>Arguments:
</p>
<ul>
<li><code>adict</code>: dict object to wrap.
</li>
<li><code>id</code>: ESM obejct unique identifier. Alert.IPSIDAlertID for exemple.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NitroDict(collections.UserDict, NitroObject):
    &#34;&#34;&#34;
    Base class that represent any SIEM data that can be represented as a item of a list.
    Exemple : Event, Alarm, etc...
    Inherits from dict.
    Initiate the NitroObject and UserDict objects, load the data if id is specified, use adict agument and update dict values accordingly.

    This classe and subclasses fully implements `dict` interface and is suitable for dictionnary operations, see: https://docs.python.org/3/library/stdtypes.html#mapping-types-dict

    Arguments:  

    - `adict`: dict object to wrap.  
    - `id`: ESM obejct unique identifier. Alert.IPSIDAlertID for exemple. 
    &#34;&#34;&#34;
    def __init__(self, adict=None, id=None):
        NitroObject.__init__(self)
        collections.UserDict.__init__(self, adict)

        if adict : self.data=adict
        if id : self.data=self.data_from_id(id)

        for key in list(self) :
            if isinstance(self[key], list):
                self[key]=NitroList(alist=self[key])

    def __str__(self):
        &#34;&#34;&#34;str(obj) -&gt; return text string.
        &#34;&#34;&#34;
        return self.text

    def __repr__(self):
        &#34;&#34;&#34;repr(obj) -&gt; return json string.
        &#34;&#34;&#34;
        return self.json

    @property
    def json(self):
        &#34;&#34;&#34;JSON representation of a item
        &#34;&#34;&#34;
        return(json.dumps(dict(self), indent=4, cls=NitroObject.NitroJSONEncoder))

    @property
    def text(self):
        &#34;&#34;&#34;Text list of item&#39;s values
        &#34;&#34;&#34;
        return(&#39;, &#39;.join([str(val) for val in self.values()]))

    @abc.abstractmethod
    def data_from_id(self, id):
        &#34;&#34;&#34;This method retreive the item infos from an object ID.  
        Abstract declaration.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.UserDict</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="msiempy.NitroObject" href="#msiempy.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="msiempy.alarm.Alarm" href="alarm.html#msiempy.alarm.Alarm">Alarm</a></li>
<li><a title="msiempy.device.DataSource" href="device.html#msiempy.device.DataSource">DataSource</a></li>
<li><a title="msiempy.event.Event" href="event.html#msiempy.event.Event">Event</a></li>
<li><a title="msiempy.watchlist.Watchlist" href="watchlist.html#msiempy.watchlist.Watchlist">Watchlist</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.NitroDict.json"><code class="name">var <span class="ident">json</span></code></dt>
<dd>
<div class="desc"><p>JSON representation of a item</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def json(self):
    &#34;&#34;&#34;JSON representation of a item
    &#34;&#34;&#34;
    return(json.dumps(dict(self), indent=4, cls=NitroObject.NitroJSONEncoder))</code></pre>
</details>
</dd>
<dt id="msiempy.NitroDict.text"><code class="name">var <span class="ident">text</span></code></dt>
<dd>
<div class="desc"><p>Text list of item's values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text(self):
    &#34;&#34;&#34;Text list of item&#39;s values
    &#34;&#34;&#34;
    return(&#39;, &#39;.join([str(val) for val in self.values()]))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.NitroDict.data_from_id"><code class="name flex">
<span>def <span class="ident">data_from_id</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"><p>This method retreive the item infos from an object ID.<br>
Abstract declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def data_from_id(self, id):
    &#34;&#34;&#34;This method retreive the item infos from an object ID.  
    Abstract declaration.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.NitroObject" href="#msiempy.NitroObject">NitroObject</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.NitroObject.NitroJSONEncoder" href="#msiempy.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.NitroObject.nitro" href="#msiempy.NitroObject.nitro">nitro</a></code></li>
<li><code><a title="msiempy.NitroObject.refresh" href="#msiempy.NitroObject.refresh">refresh</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="msiempy.NitroList"><code class="flex name class">
<span>class <span class="ident">NitroList</span></span>
<span>(</span><span>alist=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for NitroList objects. It offers callable execution management, search and other data list actions.
</p>
<p>Concrete classes have to cast the items after !
</p>
<p>This classe and subclasses fully implements <code>list</code> interface and is suitable for list operations, see: <a href="https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range">https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range</a></p>
<p>Subclassing requirements: Subclasses of UserList are expected to offer a constructor which can be called with either no arguments or one argument. List operations which return a new sequence attempt to create an instance of the actual implementation class. To do so, it assumes that the constructor can be called with a single parameter, which is a sequence object used as a data source.
If a derived class does not wish to comply with this requirement, all of the special methods supported by this class will need to be overridden; please consult the sources for information about the methods which need to be provided in that case.
See: <a href="https://docs.python.org/3.8/library/collections.html?highlight=userdict#userlist-objects">https://docs.python.org/3.8/library/collections.html?highlight=userdict#userlist-objects</a>
</p>
<p>Arguments:
</p>
<ul>
<li><code>alist</code>: list object to wrap.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NitroList(collections.UserList, NitroObject):
    &#34;&#34;&#34;
    Base class for NitroList objects. It offers callable execution management, search and other data list actions.  
    
    Concrete classes have to cast the items after !   

    This classe and subclasses fully implements `list` interface and is suitable for list operations, see: https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range
    
    Subclassing requirements: Subclasses of UserList are expected to offer a constructor which can be called with either no arguments or one argument. List operations which return a new sequence attempt to create an instance of the actual implementation class. To do so, it assumes that the constructor can be called with a single parameter, which is a sequence object used as a data source.
    If a derived class does not wish to comply with this requirement, all of the special methods supported by this class will need to be overridden; please consult the sources for information about the methods which need to be provided in that case.
    See: https://docs.python.org/3.8/library/collections.html?highlight=userdict#userlist-objects  

    Arguments:  

    - `alist`: list object to wrap.
    &#34;&#34;&#34;

    # TODO better polymorphism to cast every sub-NitroList class&#39;s item dynamcally in `__init__` method.  
    def __init__(self, alist=None):
        NitroObject.__init__(self)
        if alist : collections.UserList.__init__(self, alist)
        else : collections.UserList.__init__(self, [])

    def __str__(self):
        &#34;&#34;&#34;str(obj) -&gt; return text string.
        &#34;&#34;&#34;
        return &#34;{} containing {} elements ; keys={}&#34;.format(str(super()), len(list(self)), self.keys())

    def keys(self):
        &#34;&#34;&#34;Set of keys for all dict&#34;&#34;&#34;
        #If new fields are added it won&#39;t show on text repr. Only json.
        manager_keys=set()
        for item in list(self): manager_keys.update(getattr(item, &#39;keys&#39;, set)())
        return manager_keys

    def get_text(self, format=&#39;prettytable&#39;, fields=None, 
                        max_column_width=80, get_text_nest_attr={} ):
        &#34;&#34;&#34;
        Return a csv or table string representation of the list

        Arguments:  

        - `format`: 
              prettytable: Returns a table generated by prettytable
              csv: Returns data with header and comma separated values. 
        - `fields`: list of fields you want in the table. If `None` : default fields are returned by .keys attribute and sorted.  
        - `max_column_width`: when using prettytable only 
        - `get_text_nest_attr`: attributes passed to the nested `msiempy.NitroList.get_text` elements. Useful to control events appearence.
        &#34;&#34;&#34;

        text=str()
        
        if not fields :
            fields=sorted(self.keys())

        if format == &#39;csv&#39;:
            file = StringIO()
            dw = csv.DictWriter(file, fields, extrasaction=&#39;ignore&#39;)
            dw.writeheader()
            dw.writerows(list(self))
            text = file.getvalue()

        elif format == &#39;prettytable&#39;:
            table = prettytable.PrettyTable()
            table.set_style(MSWORD_FRIENDLY)

            table.field_names=fields

            for item in list(self):
                if isinstance(item, (dict, NitroDict)):
                    values=list()
                    for field in fields:
                        obj=None
                        try:obj=item[field]
                        except KeyError : pass

                        if isinstance(obj, NitroList):
                            values.append(obj.get_text(**get_text_nest_attr))
                        else:
                            values.append(&#39;\n&#39;.join(textwrap.wrap(str(obj), width=max_column_width)))

                    table.add_row(values)
                    
                else : log.warning(&#34;Unnapropriate list element type, won&#39;t show on the prettytable : {}&#34;.format(str(item)))

            text=table.get_string()
        
        else :
            raise AttributeError(&#34;Unknown `NitroList.get_text` format : {}. Accepted values are &#39;prettytable&#39; or &#39;csv&#39;.&#34;.format(format))

        return text


    @property
    def text(self):
        &#34;&#34;&#34;Defaut table string, a shorcut to `get_text()` with no arguments.
        &#34;&#34;&#34;
        return self.get_text()
        
    @property
    def json(self):
        &#34;&#34;&#34;JSON list of dicts representing the list.
        &#34;&#34;&#34;
        return(json.dumps([dict(item) for item in list(self)], indent=4, cls=NitroObject.NitroJSONEncoder))

    def search(self, invert=False, match_prop=&#39;json&#39;, *pattern):
        &#34;&#34;&#34;
        Return a list of elements that matches one or more regex patterns.
        Patterns are applied one after another. It&#39;s a logic AND.
        Use `|` inside patterns to search with logic OR.
        This method will return a new NitroList with matching data. NitroDicts in the returned NitroList do not
        references the items in the original NitroList.  

        Arguments:  

        - `*pattern`: List or string regex patterns to look for.
        - `invert`: Weither or not to invert the search and return elements that doesn&#39;t not match search.
        - `match_prop`: Propertie that is going to be called to search. Could be `text` or `json`.


        If you wish to apply more specific filters to NitroList list, please
        use filter(), list comprehension, or other filtering method.
            i.e. : `[item for item in list if item[&#39;cost&#39;] &gt; 50]`

        More on regex https://docs.python.org/3/library/re.html#re.Pattern.search
        &#34;&#34;&#34;
        if pattern is None :
            return self
        elif len(pattern) == 0 :
            return self
        else :
            pattern=list(pattern)
            apattern=pattern.pop()
        
        matching_items=list()
        
        if isinstance(apattern, str):
            for item in list(self) :
                if regex_match(apattern, getattr(item, match_prop) if isinstance(item, NitroDict) else str(item)) != invert :
                    matching_items.append(item)
            log.debug(&#34;You&#39;re search returned {} rows : {}&#34;.format(
                len(matching_items),
                str(matching_items)[:100]+&#39;...&#39;))
            #Apply AND reccursively
            return NitroList(alist=matching_items).search(*pattern, invert=invert, match_prop=match_prop)
        else:
            raise ValueError(&#39;pattern must be str&#39;)

    def refresh(self):
        &#34;&#34;&#34;
        Execute refresh function on all items.
        &#34;&#34;&#34;
        log.warning(&#34;The function NitroList.refresh hasn&#39;t been correctly tested&#34;)
        self.perform(NitroDict.refresh, message=&#39;Refreshing all items...&#39;)

    def perform(self, func, data=None, func_args=None, confirm=False, asynch=False,  workers=None , progress=False, message=None):
        &#34;&#34;&#34;
        Wrapper arround executable and the a list of elements, typically `msiempy.NitroList` object.  

        Arguments:  
        
        - `func`: callable function. `func` is going to be called like `func(item, **func_args)` on all items in data.  This function can be stateless (static) or statefull (first argument is `self`),
        it doesn&#39;t really matter as the element will always be passed as the first argument of the function. On thing really important, the function must not
        set/delete/change any global variable, as a result, you&#39;ll see your varible beeing potentially corrupted or chalenged with conccurent accesses.
        - `data`: if stays `None`, will perform the action on itself (`list(self)`) else it will perfom the action on the `data` list.
        - `func_args`: arguments that will be passed by default to `func` in all calls.
        - `confirm`: will ask interactively confirmation.
        - `asynch`: execute the task asynchronously with `concurrent.futures.ThreadPoolExecutor`. It will create a new executor object, so be carefull not to nest 2 asynchronous executions within eachother,
        it will be a mess.
        - `workers`: number of parrallel tasks, mandatory if asynch is true.
        - `progress`: to show progress bar with ETA (tqdm).
        - `message` : To show to the user.  

        This method is where the core of asynchronous tasks resides. `func` will be executed on all `data` elements.  
        Basically, if `asynch==True`, will return :  
            returned=list(concurrent.futures.ThreadPoolExecutor(
                        max_workers=workers ).map(
                            func, data))  

        if `asynch==False`, will iterate and return :
            for index_or_item in data:
                returned.append(func(index_or_item))

        Returns a list of returned results.
        &#34;&#34;&#34;

        log.debug(&#39;Calling perform func=&#39;+str(func)+
            &#39; data=&#39;+str(data)[:100]+
            &#39; func_args=&#39;+str(func_args)+
            &#39; confirm=&#39;+str(confirm)+
            &#39; asynch=&#39;+str(asynch)+
            &#39; workers=&#39;+str(workers)+
            &#39; progress=&#39;+str(progress)+
            &#39; message=&#39;+str(message))

        if not callable(func) :
            raise ValueError(&#39;func must be callable&#39;)

        #Confirming with user if asked
        if confirm : self._confirm_func(func, str(self))

        #Setting the arguments on the function
        func = functools.partial(func, **(func_args if func_args != None else {}))
        
        #The data returned by function
        returned=list()

        #Usethe self contained data if not speficed otherwise
        elements=list(self)
        if isinstance(data, list) and data != None:
            elements=data
        else :
            AttributeError(&#39;data must be a list&#39;)

        #Printing message if specified.
        tqdm_args=dict()

        #The message will appear on loading bar if progress is True
        if progress is True :
            tqdm_args=dict(desc=&#39;Loading...&#39;, total=len(elements))
            if message != None:
                tqdm_args[&#39;desc&#39;]=message
        elif message != None:
            log.info(message)

        #Runs the callable on list on executor or by iterating
        if asynch == True :
            if isinstance(workers, int) :
                if progress==True :
                    if not self.nitro.config.quiet:
                        #Need to call tqdm to have better support for concurrent futures executor
                        # tqdm would load the whole bar intantaneously and not wait until the callable func returns. 
                        returned=list(tqdm.tqdm(concurrent.futures.ThreadPoolExecutor(
                        max_workers=workers ).map(
                            func, elements), **tqdm_args))
                    else:
                        log.warning(&#34;You requested to show perfrom progress but config&#39;s quiet value is True, not showing tqdm load bar.&#34;)
                        returned=list(concurrent.futures.ThreadPoolExecutor(
                        max_workers=workers ).map(
                            func, elements))
                else:
                    returned=list(concurrent.futures.ThreadPoolExecutor(
                    max_workers=workers ).map(
                        func, elements))
            else:
                raise AttributeError(&#39;When asynch == True : You must specify a integer value for workers&#39;)
        else :

            if progress==True:
                if not self.nitro.config.quiet:
                    elements=tqdm.tqdm(elements, **tqdm_args)
                else:
                    log.warning(&#34;You requested to show perform progress but config&#39;s quiet value is True, not showing tqdm load bar.&#34;)

            for index_or_item in elements:
                returned.append(func(index_or_item))

        return(returned)

    @staticmethod
    def _confirm_func(func, elements):
        &#34;&#34;&#34;
        Ask user inut to confirm the calling of `func` on `elements`.
        &#34;&#34;&#34;
        if not &#39;y&#39; in input(&#39;Are you sure you want to do this &#39;+str(func)+&#39; on &#39;+
        (&#39;\n&#39;+str(elements) if elements != None else &#39;all elements&#39;)+&#39;? [y/n]: &#39;):
            raise InterruptedError(&#34;The action was cancelled by the user.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.UserList</li>
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="msiempy.NitroObject" href="#msiempy.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="msiempy.FilteredQueryList" href="#msiempy.FilteredQueryList">FilteredQueryList</a></li>
<li><a title="msiempy.device.DevTree" href="device.html#msiempy.device.DevTree">DevTree</a></li>
<li><a title="msiempy.watchlist.WatchlistManager" href="watchlist.html#msiempy.watchlist.WatchlistManager">WatchlistManager</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.NitroList.text"><code class="name">var <span class="ident">text</span></code></dt>
<dd>
<div class="desc"><p>Defaut table string, a shorcut to <code>get_text()</code> with no arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text(self):
    &#34;&#34;&#34;Defaut table string, a shorcut to `get_text()` with no arguments.
    &#34;&#34;&#34;
    return self.get_text()</code></pre>
</details>
</dd>
<dt id="msiempy.NitroList.json"><code class="name">var <span class="ident">json</span></code></dt>
<dd>
<div class="desc"><p>JSON list of dicts representing the list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def json(self):
    &#34;&#34;&#34;JSON list of dicts representing the list.
    &#34;&#34;&#34;
    return(json.dumps([dict(item) for item in list(self)], indent=4, cls=NitroObject.NitroJSONEncoder))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.NitroList.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set of keys for all dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34;Set of keys for all dict&#34;&#34;&#34;
    #If new fields are added it won&#39;t show on text repr. Only json.
    manager_keys=set()
    for item in list(self): manager_keys.update(getattr(item, &#39;keys&#39;, set)())
    return manager_keys</code></pre>
</details>
</dd>
<dt id="msiempy.NitroList.get_text"><code class="name flex">
<span>def <span class="ident">get_text</span></span>(<span>self, format='prettytable', fields=None, max_column_width=80, get_text_nest_attr={})</span>
</code></dt>
<dd>
<div class="desc"><p>Return a csv or table string representation of the list</p>
<p>Arguments:
</p>
<ul>
<li><code>format</code>:
prettytable: Returns a table generated by prettytable
csv: Returns data with header and comma separated values. </li>
<li><code>fields</code>: list of fields you want in the table. If <code>None</code> : default fields are returned by .keys attribute and sorted.
</li>
<li><code>max_column_width</code>: when using prettytable only </li>
<li><code>get_text_nest_attr</code>: attributes passed to the nested <code><a title="msiempy.NitroList.get_text" href="#msiempy.NitroList.get_text">NitroList.get_text()</a></code> elements. Useful to control events appearence.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_text(self, format=&#39;prettytable&#39;, fields=None, 
                    max_column_width=80, get_text_nest_attr={} ):
    &#34;&#34;&#34;
    Return a csv or table string representation of the list

    Arguments:  

    - `format`: 
          prettytable: Returns a table generated by prettytable
          csv: Returns data with header and comma separated values. 
    - `fields`: list of fields you want in the table. If `None` : default fields are returned by .keys attribute and sorted.  
    - `max_column_width`: when using prettytable only 
    - `get_text_nest_attr`: attributes passed to the nested `msiempy.NitroList.get_text` elements. Useful to control events appearence.
    &#34;&#34;&#34;

    text=str()
    
    if not fields :
        fields=sorted(self.keys())

    if format == &#39;csv&#39;:
        file = StringIO()
        dw = csv.DictWriter(file, fields, extrasaction=&#39;ignore&#39;)
        dw.writeheader()
        dw.writerows(list(self))
        text = file.getvalue()

    elif format == &#39;prettytable&#39;:
        table = prettytable.PrettyTable()
        table.set_style(MSWORD_FRIENDLY)

        table.field_names=fields

        for item in list(self):
            if isinstance(item, (dict, NitroDict)):
                values=list()
                for field in fields:
                    obj=None
                    try:obj=item[field]
                    except KeyError : pass

                    if isinstance(obj, NitroList):
                        values.append(obj.get_text(**get_text_nest_attr))
                    else:
                        values.append(&#39;\n&#39;.join(textwrap.wrap(str(obj), width=max_column_width)))

                table.add_row(values)
                
            else : log.warning(&#34;Unnapropriate list element type, won&#39;t show on the prettytable : {}&#34;.format(str(item)))

        text=table.get_string()
    
    else :
        raise AttributeError(&#34;Unknown `NitroList.get_text` format : {}. Accepted values are &#39;prettytable&#39; or &#39;csv&#39;.&#34;.format(format))

    return text</code></pre>
</details>
</dd>
<dt id="msiempy.NitroList.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self, invert=False, match_prop='json', *pattern)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of elements that matches one or more regex patterns.
Patterns are applied one after another. It's a logic AND.
Use <code>|</code> inside patterns to search with logic OR.
This method will return a new NitroList with matching data. NitroDicts in the returned NitroList do not
references the items in the original NitroList.
</p>
<p>Arguments:
</p>
<ul>
<li><code>*pattern</code>: List or string regex patterns to look for.</li>
<li><code>invert</code>: Weither or not to invert the search and return elements that doesn't not match search.</li>
<li><code>match_prop</code>: Propertie that is going to be called to search. Could be <code>text</code> or <code>json</code>.</li>
</ul>
<p>If you wish to apply more specific filters to NitroList list, please
use filter(), list comprehension, or other filtering method.
i.e. : <code>[item for item in list if item['cost'] &gt; 50]</code></p>
<p>More on regex <a href="https://docs.python.org/3/library/re.html#re.Pattern.search">https://docs.python.org/3/library/re.html#re.Pattern.search</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(self, invert=False, match_prop=&#39;json&#39;, *pattern):
    &#34;&#34;&#34;
    Return a list of elements that matches one or more regex patterns.
    Patterns are applied one after another. It&#39;s a logic AND.
    Use `|` inside patterns to search with logic OR.
    This method will return a new NitroList with matching data. NitroDicts in the returned NitroList do not
    references the items in the original NitroList.  

    Arguments:  

    - `*pattern`: List or string regex patterns to look for.
    - `invert`: Weither or not to invert the search and return elements that doesn&#39;t not match search.
    - `match_prop`: Propertie that is going to be called to search. Could be `text` or `json`.


    If you wish to apply more specific filters to NitroList list, please
    use filter(), list comprehension, or other filtering method.
        i.e. : `[item for item in list if item[&#39;cost&#39;] &gt; 50]`

    More on regex https://docs.python.org/3/library/re.html#re.Pattern.search
    &#34;&#34;&#34;
    if pattern is None :
        return self
    elif len(pattern) == 0 :
        return self
    else :
        pattern=list(pattern)
        apattern=pattern.pop()
    
    matching_items=list()
    
    if isinstance(apattern, str):
        for item in list(self) :
            if regex_match(apattern, getattr(item, match_prop) if isinstance(item, NitroDict) else str(item)) != invert :
                matching_items.append(item)
        log.debug(&#34;You&#39;re search returned {} rows : {}&#34;.format(
            len(matching_items),
            str(matching_items)[:100]+&#39;...&#39;))
        #Apply AND reccursively
        return NitroList(alist=matching_items).search(*pattern, invert=invert, match_prop=match_prop)
    else:
        raise ValueError(&#39;pattern must be str&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroList.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute refresh function on all items.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;
    Execute refresh function on all items.
    &#34;&#34;&#34;
    log.warning(&#34;The function NitroList.refresh hasn&#39;t been correctly tested&#34;)
    self.perform(NitroDict.refresh, message=&#39;Refreshing all items...&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.NitroList.perform"><code class="name flex">
<span>def <span class="ident">perform</span></span>(<span>self, func, data=None, func_args=None, confirm=False, asynch=False, workers=None, progress=False, message=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper arround executable and the a list of elements, typically <code><a title="msiempy.NitroList" href="#msiempy.NitroList">NitroList</a></code> object.
</p>
<p>Arguments:
</p>
<ul>
<li><code>func</code>: callable function. <code>func</code> is going to be called like <code>func(item, **func_args)</code> on all items in data.
This function can be stateless (static) or statefull (first argument is <code>self</code>),
it doesn't really matter as the element will always be passed as the first argument of the function. On thing really important, the function must not
set/delete/change any global variable, as a result, you'll see your varible beeing potentially corrupted or chalenged with conccurent accesses.</li>
<li><code>data</code>: if stays <code>None</code>, will perform the action on itself (<code>list(self)</code>) else it will perfom the action on the <code>data</code> list.</li>
<li><code>func_args</code>: arguments that will be passed by default to <code>func</code> in all calls.</li>
<li><code>confirm</code>: will ask interactively confirmation.</li>
<li><code>asynch</code>: execute the task asynchronously with <code>concurrent.futures.ThreadPoolExecutor</code>. It will create a new executor object, so be carefull not to nest 2 asynchronous executions within eachother,
it will be a mess.</li>
<li><code>workers</code>: number of parrallel tasks, mandatory if asynch is true.</li>
<li><code>progress</code>: to show progress bar with ETA (tqdm).</li>
<li><code>message</code> : To show to the user.
</li>
</ul>
<p>This method is where the core of asynchronous tasks resides. <code>func</code> will be executed on all <code>data</code> elements.<br>
Basically, if <code>asynch==True</code>, will return :<br>
returned=list(concurrent.futures.ThreadPoolExecutor(
max_workers=workers ).map(
func, data))
</p>
<p>if <code>asynch==False</code>, will iterate and return :
for index_or_item in data:
returned.append(func(index_or_item))</p>
<p>Returns a list of returned results.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perform(self, func, data=None, func_args=None, confirm=False, asynch=False,  workers=None , progress=False, message=None):
    &#34;&#34;&#34;
    Wrapper arround executable and the a list of elements, typically `msiempy.NitroList` object.  

    Arguments:  
    
    - `func`: callable function. `func` is going to be called like `func(item, **func_args)` on all items in data.  This function can be stateless (static) or statefull (first argument is `self`),
    it doesn&#39;t really matter as the element will always be passed as the first argument of the function. On thing really important, the function must not
    set/delete/change any global variable, as a result, you&#39;ll see your varible beeing potentially corrupted or chalenged with conccurent accesses.
    - `data`: if stays `None`, will perform the action on itself (`list(self)`) else it will perfom the action on the `data` list.
    - `func_args`: arguments that will be passed by default to `func` in all calls.
    - `confirm`: will ask interactively confirmation.
    - `asynch`: execute the task asynchronously with `concurrent.futures.ThreadPoolExecutor`. It will create a new executor object, so be carefull not to nest 2 asynchronous executions within eachother,
    it will be a mess.
    - `workers`: number of parrallel tasks, mandatory if asynch is true.
    - `progress`: to show progress bar with ETA (tqdm).
    - `message` : To show to the user.  

    This method is where the core of asynchronous tasks resides. `func` will be executed on all `data` elements.  
    Basically, if `asynch==True`, will return :  
        returned=list(concurrent.futures.ThreadPoolExecutor(
                    max_workers=workers ).map(
                        func, data))  

    if `asynch==False`, will iterate and return :
        for index_or_item in data:
            returned.append(func(index_or_item))

    Returns a list of returned results.
    &#34;&#34;&#34;

    log.debug(&#39;Calling perform func=&#39;+str(func)+
        &#39; data=&#39;+str(data)[:100]+
        &#39; func_args=&#39;+str(func_args)+
        &#39; confirm=&#39;+str(confirm)+
        &#39; asynch=&#39;+str(asynch)+
        &#39; workers=&#39;+str(workers)+
        &#39; progress=&#39;+str(progress)+
        &#39; message=&#39;+str(message))

    if not callable(func) :
        raise ValueError(&#39;func must be callable&#39;)

    #Confirming with user if asked
    if confirm : self._confirm_func(func, str(self))

    #Setting the arguments on the function
    func = functools.partial(func, **(func_args if func_args != None else {}))
    
    #The data returned by function
    returned=list()

    #Usethe self contained data if not speficed otherwise
    elements=list(self)
    if isinstance(data, list) and data != None:
        elements=data
    else :
        AttributeError(&#39;data must be a list&#39;)

    #Printing message if specified.
    tqdm_args=dict()

    #The message will appear on loading bar if progress is True
    if progress is True :
        tqdm_args=dict(desc=&#39;Loading...&#39;, total=len(elements))
        if message != None:
            tqdm_args[&#39;desc&#39;]=message
    elif message != None:
        log.info(message)

    #Runs the callable on list on executor or by iterating
    if asynch == True :
        if isinstance(workers, int) :
            if progress==True :
                if not self.nitro.config.quiet:
                    #Need to call tqdm to have better support for concurrent futures executor
                    # tqdm would load the whole bar intantaneously and not wait until the callable func returns. 
                    returned=list(tqdm.tqdm(concurrent.futures.ThreadPoolExecutor(
                    max_workers=workers ).map(
                        func, elements), **tqdm_args))
                else:
                    log.warning(&#34;You requested to show perfrom progress but config&#39;s quiet value is True, not showing tqdm load bar.&#34;)
                    returned=list(concurrent.futures.ThreadPoolExecutor(
                    max_workers=workers ).map(
                        func, elements))
            else:
                returned=list(concurrent.futures.ThreadPoolExecutor(
                max_workers=workers ).map(
                    func, elements))
        else:
            raise AttributeError(&#39;When asynch == True : You must specify a integer value for workers&#39;)
    else :

        if progress==True:
            if not self.nitro.config.quiet:
                elements=tqdm.tqdm(elements, **tqdm_args)
            else:
                log.warning(&#34;You requested to show perform progress but config&#39;s quiet value is True, not showing tqdm load bar.&#34;)

        for index_or_item in elements:
            returned.append(func(index_or_item))

    return(returned)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.NitroObject" href="#msiempy.NitroObject">NitroObject</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.NitroObject.NitroJSONEncoder" href="#msiempy.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.NitroObject.nitro" href="#msiempy.NitroObject.nitro">nitro</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="msiempy.FilteredQueryList"><code class="flex name class">
<span>class <span class="ident">FilteredQueryList</span></span>
<span>(</span><span>*arg, time_range=None, start_time=None, end_time=None, filters=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for query based managers : <code><a title="msiempy.alarm.AlarmManager" href="alarm.html#msiempy.alarm.AlarmManager">AlarmManager</a></code>, <code><a title="msiempy.event.EventManager" href="event.html#msiempy.event.EventManager">EventManager</a></code>.<br>
FilteredQueryList object can handle time_ranges and time splitting.<br>
Abstract base class that provide time ranged filtered query wrapper.
</p>
<p>Arguments:
</p>
<ul>
<li><code>time_range</code> : Query time range. String representation of a time range.
See <code><a title="msiempy.FilteredQueryList.POSSIBLE_TIME_RANGE" href="#msiempy.FilteredQueryList.POSSIBLE_TIME_RANGE">FilteredQueryList.POSSIBLE_TIME_RANGE</a></code>.
</li>
<li><code>start_time</code> : Query starting time, can be a <code>string</code> or a <code>datetime</code> object. Parsed with <code>dateutil</code>.
</li>
<li><code>end_time</code> : Query endding time, can be a <code>string</code> or a <code>datetime</code> object. Parsed with <code>dateutil</code>.
</li>
<li><code>filters</code> : List of filters applied to the query.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FilteredQueryList(NitroList):
    &#34;&#34;&#34;
    Base class for query based managers : `msiempy.alarm.AlarmManager`, `msiempy.event.EventManager`.  
    FilteredQueryList object can handle time_ranges and time splitting.  
    Abstract base class that provide time ranged filtered query wrapper.  

    Arguments:  

    - `time_range` : Query time range. String representation of a time range. 
        See `msiempy.FilteredQueryList.POSSIBLE_TIME_RANGE`.  
    - `start_time` : Query starting time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  
    - `end_time` : Query endding time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  
    - `filters` : List of filters applied to the query.  
    &#34;&#34;&#34;
    def __init__(self, *arg, time_range=None, start_time=None, end_time=None, filters=None, **kwargs):

        # Handled eventual deprecated arguments
        if &#39;max_query_depth&#39; in kwargs :
            log.warning(&#39;Deprecated : `max_query_depth` argument has been removed from the object declaration for more clarty, it\&#39;s now a specilized EventManager.load_data() argument only. This argument will be ignored.&#39;)
            del kwargs[&#39;max_query_depth&#39;]
        if &#39;requests_size&#39; in kwargs :
            log.warning(&#39;Deprecated : `requests_size` argument has been removed from FilteredQueryList, use `page_size` for AlarmManager or `limit` for EventManager arguments.&#39;)
            del kwargs[&#39;requests_size&#39;]
        if &#39;load_async&#39; in kwargs :
            log.warning(&#39;Deprecated : `load_async` argument has been removed from FilteredQueryList. Queries are now always loaded asynchronously.&#39;)
            del kwargs[&#39;load_async&#39;]

        super().__init__(*arg, **kwargs)

        
        self.not_completed=False

        #self.nitro.config.default_rows #nb rows per request : eq limit/page_size = requests_size
        #self.nitro.config.max_rows #max nb rows 

        #Declaring attributes and types
        self._time_range=str()
        self._start_time=None
        self._end_time=None

        #self.filters=filters filter property setter should be called in the concrete class
        #TODO find a better solution to integrate the filter propertie

        if start_time != None and end_time != None :
            self.start_time=start_time
            self.end_time=end_time
            self.time_range=&#39;CUSTOM&#39;
        else :
            self.time_range=time_range
    
    DEFAULT_TIME_RANGE=&#34;CURRENT_DAY&#34;
    __pdoc__[&#39;FilteredQueryList.DEFAULT_TIME_RANGE&#39;]=&#34;&#34;&#34;Default time range : %(default)s&#34;&#34;&#34; % dict(default=DEFAULT_TIME_RANGE)

    POSSIBLE_TIME_RANGE=[
            &#34;CUSTOM&#34;,
            &#34;LAST_MINUTE&#34;,
            &#34;LAST_10_MINUTES&#34;,
            &#34;LAST_30_MINUTES&#34;,
            &#34;LAST_HOUR&#34;,
            &#34;CURRENT_DAY&#34;,
            &#34;PREVIOUS_DAY&#34;,
            &#34;LAST_24_HOURS&#34;,
            &#34;LAST_2_DAYS&#34;,
            &#34;LAST_3_DAYS&#34;,
            &#34;CURRENT_WEEK&#34;,
            &#34;PREVIOUS_WEEK&#34;,
            &#34;CURRENT_MONTH&#34;,
            &#34;PREVIOUS_MONTH&#34;,
            &#34;CURRENT_QUARTER&#34;,
            &#34;PREVIOUS_QUARTER&#34;,
            &#34;CURRENT_YEAR&#34;,
            &#34;PREVIOUS_YEAR&#34;
    ]
    __pdoc__[&#39;FilteredQueryList.POSSIBLE_TIME_RANGE&#39;]=&#34;&#34;&#34;
    List of possible time ranges : `%(timeranges)s`&#34;&#34;&#34; % dict(timeranges=&#39;, &#39;.join(POSSIBLE_TIME_RANGE))

    @property
    def time_range(self):
        &#34;&#34;&#34;
        Query time range. See `msiempy.FilteredQueryList.POSSIBLE_TIME_RANGE`.
        Default to `msiempy.FilteredQueryList.DEFAULT_TIME_RANGE` (CURRENT_DAY).
        Note that the time range is upper cased automatically.
        Raises `VallueError` if unrecognized time range is set and `AttributeError` if not the right type.
        &#34;&#34;&#34;
        return self._time_range.upper()

    @time_range.setter
    def time_range(self, time_range):
        if not time_range :
            self.time_range=self.DEFAULT_TIME_RANGE

        elif isinstance(time_range, str):
            time_range=time_range.upper()
            if time_range in self.POSSIBLE_TIME_RANGE :
                if time_range != &#39;CUSTOM&#39;:
                    self.start_time=None
                    self.end_time=None
                self._time_range=time_range
            else:
                raise ValueError(&#34;The time range must be in &#34;+str(self.POSSIBLE_TIME_RANGE))
        else:
            raise AttributeError(&#39;time_range must be a string or None&#39;)

    @property
    def start_time(self):
        &#34;&#34;&#34;
        Start time of the query in the right SIEM format.  
        Use `_start_time` to get the datetime object. You can set the `star_time` as a `str` or a `datetime`.  
        If `None`, equivalent CURRENT_DAY start 00:00:00.  
        Raises: `ValueError` if not the right type.  
        &#34;&#34;&#34;
        return format_esm_time(self._start_time)

    @start_time.setter
    def start_time(self, start_time):
        if isinstance(start_time, str):
            self.start_time = convert_to_time_obj(start_time)
        elif isinstance(start_time, datetime.datetime):
            self._start_time = start_time
        elif start_time==None:
             self._start_time=None #raise ValueError(&#34;Time must be string or datetime object, not None&#34;)#self.start_time = datetime.datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        else:
            raise ValueError(&#34;Time must be string or datetime object.&#34;)

    @property
    def end_time(self):
        &#34;&#34;&#34;
        End time of the query in the right SIEM format.  
        Use `_end_time` property to get the datetime object. You can set the `end_time` as a `str` or a `datetime`.  
        If `None`, equivalent CURRENT_DAY.  
        Raises `ValueError` if not the right type.
        &#34;&#34;&#34;
        return format_esm_time(self._end_time)

    @end_time.setter
    def end_time(self, end_time):       
        if isinstance(end_time, str):
            self.end_time = convert_to_time_obj(end_time)
        elif isinstance(end_time, datetime.datetime):
            self._end_time = end_time
        elif end_time==None:
             self._end_time=None #raise ValueError(&#34;Time must be string or datetime object, not None&#34;)
        else:
            raise ValueError(&#34;Time must be string or datetime object.&#34;)

    @abc.abstractproperty
    def filters(self):
        &#34;&#34;&#34; 
        Filter property : Returns a list of filters.
        Can be set with list of tuple(field, [values]), a `msiempy.event.FieldFilter` or `msiempy.event.GroupFilter` in the case of a `msiempy.event.EventManager` query. A single tuple is also accepted.  
        `None` value will trigger `msiempy.FilteredQueryList.clear_filters()`.  
        Raises : `AttributeError` if type not supported.
        Abstract declaration.
        TODO find a better solution to integrate the filter property
        &#34;&#34;&#34;
        pass

    @filters.setter
    def filters(self, filters):
        if isinstance(filters, list):
            for f in filters :
                self.add_filter(f)

        elif isinstance(filters, tuple):
            self.add_filter(filters)

        elif filters == None :
            self.clear_filters()
        
        else :
            raise AttributeError(&#34;Illegal type for the filter object, it must be a list, a tuple or None.&#34;)

    
    @abc.abstractmethod
    def add_filter(self, filter):
        &#34;&#34;&#34;Add a filter to the query.  
        Abstract declaration.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def clear_filters(self):
        &#34;&#34;&#34;Remove all filters to the query.  
        Abstract declaration.
        &#34;&#34;&#34;
        pass 

    @abc.abstractmethod
    def qry_load_data(self, *args, **kwargs):
        &#34;&#34;&#34;
        Method to load the data from the SIEM.  
        Rturns a `tuple ((items, completed))`.  
        Abstract declaration.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def load_data(self, *args, **kwargs):
        &#34;&#34;&#34;Load the data from the SIEM into the manager list.  
        Abstract declaration.&#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="msiempy.NitroList" href="#msiempy.NitroList">NitroList</a></li>
<li>collections.UserList</li>
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="msiempy.NitroObject" href="#msiempy.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="msiempy.alarm.AlarmManager" href="alarm.html#msiempy.alarm.AlarmManager">AlarmManager</a></li>
<li><a title="msiempy.event.EventManager" href="event.html#msiempy.event.EventManager">EventManager</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.FilteredQueryList.DEFAULT_TIME_RANGE"><code class="name">var <span class="ident">DEFAULT_TIME_RANGE</span></code></dt>
<dd>
<div class="desc"><p>Default time range : CURRENT_DAY</p></div>
</dd>
<dt id="msiempy.FilteredQueryList.POSSIBLE_TIME_RANGE"><code class="name">var <span class="ident">POSSIBLE_TIME_RANGE</span></code></dt>
<dd>
<div class="desc"><p>List of possible time ranges : <code>CUSTOM, LAST_MINUTE, LAST_10_MINUTES, LAST_30_MINUTES, LAST_HOUR, CURRENT_DAY, PREVIOUS_DAY, LAST_24_HOURS, LAST_2_DAYS, LAST_3_DAYS, CURRENT_WEEK, PREVIOUS_WEEK, CURRENT_MONTH, PREVIOUS_MONTH, CURRENT_QUARTER, PREVIOUS_QUARTER, CURRENT_YEAR, PREVIOUS_YEAR</code></p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.FilteredQueryList.time_range"><code class="name">var <span class="ident">time_range</span></code></dt>
<dd>
<div class="desc"><p>Query time range. See <code><a title="msiempy.FilteredQueryList.POSSIBLE_TIME_RANGE" href="#msiempy.FilteredQueryList.POSSIBLE_TIME_RANGE">FilteredQueryList.POSSIBLE_TIME_RANGE</a></code>.
Default to <code><a title="msiempy.FilteredQueryList.DEFAULT_TIME_RANGE" href="#msiempy.FilteredQueryList.DEFAULT_TIME_RANGE">FilteredQueryList.DEFAULT_TIME_RANGE</a></code> (CURRENT_DAY).
Note that the time range is upper cased automatically.
Raises <code>VallueError</code> if unrecognized time range is set and <code>AttributeError</code> if not the right type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_range(self):
    &#34;&#34;&#34;
    Query time range. See `msiempy.FilteredQueryList.POSSIBLE_TIME_RANGE`.
    Default to `msiempy.FilteredQueryList.DEFAULT_TIME_RANGE` (CURRENT_DAY).
    Note that the time range is upper cased automatically.
    Raises `VallueError` if unrecognized time range is set and `AttributeError` if not the right type.
    &#34;&#34;&#34;
    return self._time_range.upper()</code></pre>
</details>
</dd>
<dt id="msiempy.FilteredQueryList.start_time"><code class="name">var <span class="ident">start_time</span></code></dt>
<dd>
<div class="desc"><p>Start time of the query in the right SIEM format.<br>
Use <code>_start_time</code> to get the datetime object. You can set the <code>star_time</code> as a <code>str</code> or a <code>datetime</code>.<br>
If <code>None</code>, equivalent CURRENT_DAY start 00:00:00.<br>
Raises: <code>ValueError</code> if not the right type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start_time(self):
    &#34;&#34;&#34;
    Start time of the query in the right SIEM format.  
    Use `_start_time` to get the datetime object. You can set the `star_time` as a `str` or a `datetime`.  
    If `None`, equivalent CURRENT_DAY start 00:00:00.  
    Raises: `ValueError` if not the right type.  
    &#34;&#34;&#34;
    return format_esm_time(self._start_time)</code></pre>
</details>
</dd>
<dt id="msiempy.FilteredQueryList.end_time"><code class="name">var <span class="ident">end_time</span></code></dt>
<dd>
<div class="desc"><p>End time of the query in the right SIEM format.<br>
Use <code>_end_time</code> property to get the datetime object. You can set the <code>end_time</code> as a <code>str</code> or a <code>datetime</code>.<br>
If <code>None</code>, equivalent CURRENT_DAY.<br>
Raises <code>ValueError</code> if not the right type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end_time(self):
    &#34;&#34;&#34;
    End time of the query in the right SIEM format.  
    Use `_end_time` property to get the datetime object. You can set the `end_time` as a `str` or a `datetime`.  
    If `None`, equivalent CURRENT_DAY.  
    Raises `ValueError` if not the right type.
    &#34;&#34;&#34;
    return format_esm_time(self._end_time)</code></pre>
</details>
</dd>
<dt id="msiempy.FilteredQueryList.filters"><code class="name">var <span class="ident">filters</span></code></dt>
<dd>
<div class="desc"><p>Filter property : Returns a list of filters.
Can be set with list of tuple(field, [values]), a <code><a title="msiempy.event.FieldFilter" href="event.html#msiempy.event.FieldFilter">FieldFilter</a></code> or <code><a title="msiempy.event.GroupFilter" href="event.html#msiempy.event.GroupFilter">GroupFilter</a></code> in the case of a <code><a title="msiempy.event.EventManager" href="event.html#msiempy.event.EventManager">EventManager</a></code> query. A single tuple is also accepted.<br>
<code>None</code> value will trigger <code><a title="msiempy.FilteredQueryList.clear_filters" href="#msiempy.FilteredQueryList.clear_filters">FilteredQueryList.clear_filters()</a></code>.<br>
Raises : <code>AttributeError</code> if type not supported.
Abstract declaration.
TODO find a better solution to integrate the filter property</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractproperty
def filters(self):
    &#34;&#34;&#34; 
    Filter property : Returns a list of filters.
    Can be set with list of tuple(field, [values]), a `msiempy.event.FieldFilter` or `msiempy.event.GroupFilter` in the case of a `msiempy.event.EventManager` query. A single tuple is also accepted.  
    `None` value will trigger `msiempy.FilteredQueryList.clear_filters()`.  
    Raises : `AttributeError` if type not supported.
    Abstract declaration.
    TODO find a better solution to integrate the filter property
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.FilteredQueryList.add_filter"><code class="name flex">
<span>def <span class="ident">add_filter</span></span>(<span>self, filter)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a filter to the query.<br>
Abstract declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def add_filter(self, filter):
    &#34;&#34;&#34;Add a filter to the query.  
    Abstract declaration.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="msiempy.FilteredQueryList.clear_filters"><code class="name flex">
<span>def <span class="ident">clear_filters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all filters to the query.<br>
Abstract declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def clear_filters(self):
    &#34;&#34;&#34;Remove all filters to the query.  
    Abstract declaration.
    &#34;&#34;&#34;
    pass </code></pre>
</details>
</dd>
<dt id="msiempy.FilteredQueryList.qry_load_data"><code class="name flex">
<span>def <span class="ident">qry_load_data</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to load the data from the SIEM.<br>
Rturns a <code>tuple ((items, completed))</code>.<br>
Abstract declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def qry_load_data(self, *args, **kwargs):
    &#34;&#34;&#34;
    Method to load the data from the SIEM.  
    Rturns a `tuple ((items, completed))`.  
    Abstract declaration.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="msiempy.FilteredQueryList.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the data from the SIEM into the manager list.<br>
Abstract declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def load_data(self, *args, **kwargs):
    &#34;&#34;&#34;Load the data from the SIEM into the manager list.  
    Abstract declaration.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.NitroList" href="#msiempy.NitroList">NitroList</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.NitroList.NitroJSONEncoder" href="#msiempy.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.NitroList.get_text" href="#msiempy.NitroList.get_text">get_text</a></code></li>
<li><code><a title="msiempy.NitroList.json" href="#msiempy.NitroList.json">json</a></code></li>
<li><code><a title="msiempy.NitroList.keys" href="#msiempy.NitroList.keys">keys</a></code></li>
<li><code><a title="msiempy.NitroList.nitro" href="#msiempy.NitroObject.nitro">nitro</a></code></li>
<li><code><a title="msiempy.NitroList.perform" href="#msiempy.NitroList.perform">perform</a></code></li>
<li><code><a title="msiempy.NitroList.refresh" href="#msiempy.NitroList.refresh">refresh</a></code></li>
<li><code><a title="msiempy.NitroList.search" href="#msiempy.NitroList.search">search</a></code></li>
<li><code><a title="msiempy.NitroList.text" href="#msiempy.NitroList.text">text</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="msiempy.NitroError"><code class="flex name class">
<span>class <span class="ident">NitroError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Base internal exception.<br>
It's used when the user/passwd is incorrect, or other specific ESM related errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NitroError(Exception):
    &#34;&#34;&#34;
    Base internal exception.  
    It&#39;s used when the user/passwd is incorrect, or other specific ESM related errors.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="msiempy.alarm" href="alarm.html">msiempy.alarm</a></code></li>
<li><code><a title="msiempy.device" href="device.html">msiempy.device</a></code></li>
<li><code><a title="msiempy.event" href="event.html">msiempy.event</a></code></li>
<li><code><a title="msiempy.watchlist" href="watchlist.html">msiempy.watchlist</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="msiempy.NitroConfig" href="#msiempy.NitroConfig">NitroConfig</a></code></h4>
<ul class="two-column">
<li><code><a title="msiempy.NitroConfig.find_ini_location" href="#msiempy.NitroConfig.find_ini_location">find_ini_location</a></code></li>
<li><code><a title="msiempy.NitroConfig.write" href="#msiempy.NitroConfig.write">write</a></code></li>
<li><code><a title="msiempy.NitroConfig.iset" href="#msiempy.NitroConfig.iset">iset</a></code></li>
<li><code><a title="msiempy.NitroConfig.user" href="#msiempy.NitroConfig.user">user</a></code></li>
<li><code><a title="msiempy.NitroConfig.host" href="#msiempy.NitroConfig.host">host</a></code></li>
<li><code><a title="msiempy.NitroConfig.passwd" href="#msiempy.NitroConfig.passwd">passwd</a></code></li>
<li><code><a title="msiempy.NitroConfig.verbose" href="#msiempy.NitroConfig.verbose">verbose</a></code></li>
<li><code><a title="msiempy.NitroConfig.quiet" href="#msiempy.NitroConfig.quiet">quiet</a></code></li>
<li><code><a title="msiempy.NitroConfig.logfile" href="#msiempy.NitroConfig.logfile">logfile</a></code></li>
<li><code><a title="msiempy.NitroConfig.timeout" href="#msiempy.NitroConfig.timeout">timeout</a></code></li>
<li><code><a title="msiempy.NitroConfig.ssl_verify" href="#msiempy.NitroConfig.ssl_verify">ssl_verify</a></code></li>
<li><code><a title="msiempy.NitroConfig.CONFIG_FILE_NAME" href="#msiempy.NitroConfig.CONFIG_FILE_NAME">CONFIG_FILE_NAME</a></code></li>
<li><code><a title="msiempy.NitroConfig.CONF_DIR" href="#msiempy.NitroConfig.CONF_DIR">CONF_DIR</a></code></li>
<li><code><a title="msiempy.NitroConfig.DEFAULT_CONF_DICT" href="#msiempy.NitroConfig.DEFAULT_CONF_DICT">DEFAULT_CONF_DICT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.NitroSession" href="#msiempy.NitroSession">NitroSession</a></code></h4>
<ul class="two-column">
<li><code><a title="msiempy.NitroSession.format_params" href="#msiempy.NitroSession.format_params">format_params</a></code></li>
<li><code><a title="msiempy.NitroSession.format_priv_resp" href="#msiempy.NitroSession.format_priv_resp">format_priv_resp</a></code></li>
<li><code><a title="msiempy.NitroSession.unpack_resp" href="#msiempy.NitroSession.unpack_resp">unpack_resp</a></code></li>
<li><code><a title="msiempy.NitroSession.login" href="#msiempy.NitroSession.login">login</a></code></li>
<li><code><a title="msiempy.NitroSession.logout" href="#msiempy.NitroSession.logout">logout</a></code></li>
<li><code><a title="msiempy.NitroSession.esm_request" href="#msiempy.NitroSession.esm_request">esm_request</a></code></li>
<li><code><a title="msiempy.NitroSession.version" href="#msiempy.NitroSession.version">version</a></code></li>
<li><code><a title="msiempy.NitroSession.buildstamp" href="#msiempy.NitroSession.buildstamp">buildstamp</a></code></li>
<li><code><a title="msiempy.NitroSession.get_internal_file" href="#msiempy.NitroSession.get_internal_file">get_internal_file</a></code></li>
<li><code><a title="msiempy.NitroSession.request" href="#msiempy.NitroSession.request">request</a></code></li>
<li><code><a title="msiempy.NitroSession.BASE_URL" href="#msiempy.NitroSession.BASE_URL">BASE_URL</a></code></li>
<li><code><a title="msiempy.NitroSession.BASE_URL_PRIV" href="#msiempy.NitroSession.BASE_URL_PRIV">BASE_URL_PRIV</a></code></li>
<li><code><a title="msiempy.NitroSession.config" href="#msiempy.NitroSession.config">config</a></code></li>
<li><code><a title="msiempy.NitroSession.PARAMS" href="#msiempy.NitroSession.PARAMS">PARAMS</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.NitroObject" href="#msiempy.NitroObject">NitroObject</a></code></h4>
<ul class="">
<li><code><a title="msiempy.NitroObject.refresh" href="#msiempy.NitroObject.refresh">refresh</a></code></li>
<li><code><a title="msiempy.NitroObject.text" href="#msiempy.NitroObject.text">text</a></code></li>
<li><code><a title="msiempy.NitroObject.json" href="#msiempy.NitroObject.json">json</a></code></li>
<li><code><a title="msiempy.NitroObject.NitroJSONEncoder" href="#msiempy.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.NitroObject.nitro" href="#msiempy.NitroObject.nitro">nitro</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.NitroDict" href="#msiempy.NitroDict">NitroDict</a></code></h4>
<ul class="">
<li><code><a title="msiempy.NitroDict.data_from_id" href="#msiempy.NitroDict.data_from_id">data_from_id</a></code></li>
<li><code><a title="msiempy.NitroDict.json" href="#msiempy.NitroDict.json">json</a></code></li>
<li><code><a title="msiempy.NitroDict.text" href="#msiempy.NitroDict.text">text</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.NitroList" href="#msiempy.NitroList">NitroList</a></code></h4>
<ul class="two-column">
<li><code><a title="msiempy.NitroList.keys" href="#msiempy.NitroList.keys">keys</a></code></li>
<li><code><a title="msiempy.NitroList.get_text" href="#msiempy.NitroList.get_text">get_text</a></code></li>
<li><code><a title="msiempy.NitroList.search" href="#msiempy.NitroList.search">search</a></code></li>
<li><code><a title="msiempy.NitroList.refresh" href="#msiempy.NitroList.refresh">refresh</a></code></li>
<li><code><a title="msiempy.NitroList.perform" href="#msiempy.NitroList.perform">perform</a></code></li>
<li><code><a title="msiempy.NitroList.text" href="#msiempy.NitroList.text">text</a></code></li>
<li><code><a title="msiempy.NitroList.json" href="#msiempy.NitroList.json">json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.FilteredQueryList" href="#msiempy.FilteredQueryList">FilteredQueryList</a></code></h4>
<ul class="two-column">
<li><code><a title="msiempy.FilteredQueryList.add_filter" href="#msiempy.FilteredQueryList.add_filter">add_filter</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.clear_filters" href="#msiempy.FilteredQueryList.clear_filters">clear_filters</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.qry_load_data" href="#msiempy.FilteredQueryList.qry_load_data">qry_load_data</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.load_data" href="#msiempy.FilteredQueryList.load_data">load_data</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.time_range" href="#msiempy.FilteredQueryList.time_range">time_range</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.start_time" href="#msiempy.FilteredQueryList.start_time">start_time</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.end_time" href="#msiempy.FilteredQueryList.end_time">end_time</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.filters" href="#msiempy.FilteredQueryList.filters">filters</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.DEFAULT_TIME_RANGE" href="#msiempy.FilteredQueryList.DEFAULT_TIME_RANGE">DEFAULT_TIME_RANGE</a></code></li>
<li><code><a title="msiempy.FilteredQueryList.POSSIBLE_TIME_RANGE" href="#msiempy.FilteredQueryList.POSSIBLE_TIME_RANGE">POSSIBLE_TIME_RANGE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.NitroError" href="#msiempy.NitroError">NitroError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>msiempy.alarm API documentation</title>
<meta name="description" content="Provide alarm management." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>msiempy.alarm</code></h1>
</header>
<section id="section-intro">
<p>Provide alarm management.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Provide alarm management.  
&#34;&#34;&#34;
import collections
import logging
log = logging.getLogger(&#39;msiempy&#39;)

from .core import NitroDict, FilteredQueryList
from .event import Event
from .core.utils import regex_match, dehexify

__pdoc__={}

__pdoc__[&#39;AlarmManager.status_filter&#39;]=&#34;Alarms status filter&#34;
__pdoc__[&#39;AlarmManager.page_size&#39;]=&#34;Max number of alarms per query&#34;
__pdoc__[&#39;AlarmManager.page_number&#39;]=&#34;The alarms page to load&#34;
__pdoc__[&#39;AlarmManager.time_range&#39;]=&#34;Query time range&#34;
__pdoc__[&#39;AlarmManager.start_time&#39;]=&#34;Query start time&#34;
__pdoc__[&#39;AlarmManager.end_time&#39;]=&#34;Query end time&#34;

class AlarmManager(FilteredQueryList):
    &#34;&#34;&#34;
    Interface to query and manage Alarms.  
    Inherits from `msiempy.core.query.FilteredQueryList`.

    Arguments:  

    - `status_filter` : status of the alarms to query. `status_filter` is not a filter like other cause it&#39;s computed on the SIEM side.  
    Accepted values : `acknowledged`, `unacknowledged`, `all`, `` or `None` (default is ``).
    `filters` are computed locally - Unlike `msiempy.event.EventManager` filters.  
    - `page_size` : max number of rows per query.  
    - `page_number` : defaulted to 1.
    - `filters` : `[(field, [values]), (field, [values])]` Filters applied to `msiempy.alarm.Alarm` objects. A single `tuple` is also accepted. 
    - `event_filters` : `[(field, [values]), (field, [values])]` Filters applied to `msiempy.event.Event` objects. A single `tuple` is also accepted.  
    - `time_range` : Query time range. String representation of a time range.  
    - `start_time` : Query starting time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  
    - `end_time` : Query endding time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  

    **Unlike `EventManager`, filters are computed after the data loaded with regex matching.**  
    
    &#34;&#34;&#34;
    def __init__(self, *args, status_filter=&#39;all&#39;, page_size=200, filters=None, event_filters=None, **kwargs):
        super().__init__(*args, **kwargs)

        #Declaring attributes
        self._alarm_filters = list(tuple())
        self._event_filters = list(tuple())
        self._status_filter = str()

        #Setting attributes
        self.status_filter=status_filter
        self.page_size=page_size

        #uses the parent filter setter
        #TODO : find a soltuion not to use this
        #calling super().filters=filters #https://bugs.python.org/issue14965
        super(self.__class__, self.__class__).filters.__set__(self, filters)

        #Seeting events filters after alarms filters cause it would overwrite it
        self.event_filters=event_filters

        #Casting all data to Alarms objects, better way to do it ?
        collections.UserList.__init__(self, [Alarm(adict=item) for item in self.data if isinstance(item, (dict, NitroDict))])

    @property
    def filters(self):
        &#34;&#34;&#34;
        The alarm related filters
        &#34;&#34;&#34;
        return self._alarm_filters
    
    @property
    def status_filter(self):
        &#34;&#34;&#34;
        Status of the alarms in the query.  
        &#34;&#34;&#34;
        return self._status_filter

    @status_filter.setter
    def status_filter(self, status_filter):
        status_found=False
        if type(status_filter) is str : 
            for synonims in Alarm.POSSIBLE_ALARM_STATUS :
                if status_filter in synonims:
                    self._status_filter=synonims[0]
                    status_found=True

        if not status_found:
            raise AttributeError(&#34;Illegal value of status filter. The status must be in &#34;+str(Alarm.POSSIBLE_ALARM_STATUS)+&#39; not :&#39;+str(status_filter))

    def add_filter(self, afilter):
        &#34;&#34;&#34;
        Add a filter to the query.  
        
        Arguments :  

        - `afilter` : Can be a a tuple `(field, [values])` or `(field, value)` or `str` &#39;field=value&#39;

        Filters format is `tuple(field, [values])`.  
        &#34;&#34;&#34;

        if isinstance(afilter,str): afilter = afilter.split(&#39;=&#39;,1)
        
        values = afilter[1] if isinstance(afilter[1], list) else [afilter[1]]
        values = [str(v) for v in values]
        added=False

        for synonims in Alarm.ALARM_EVENT_FILTER_FIELDS :
            if afilter[0] in synonims :
                log.warning(&#39;Passing event related filters in `filters` argument is not safe consider using `event_filters` argument. You\&#39;ll be able to use more filters dynamically.&#39;)
                self._event_filters.append((synonims[0], values))
                added=True

        #support query related filtering if the filter&#39;s field is composed by a table name then a field name separated by a dot.
        if len(afilter[0].split(&#39;.&#39;)) == 2 :
            self._event_filters.append((afilter[0], values))
            log.warning(&#39;Passing event related filters in `filters` argument is not safe, consider using `event_filters` argument. You\&#39;ll be able to use more filters dynamically.&#39;)
            added=True

        if added==False:
            self._alarm_filters.append((afilter[0], values))
            added=True

    @property
    def event_filters(self):
        &#34;&#34;&#34;Event related filters.&#34;&#34;&#34;
        return self._event_filters

    @event_filters.setter
    def event_filters(self, filters):
        if isinstance(filters, list):
            for f in filters :
                self.add_event_filter(f)

        elif isinstance(filters, tuple):
            self.add_event_filter(filters)

        elif filters == None :
            self._event_filters=list(tuple())
        
        else :
            raise AttributeError(&#34;Illegal type for the filter object, it must be a list, a tuple or None.&#34;)

    def add_event_filter(self, afilter):
        &#34;&#34;&#34;
        Add a event filter to the query.  
        
        Arguments :  

        - `afilter` : Can be a a tuple `(field, [values])` or `(field, value)` or `str` &#39;field=value&#39;

        Filters format is `tuple(field, [values])`.  
        &#34;&#34;&#34;

        if isinstance(afilter,str):
            afilter = afilter.split(&#39;=&#39;,1)
       
        values = afilter[1] if isinstance(afilter[1], list) else [afilter[1]]
        values = [str(v) for v in values] 
        self._event_filters.append((afilter[0], values))

    def clear_filters(self):
        &#34;&#34;&#34;
        Reset local alarm and event filters.
        &#34;&#34;&#34;
        self._alarm_filters = list(tuple())
        self._event_filters = list(tuple())

    def load_data(self, pages=1, **kwargs):
        &#34;&#34;&#34;
        Load the data into the list.  
        Implements automatic paging over `msiempy.alarm.AlarmManager.qry_load_data`.  
        Default behaviour is to load all alarms informations. Meaning that foreach alarms, 
        the full details is loaded, then the trigerring event details is loaded.  
        
        Arguments :  

        - `pages` : Number of pages to load (not asynchronous).   

        Arguments passed to `msiempy.alarm.AlarmManager.qry_load_data` :  

        - `workers` : Number of asynchronous workers   
        - `alarms_details` : Load detailed alarms infos. If `False`, only a couple values are loaded, no `events` infos.  
        - `events_details` : Load detailed events infos. If `False`, no detailed `events` will be loaded only `str` representation.  
        - `use_query` : Uses the query module to retreive event data. Only works with SIEM v11.2.1 or greater.  
        Default behaviour will call `ipsGetAlertData` to retreive the complete event definition.    
        - `extra_fields` :  Only when `use_query=True`. Additionnal event fields to load in the query. See : `msiempy.event.EventManager`  
        - `page_number` : Page number, default to 1. Do not touch if you&#39;re using `pages` parameter  

        Returns : `msiempy.alarm.AlarmManager`
        &#34;&#34;&#34;

        items, completed = self.qry_load_data(**kwargs)
        #Casting items to Alarms
        alarms=[Alarm(adict=item) for item in items]

        #Iterative automatic paging (not asynchronous)
        if not completed and pages&gt;1 :
            next_kwargs={**kwargs}
            if &#39;page_number&#39; in kwargs : next_kwargs[&#39;page_number&#39;]=kwargs[&#39;page_number&#39;]+1
            else: next_kwargs[&#39;page_number&#39;]=2

            log.info(&#39;Loading pages... ({})&#39;.format(next_kwargs[&#39;page_number&#39;]))
            alarms=alarms+list(self.load_data(pages=pages-1, **next_kwargs))

        if &#39;page_number&#39; not in kwargs:
            log.info(str(len(alarms)) + &#34; alarms are matching your filter(s)&#34;)

        
        self.data=alarms
        return(self)

    def qry_load_data(self, workers=10,
        alarms_details=True, events_details=True,
        use_query=False, extra_fields=[], page_number=1):
        &#34;&#34;&#34;
        Method that query, filter and return the alarms data :  
        -&gt; Fetch the list of alarms and load alarms details  
        -&gt; Filter depending on alarms related filters  
        -&gt; Load the events details  
        -&gt; Filter depending on event related filters  

        Arguments :  

        - `workers` : Number of asynchronous workers  
        - `alarms_details` : Load detailed alarms infos. If `False`, only a couple values are loaded, no `events` infos.
        - `events_details` : Load detailed events infos. If `False`, no detailed `events` will be loaded only `str` representation.
        - `use_query` : Uses the query module to retreive event data. Only works with SIEM v11.2.1 or greater.  
        - `extra_fields` :  Only when `use_query=True`. Additionnal event fields to load in the query. See : `msiempy.event.EventManager`  
        - `page_number` : Page number, default to 1. Do not touch if you&#39;re using `pages` parameter  
        
        Returns : `tuple` : ( Results : `list` , Status of the query : `completed` )

        &#34;&#34;&#34;

        if self.time_range == &#39;CUSTOM&#39; :
            no_filtered_alarms=self.nitro.request(
                &#39;get_alarms_custom_time&#39;,
                time_range=self.time_range,
                start_time=self.start_time,
                end_time=self.end_time,
                status=self.status_filter,
                page_size=self.page_size,
                page_number=page_number
                )

        else :
            no_filtered_alarms=self.nitro.request(
                &#39;get_alarms&#39;,
                time_range=self.time_range,
                status=self.status_filter,
                page_size=self.page_size,
                page_number=page_number
                )

        #Casting to list of Alarms to be able to call load_details etc...        
        alarm_based_filtered = [Alarm(adict=a) for a in no_filtered_alarms if self._alarm_match(a)]

        if alarms_details :

            log.info(&#34;Getting alarms infos...&#34;)
            alarm_detailed = self.perform(Alarm.load_details,
                list(alarm_based_filtered),
                asynch=True,
                progress=True,
                workers=workers)

            #Casting to list of Alarms to be able to call load_details etc...        
            detailed_alarm_based_filtered = [Alarm(adict=a) for a in alarm_detailed if self._alarm_match(a)]

            if events_details :
                log.info(&#34;Getting events infos...&#34;)
                event_detailed = self.perform(Alarm.load_events, 
                    list(alarm_detailed),
                    func_args=dict(use_query=use_query, extra_fields=extra_fields),
                    asynch=True, 
                    progress=True, 
                    workers=workers)

                filtered_alarms = [a for a in event_detailed if self._event_match(a)]
            else:
                log.warning(&#39;Field based Event filters are ignored when `events_details is False`. You can use `events` keyword in alarms filters to match str representation.&#39;)
                filtered_alarms=detailed_alarm_based_filtered
        else :
            filtered_alarms = alarm_based_filtered
            log.warning(&#39;Event filters and some Alarm filters are ignored when `alarms_details is False`&#39;)

        return (( filtered_alarms , len(no_filtered_alarms) &lt; int(self.page_size) ))

    def _alarm_match(self, alarm):
        &#34;&#34;&#34;
        Internal filter method that is going to return True if the passed alarm match any alarm related filters.
        &#34;&#34;&#34;
        match=True
        for alarm_filter in self._alarm_filters :
            match=False
            try: value = str(alarm[alarm_filter[0]]) #Can only match strings
            except KeyError: break
            for filter_value in alarm_filter[1]:
                if regex_match(filter_value.lower(), value.lower()):
                    match=True
                    break
            if not match :
                break
        return match
        
    def _event_match(self, alarm):
        &#34;&#34;&#34;
        Internal filter method that is going to return True if the passed alarm match any event related filters.
        &#34;&#34;&#34;
        match=True
        for event_filter in self._event_filters :
            match=False
            try: value = str(alarm[&#39;events&#39;][0][event_filter[0]])
            except KeyError: break
            for filter_value in event_filter[1]:
                if regex_match(filter_value.lower(), value.lower()) :
                    match=True
                    break
            if not match :
                break
        return match



class Alarm(NitroDict):
    &#34;&#34;&#34;
    Dict-Like object.  

    Common keys :  

    - `id` : The ID of the triggered alarm  
    - `summary`  : The summary of the triggered alarm  
    - `assignee` : The assignee for this triggered alarm  
    - `severity` : The severity for this triggered alarm  
    - `triggeredDate` : The date this alarm was triggered  
    - `acknowledgedDate` : The date this triggered alarm was acknowledged  
    - `acknowledgedUsername` : The user that acknowledged this triggered alarm  
    - `alarmName` : The name of the alarm that was triggered  
    - `events` : The events that triggered the alarm    
    - And others... see `msiempy.alarm.Alarm.ALARM_FIELDS_MAP`  
    
    Arguments:

    - `adict`: Alarm parameters  
    - `id`: The alarm ID to instanciate. Will load informations
    &#34;&#34;&#34;

    def __init__(self, *arg, **kwargs):
        &#34;&#34;&#34;Creates a empty Alarm.
        &#34;&#34;&#34;
        super().__init__(*arg, **kwargs)

        #Keep the id in the dict when instanciating an Alarm directly from its id.
        if &#39;id&#39; in kwargs :
            self.data[&#39;id&#39;] = {&#39;value&#39;:str(kwargs[&#39;id&#39;])}

    POSSIBLE_ALARM_STATUS=[
        [&#39;acknowledged&#39;, &#39;ack&#39;,],
        [&#39;unacknowledged&#39;, &#39;unack&#39;,],
        [&#39;&#39;, &#39;all&#39;, &#39;both&#39;]
    ]
    __pdoc__[&#39;Alarm.POSSIBLE_ALARM_STATUS&#39;]=&#34;&#34;&#34;Possible alarm statuses : ```%(statuses)s```&#34;&#34;&#34; % dict(statuses=&#39;, &#39;.join([ &#39;/&#39;.join(synonims) for synonims in POSSIBLE_ALARM_STATUS]))

    ALARM_EVENT_FILTER_FIELDS=[
    (&#34;ruleName&#34;,),
    (&#34;srcIp&#34;,),
    (&#34;destIp&#34;,),
    (&#34;protocol&#34;,),
    (&#34;lastTime&#34;,),
    (&#34;subtype&#34;,),
    (&#34;destPort&#34;,),
    (&#34;destMac&#34;,),
    (&#34;srcMac&#34;,),
    (&#34;srcPort&#34;,),
    (&#34;deviceName&#34;,),
    (&#34;sigId&#34;,),
    (&#34;normId&#34;,),
    (&#34;srcUser&#34;,),
    (&#34;destUser&#34;,),
    (&#34;normMessage&#34;,),
    (&#34;normDesc&#34;,),
    (&#34;host&#34;,),
    (&#34;domain&#34;,),
    (&#34;ipsId&#34;,),
    ]
    __pdoc__[&#39;Alarm.ALARM_EVENT_FILTER_FIELDS&#39;]=&#34;&#34;&#34;Static event related fields usable in a filter. Usable in `filters` parameter : ```%(fields)s```&#34;&#34;&#34; % dict(fields=&#39;, &#39;.join([ &#39;/&#39;.join(synonims) for synonims in ALARM_EVENT_FILTER_FIELDS]))

    ALARM_DEFAULT_FIELDS=[&#39;id&#39;,&#39;alarmName&#39;, &#39;summary&#39;,&#39;triggeredDate&#39;, &#39;acknowledgedUsername&#39;]
    __pdoc__[&#39;Alarm.ALARM_DEFAULT_FIELDS&#39;]=&#34;&#34;&#34;Defaulfs fields : `%(fields)s` 
    (not used in library, can bu useful for printing with `get_text(fields=msiempy.alarm.ALARM_DEFAULT_FIELDS)`)&#34;&#34;&#34; % dict(fields=&#39;, &#39;.join(ALARM_DEFAULT_FIELDS))


    def acknowledge(self):
        &#34;&#34;&#34;Mark the alarm as acknowledged.
        &#34;&#34;&#34;
        if self.nitro.api_v == 1:
            self.nitro.request(&#39;ack_alarms&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])
        else:
            self.nitro.request(&#39;ack_alarms_11_2_1&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])

    def unacknowledge(self):
        &#34;&#34;&#34;Mark the alarm as unacknowledge.
        &#34;&#34;&#34;
        if self.nitro.api_v == 1:
            self.nitro.request(&#39;unack_alarms&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])
        else:
            self.nitro.request(&#39;unack_alarms_11_2_1&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])


    def delete(self):
        &#34;&#34;&#34;Destructive action!
        Delete the alarm.
        &#34;&#34;&#34;
        if self.nitro.api_v == 1:
            self.nitro.request(&#39;delete_alarms&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])
        else:
            self.nitro.request(&#39;delete_alarms_11_2_1&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])

    def ceate_case(self):
        &#34;&#34;&#34;Not implemented : TODO
        &#34;&#34;&#34;
        raise NotImplementedError()

    def load_details(self):
        &#34;&#34;&#34;Update the alarm with detailled data loaded from the SIEM.
        &#34;&#34;&#34;
        the_id = self.data[&#39;id&#39;][&#39;value&#39;]
        self.data.update(self.data_from_id(the_id))
        self.data[&#39;id&#39;][&#39;value&#39;]=the_id

        return self

    def refresh(self):
        &#34;&#34;&#34;Update the alarm with detailled data loaded from the SIEM.  
        &#34;&#34;&#34;        
        self.load_details()

    def load_events(self, use_query=False, extra_fields=[]):
        &#34;&#34;&#34;
        Retreive the genuine Event object from an Alarm.
        Warning : This method will load the details of the first triggering event only.  

        Arguments:  

        - `use_query` : Uses the query module to retreive common event data. Only works with SIEM v 11.2 or greater.    
        Default behaviour will call `ipsGetAlertData` to retreive the complete event definition.  
        - `extra_fields` : Only when `use_query=True`. Additionnal event fields to load in the query. See : `msiempy.event.EventManager`  
        &#34;&#34;&#34;
        if isinstance(self.data[&#39;events&#39;], str):

            #Retreive the alert id from the event&#39;s string
            events_data=self.data[&#39;events&#39;].split(&#39;|&#39;)
            the_id = events_data[0]+&#39;|&#39;+events_data[1]

            #instanciate the event
            the_first_event=Event()
            the_first_event.data = Event().data_from_id(id=the_id, use_query=use_query, extra_fields=extra_fields)

            #set it as the only item of the event list
            self.data[&#39;events&#39;]= [ the_first_event ]

        else:
            log.info(&#39;The alarm {} ({}) has no events associated&#39;.format(self.data[&#39;alarmName&#39;], self.data[&#39;triggeredDate&#39;]))
            self.data[&#39;events&#39;]= [ Event() ]

        return self

    ALARM_FIELDS_MAP={&#39;EC&#39;: None,
                &#39;SMRY&#39;: &#39;summary&#39;,
                &#39;NAME&#39;: &#39;alarmName&#39;,
                &#39;FILTERS&#39;: &#39;filters&#39;,
                &#39;CTYPE&#39;: None,
                &#39;QID&#39;: &#39;queryId&#39;,
                &#39;ARM&#39;: &#39;alretRateMin&#39;,
                &#39;ARC&#39;: &#39;alertRateCount&#39;,
                &#39;PCTA&#39;: &#39;percentAbove&#39;,
                &#39;PCTB&#39;: &#39;percentBelow&#39;,
                &#39;OFFSETMIN&#39;: &#39;offsetMinutes&#39;,
                &#39;TIMEF&#39;: &#39;maximumConditionTriggerFrequency&#39;,
                &#39;XMIN&#39;: None,
                &#39;USEW&#39;: &#39;useWatchlist&#39;,
                &#39;MFLD&#39;: &#39;matchField&#39;,
                &#39;MVAL&#39;: &#39;matchValue&#39;,
                &#39;SVRTY&#39;: &#39;severity&#39;,
                &#39;ASNID&#39;: &#39;assigneeId&#39;,
                &#39;ASNNAME&#39;: &#39;assignee&#39;,
                &#39;TRGDATE&#39;: &#39;triggeredDate&#39;,
                &#39;ACKDATE&#39;: &#39;acknowledgedDate&#39;,
                &#39;ESCDATE&#39;: &#39;escalatedDate&#39;,
                &#39;CASEID&#39;: &#39;caseId&#39;,
                &#39;CASENAME&#39;: &#39;caseName&#39;,
                &#39;IOCNAME&#39;: &#39;iocName&#39;,
                &#39;IOCID&#39;: &#39;iocId&#39;,
                &#39;DESC&#39;: &#39;description&#39;,
                &#39;NID&#39;: None,
                &#39;ACTIONS&#39;: &#39;actions&#39;,
                &#39;NE&#39;: None,
                &#39;EVENTS&#39;: &#39;events&#39;,
                &#39;DCHNG&#39;: None}
    &#34;&#34;&#34;
    List of all `Alarm` possible fields.  
    This mapping is used to create new alarms and change genuine (UPPERCASE) key names to explicit ones.  
    If the value is None, the original key name is kept, otherwise the UPPERCASE key won&#39;t work. 
    ```
    {&#39;EC&#39;: None,
    &#39;SMRY&#39;: &#39;summary&#39;,
    &#39;NAME&#39;: &#39;alarmName&#39;,
    &#39;FILTERS&#39;: &#39;filters&#39;,
    &#39;CTYPE&#39;: None,
    &#39;QID&#39;: &#39;queryId&#39;,
    &#39;ARM&#39;: &#39;alretRateMin&#39;,
    &#39;ARC&#39;: &#39;alertRateCount&#39;,
    &#39;PCTA&#39;: &#39;percentAbove&#39;,
    &#39;PCTB&#39;: &#39;percentBelow&#39;,
    &#39;OFFSETMIN&#39;: &#39;offsetMinutes&#39;,
    &#39;TIMEF&#39;: &#39;maximumConditionTriggerFrequency&#39;,
    &#39;XMIN&#39;: None,
    &#39;USEW&#39;: &#39;useWatchlist&#39;,
    &#39;MFLD&#39;: &#39;matchField&#39;,
    &#39;MVAL&#39;: &#39;matchValue&#39;,
    &#39;SVRTY&#39;: &#39;severity&#39;,
    &#39;ASNID&#39;: &#39;assigneeId&#39;,
    &#39;ASNNAME&#39;: &#39;assignee&#39;,
    &#39;TRGDATE&#39;: &#39;triggeredDate&#39;,
    &#39;ACKDATE&#39;: &#39;acknowledgedDate&#39;,
    &#39;ESCDATE&#39;: &#39;escalatedDate&#39;,
    &#39;CASEID&#39;: &#39;caseId&#39;,
    &#39;CASENAME&#39;: &#39;caseName&#39;,
    &#39;IOCNAME&#39;: &#39;iocName&#39;,
    &#39;IOCID&#39;: &#39;iocId&#39;,
    &#39;DESC&#39;: &#39;description&#39;,
    &#39;NID&#39;: None,
    &#39;ACTIONS&#39;: &#39;actions&#39;,
    &#39;NE&#39;: None,
    &#39;EVENTS&#39;: &#39;events&#39;,
    &#39;DCHNG&#39;: None}
    ```
    &#34;&#34;&#34; 

    def map_alarm_int_fields(self, alarm_details):
        &#34;&#34;&#34;
        Map the internal ESM field names to msiempy style with `msiempy.alarm.Alarm.ALARM_FIELDS_MAP`.  
        Converts &#34;T&#34; and &#34;F&#34; to `True` and `False` and handle None values.  
        &#34;&#34;&#34;

        for key, val in alarm_details.items():
            if alarm_details[key] == key:
                alarm_details[key] = None
            elif alarm_details[key] in [&#39;f&#39;, &#39;F&#39;]:
                alarm_details[key] = False
            elif alarm_details[key] in [&#39;t&#39;, &#39;T&#39;]:
                alarm_details[key] = True
            else:
                alarm_details[key] = val

        new_alarm = {}

        for priv_key in self.ALARM_FIELDS_MAP: new_alarm.__setitem__(
            self.ALARM_FIELDS_MAP[priv_key] or priv_key, alarm_details.get(priv_key) or None )

        log.debug(&#39;NEW FULL alarm_details: &#39;+str(new_alarm))

        return new_alarm
                                                                                       
    def data_from_id(self, id):
        &#34;&#34;&#34;
        Gets the alarm parameters based on an ID
        &#34;&#34;&#34;
        alarms = self.nitro.request(&#39;get_alarm_details_int&#39;, id=str(id))
        # Wrap arround private api call
        alarms = {key: dehexify(val).replace(&#39;\n&#39;, &#39;|&#39;) for key, val in alarms.items()} 
        alarms = self.map_alarm_int_fields(alarms)        
        return alarms</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="msiempy.alarm.AlarmManager"><code class="flex name class">
<span>class <span class="ident">AlarmManager</span></span>
<span>(</span><span>*args, status_filter='all', page_size=200, filters=None, event_filters=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Interface to query and manage Alarms.<br>
Inherits from <code><a title="msiempy.core.query.FilteredQueryList" href="core/query.html#msiempy.core.query.FilteredQueryList">FilteredQueryList</a></code>.</p>
<p>Arguments:
</p>
<ul>
<li><code>status_filter</code> : status of the alarms to query. <code>status_filter</code> is not a filter like other cause it's computed on the SIEM side.<br>
Accepted values : <code>acknowledged</code>, <code>unacknowledged</code>, <code>all</code>, <code> or <code>None</code> (default is </code>).
<code>filters</code> are computed locally - Unlike <code><a title="msiempy.event.EventManager" href="event.html#msiempy.event.EventManager">EventManager</a></code> filters.
</li>
<li><code>page_size</code> : max number of rows per query.
</li>
<li><code>page_number</code> : defaulted to 1.</li>
<li><code>filters</code> : <code>[(field, [values]), (field, [values])]</code> Filters applied to <code><a title="msiempy.alarm.Alarm" href="#msiempy.alarm.Alarm">Alarm</a></code> objects. A single <code>tuple</code> is also accepted. </li>
<li><code>event_filters</code> : <code>[(field, [values]), (field, [values])]</code> Filters applied to <code><a title="msiempy.event.Event" href="event.html#msiempy.event.Event">Event</a></code> objects. A single <code>tuple</code> is also accepted.
</li>
<li><code>time_range</code> : Query time range. String representation of a time range.
</li>
<li><code>start_time</code> : Query starting time, can be a <code>string</code> or a <code>datetime</code> object. Parsed with <code>dateutil</code>.
</li>
<li><code>end_time</code> : Query endding time, can be a <code>string</code> or a <code>datetime</code> object. Parsed with <code>dateutil</code>.
</li>
</ul>
<p><strong>Unlike <code>EventManager</code>, filters are computed after the data loaded with regex matching.</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AlarmManager(FilteredQueryList):
    &#34;&#34;&#34;
    Interface to query and manage Alarms.  
    Inherits from `msiempy.core.query.FilteredQueryList`.

    Arguments:  

    - `status_filter` : status of the alarms to query. `status_filter` is not a filter like other cause it&#39;s computed on the SIEM side.  
    Accepted values : `acknowledged`, `unacknowledged`, `all`, `` or `None` (default is ``).
    `filters` are computed locally - Unlike `msiempy.event.EventManager` filters.  
    - `page_size` : max number of rows per query.  
    - `page_number` : defaulted to 1.
    - `filters` : `[(field, [values]), (field, [values])]` Filters applied to `msiempy.alarm.Alarm` objects. A single `tuple` is also accepted. 
    - `event_filters` : `[(field, [values]), (field, [values])]` Filters applied to `msiempy.event.Event` objects. A single `tuple` is also accepted.  
    - `time_range` : Query time range. String representation of a time range.  
    - `start_time` : Query starting time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  
    - `end_time` : Query endding time, can be a `string` or a `datetime` object. Parsed with `dateutil`.  

    **Unlike `EventManager`, filters are computed after the data loaded with regex matching.**  
    
    &#34;&#34;&#34;
    def __init__(self, *args, status_filter=&#39;all&#39;, page_size=200, filters=None, event_filters=None, **kwargs):
        super().__init__(*args, **kwargs)

        #Declaring attributes
        self._alarm_filters = list(tuple())
        self._event_filters = list(tuple())
        self._status_filter = str()

        #Setting attributes
        self.status_filter=status_filter
        self.page_size=page_size

        #uses the parent filter setter
        #TODO : find a soltuion not to use this
        #calling super().filters=filters #https://bugs.python.org/issue14965
        super(self.__class__, self.__class__).filters.__set__(self, filters)

        #Seeting events filters after alarms filters cause it would overwrite it
        self.event_filters=event_filters

        #Casting all data to Alarms objects, better way to do it ?
        collections.UserList.__init__(self, [Alarm(adict=item) for item in self.data if isinstance(item, (dict, NitroDict))])

    @property
    def filters(self):
        &#34;&#34;&#34;
        The alarm related filters
        &#34;&#34;&#34;
        return self._alarm_filters
    
    @property
    def status_filter(self):
        &#34;&#34;&#34;
        Status of the alarms in the query.  
        &#34;&#34;&#34;
        return self._status_filter

    @status_filter.setter
    def status_filter(self, status_filter):
        status_found=False
        if type(status_filter) is str : 
            for synonims in Alarm.POSSIBLE_ALARM_STATUS :
                if status_filter in synonims:
                    self._status_filter=synonims[0]
                    status_found=True

        if not status_found:
            raise AttributeError(&#34;Illegal value of status filter. The status must be in &#34;+str(Alarm.POSSIBLE_ALARM_STATUS)+&#39; not :&#39;+str(status_filter))

    def add_filter(self, afilter):
        &#34;&#34;&#34;
        Add a filter to the query.  
        
        Arguments :  

        - `afilter` : Can be a a tuple `(field, [values])` or `(field, value)` or `str` &#39;field=value&#39;

        Filters format is `tuple(field, [values])`.  
        &#34;&#34;&#34;

        if isinstance(afilter,str): afilter = afilter.split(&#39;=&#39;,1)
        
        values = afilter[1] if isinstance(afilter[1], list) else [afilter[1]]
        values = [str(v) for v in values]
        added=False

        for synonims in Alarm.ALARM_EVENT_FILTER_FIELDS :
            if afilter[0] in synonims :
                log.warning(&#39;Passing event related filters in `filters` argument is not safe consider using `event_filters` argument. You\&#39;ll be able to use more filters dynamically.&#39;)
                self._event_filters.append((synonims[0], values))
                added=True

        #support query related filtering if the filter&#39;s field is composed by a table name then a field name separated by a dot.
        if len(afilter[0].split(&#39;.&#39;)) == 2 :
            self._event_filters.append((afilter[0], values))
            log.warning(&#39;Passing event related filters in `filters` argument is not safe, consider using `event_filters` argument. You\&#39;ll be able to use more filters dynamically.&#39;)
            added=True

        if added==False:
            self._alarm_filters.append((afilter[0], values))
            added=True

    @property
    def event_filters(self):
        &#34;&#34;&#34;Event related filters.&#34;&#34;&#34;
        return self._event_filters

    @event_filters.setter
    def event_filters(self, filters):
        if isinstance(filters, list):
            for f in filters :
                self.add_event_filter(f)

        elif isinstance(filters, tuple):
            self.add_event_filter(filters)

        elif filters == None :
            self._event_filters=list(tuple())
        
        else :
            raise AttributeError(&#34;Illegal type for the filter object, it must be a list, a tuple or None.&#34;)

    def add_event_filter(self, afilter):
        &#34;&#34;&#34;
        Add a event filter to the query.  
        
        Arguments :  

        - `afilter` : Can be a a tuple `(field, [values])` or `(field, value)` or `str` &#39;field=value&#39;

        Filters format is `tuple(field, [values])`.  
        &#34;&#34;&#34;

        if isinstance(afilter,str):
            afilter = afilter.split(&#39;=&#39;,1)
       
        values = afilter[1] if isinstance(afilter[1], list) else [afilter[1]]
        values = [str(v) for v in values] 
        self._event_filters.append((afilter[0], values))

    def clear_filters(self):
        &#34;&#34;&#34;
        Reset local alarm and event filters.
        &#34;&#34;&#34;
        self._alarm_filters = list(tuple())
        self._event_filters = list(tuple())

    def load_data(self, pages=1, **kwargs):
        &#34;&#34;&#34;
        Load the data into the list.  
        Implements automatic paging over `msiempy.alarm.AlarmManager.qry_load_data`.  
        Default behaviour is to load all alarms informations. Meaning that foreach alarms, 
        the full details is loaded, then the trigerring event details is loaded.  
        
        Arguments :  

        - `pages` : Number of pages to load (not asynchronous).   

        Arguments passed to `msiempy.alarm.AlarmManager.qry_load_data` :  

        - `workers` : Number of asynchronous workers   
        - `alarms_details` : Load detailed alarms infos. If `False`, only a couple values are loaded, no `events` infos.  
        - `events_details` : Load detailed events infos. If `False`, no detailed `events` will be loaded only `str` representation.  
        - `use_query` : Uses the query module to retreive event data. Only works with SIEM v11.2.1 or greater.  
        Default behaviour will call `ipsGetAlertData` to retreive the complete event definition.    
        - `extra_fields` :  Only when `use_query=True`. Additionnal event fields to load in the query. See : `msiempy.event.EventManager`  
        - `page_number` : Page number, default to 1. Do not touch if you&#39;re using `pages` parameter  

        Returns : `msiempy.alarm.AlarmManager`
        &#34;&#34;&#34;

        items, completed = self.qry_load_data(**kwargs)
        #Casting items to Alarms
        alarms=[Alarm(adict=item) for item in items]

        #Iterative automatic paging (not asynchronous)
        if not completed and pages&gt;1 :
            next_kwargs={**kwargs}
            if &#39;page_number&#39; in kwargs : next_kwargs[&#39;page_number&#39;]=kwargs[&#39;page_number&#39;]+1
            else: next_kwargs[&#39;page_number&#39;]=2

            log.info(&#39;Loading pages... ({})&#39;.format(next_kwargs[&#39;page_number&#39;]))
            alarms=alarms+list(self.load_data(pages=pages-1, **next_kwargs))

        if &#39;page_number&#39; not in kwargs:
            log.info(str(len(alarms)) + &#34; alarms are matching your filter(s)&#34;)

        
        self.data=alarms
        return(self)

    def qry_load_data(self, workers=10,
        alarms_details=True, events_details=True,
        use_query=False, extra_fields=[], page_number=1):
        &#34;&#34;&#34;
        Method that query, filter and return the alarms data :  
        -&gt; Fetch the list of alarms and load alarms details  
        -&gt; Filter depending on alarms related filters  
        -&gt; Load the events details  
        -&gt; Filter depending on event related filters  

        Arguments :  

        - `workers` : Number of asynchronous workers  
        - `alarms_details` : Load detailed alarms infos. If `False`, only a couple values are loaded, no `events` infos.
        - `events_details` : Load detailed events infos. If `False`, no detailed `events` will be loaded only `str` representation.
        - `use_query` : Uses the query module to retreive event data. Only works with SIEM v11.2.1 or greater.  
        - `extra_fields` :  Only when `use_query=True`. Additionnal event fields to load in the query. See : `msiempy.event.EventManager`  
        - `page_number` : Page number, default to 1. Do not touch if you&#39;re using `pages` parameter  
        
        Returns : `tuple` : ( Results : `list` , Status of the query : `completed` )

        &#34;&#34;&#34;

        if self.time_range == &#39;CUSTOM&#39; :
            no_filtered_alarms=self.nitro.request(
                &#39;get_alarms_custom_time&#39;,
                time_range=self.time_range,
                start_time=self.start_time,
                end_time=self.end_time,
                status=self.status_filter,
                page_size=self.page_size,
                page_number=page_number
                )

        else :
            no_filtered_alarms=self.nitro.request(
                &#39;get_alarms&#39;,
                time_range=self.time_range,
                status=self.status_filter,
                page_size=self.page_size,
                page_number=page_number
                )

        #Casting to list of Alarms to be able to call load_details etc...        
        alarm_based_filtered = [Alarm(adict=a) for a in no_filtered_alarms if self._alarm_match(a)]

        if alarms_details :

            log.info(&#34;Getting alarms infos...&#34;)
            alarm_detailed = self.perform(Alarm.load_details,
                list(alarm_based_filtered),
                asynch=True,
                progress=True,
                workers=workers)

            #Casting to list of Alarms to be able to call load_details etc...        
            detailed_alarm_based_filtered = [Alarm(adict=a) for a in alarm_detailed if self._alarm_match(a)]

            if events_details :
                log.info(&#34;Getting events infos...&#34;)
                event_detailed = self.perform(Alarm.load_events, 
                    list(alarm_detailed),
                    func_args=dict(use_query=use_query, extra_fields=extra_fields),
                    asynch=True, 
                    progress=True, 
                    workers=workers)

                filtered_alarms = [a for a in event_detailed if self._event_match(a)]
            else:
                log.warning(&#39;Field based Event filters are ignored when `events_details is False`. You can use `events` keyword in alarms filters to match str representation.&#39;)
                filtered_alarms=detailed_alarm_based_filtered
        else :
            filtered_alarms = alarm_based_filtered
            log.warning(&#39;Event filters and some Alarm filters are ignored when `alarms_details is False`&#39;)

        return (( filtered_alarms , len(no_filtered_alarms) &lt; int(self.page_size) ))

    def _alarm_match(self, alarm):
        &#34;&#34;&#34;
        Internal filter method that is going to return True if the passed alarm match any alarm related filters.
        &#34;&#34;&#34;
        match=True
        for alarm_filter in self._alarm_filters :
            match=False
            try: value = str(alarm[alarm_filter[0]]) #Can only match strings
            except KeyError: break
            for filter_value in alarm_filter[1]:
                if regex_match(filter_value.lower(), value.lower()):
                    match=True
                    break
            if not match :
                break
        return match
        
    def _event_match(self, alarm):
        &#34;&#34;&#34;
        Internal filter method that is going to return True if the passed alarm match any event related filters.
        &#34;&#34;&#34;
        match=True
        for event_filter in self._event_filters :
            match=False
            try: value = str(alarm[&#39;events&#39;][0][event_filter[0]])
            except KeyError: break
            for filter_value in event_filter[1]:
                if regex_match(filter_value.lower(), value.lower()) :
                    match=True
                    break
            if not match :
                break
        return match</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="msiempy.core.query.FilteredQueryList" href="core/query.html#msiempy.core.query.FilteredQueryList">FilteredQueryList</a></li>
<li><a title="msiempy.core.types.NitroList" href="core/types.html#msiempy.core.types.NitroList">NitroList</a></li>
<li>collections.UserList</li>
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="msiempy.core.types.NitroObject" href="core/types.html#msiempy.core.types.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.alarm.AlarmManager.filters"><code class="name">var <span class="ident">filters</span></code></dt>
<dd>
<div class="desc"><p>The alarm related filters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def filters(self):
    &#34;&#34;&#34;
    The alarm related filters
    &#34;&#34;&#34;
    return self._alarm_filters</code></pre>
</details>
</dd>
<dt id="msiempy.alarm.AlarmManager.status_filter"><code class="name">var <span class="ident">status_filter</span></code></dt>
<dd>
<div class="desc"><p>Alarms status filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def status_filter(self):
    &#34;&#34;&#34;
    Status of the alarms in the query.  
    &#34;&#34;&#34;
    return self._status_filter</code></pre>
</details>
</dd>
<dt id="msiempy.alarm.AlarmManager.event_filters"><code class="name">var <span class="ident">event_filters</span></code></dt>
<dd>
<div class="desc"><p>Event related filters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def event_filters(self):
    &#34;&#34;&#34;Event related filters.&#34;&#34;&#34;
    return self._event_filters</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.alarm.AlarmManager.add_filter"><code class="name flex">
<span>def <span class="ident">add_filter</span></span>(<span>self, afilter)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a filter to the query.
</p>
<p>Arguments :
</p>
<ul>
<li><code>afilter</code> : Can be a a tuple <code>(field, [values])</code> or <code>(field, value)</code> or <code>str</code> 'field=value'</li>
</ul>
<p>Filters format is <code>tuple(field, [values])</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_filter(self, afilter):
    &#34;&#34;&#34;
    Add a filter to the query.  
    
    Arguments :  

    - `afilter` : Can be a a tuple `(field, [values])` or `(field, value)` or `str` &#39;field=value&#39;

    Filters format is `tuple(field, [values])`.  
    &#34;&#34;&#34;

    if isinstance(afilter,str): afilter = afilter.split(&#39;=&#39;,1)
    
    values = afilter[1] if isinstance(afilter[1], list) else [afilter[1]]
    values = [str(v) for v in values]
    added=False

    for synonims in Alarm.ALARM_EVENT_FILTER_FIELDS :
        if afilter[0] in synonims :
            log.warning(&#39;Passing event related filters in `filters` argument is not safe consider using `event_filters` argument. You\&#39;ll be able to use more filters dynamically.&#39;)
            self._event_filters.append((synonims[0], values))
            added=True

    #support query related filtering if the filter&#39;s field is composed by a table name then a field name separated by a dot.
    if len(afilter[0].split(&#39;.&#39;)) == 2 :
        self._event_filters.append((afilter[0], values))
        log.warning(&#39;Passing event related filters in `filters` argument is not safe, consider using `event_filters` argument. You\&#39;ll be able to use more filters dynamically.&#39;)
        added=True

    if added==False:
        self._alarm_filters.append((afilter[0], values))
        added=True</code></pre>
</details>
</dd>
<dt id="msiempy.alarm.AlarmManager.add_event_filter"><code class="name flex">
<span>def <span class="ident">add_event_filter</span></span>(<span>self, afilter)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a event filter to the query.
</p>
<p>Arguments :
</p>
<ul>
<li><code>afilter</code> : Can be a a tuple <code>(field, [values])</code> or <code>(field, value)</code> or <code>str</code> 'field=value'</li>
</ul>
<p>Filters format is <code>tuple(field, [values])</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_event_filter(self, afilter):
    &#34;&#34;&#34;
    Add a event filter to the query.  
    
    Arguments :  

    - `afilter` : Can be a a tuple `(field, [values])` or `(field, value)` or `str` &#39;field=value&#39;

    Filters format is `tuple(field, [values])`.  
    &#34;&#34;&#34;

    if isinstance(afilter,str):
        afilter = afilter.split(&#39;=&#39;,1)
   
    values = afilter[1] if isinstance(afilter[1], list) else [afilter[1]]
    values = [str(v) for v in values] 
    self._event_filters.append((afilter[0], values))</code></pre>
</details>
</dd>
<dt id="msiempy.alarm.AlarmManager.clear_filters"><code class="name flex">
<span>def <span class="ident">clear_filters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset local alarm and event filters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_filters(self):
    &#34;&#34;&#34;
    Reset local alarm and event filters.
    &#34;&#34;&#34;
    self._alarm_filters = list(tuple())
    self._event_filters = list(tuple())</code></pre>
</details>
</dd>
<dt id="msiempy.alarm.AlarmManager.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self, pages=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the data into the list.<br>
Implements automatic paging over <code><a title="msiempy.alarm.AlarmManager.qry_load_data" href="#msiempy.alarm.AlarmManager.qry_load_data">AlarmManager.qry_load_data()</a></code>.<br>
Default behaviour is to load all alarms informations. Meaning that foreach alarms,
the full details is loaded, then the trigerring event details is loaded.
</p>
<p>Arguments :
</p>
<ul>
<li><code>pages</code> : Number of pages to load (not asynchronous).
</li>
</ul>
<p>Arguments passed to <code><a title="msiempy.alarm.AlarmManager.qry_load_data" href="#msiempy.alarm.AlarmManager.qry_load_data">AlarmManager.qry_load_data()</a></code> :
</p>
<ul>
<li><code>workers</code> : Number of asynchronous workers
</li>
<li><code>alarms_details</code> : Load detailed alarms infos. If <code>False</code>, only a couple values are loaded, no <code>events</code> infos.
</li>
<li><code>events_details</code> : Load detailed events infos. If <code>False</code>, no detailed <code>events</code> will be loaded only <code>str</code> representation.
</li>
<li><code>use_query</code> : Uses the query module to retreive event data. Only works with SIEM v11.2.1 or greater.<br>
Default behaviour will call <code>ipsGetAlertData</code> to retreive the complete event definition.
</li>
<li><code>extra_fields</code> :
Only when <code>use_query=True</code>. Additionnal event fields to load in the query. See : <code><a title="msiempy.event.EventManager" href="event.html#msiempy.event.EventManager">EventManager</a></code>
</li>
<li><code>page_number</code> : Page number, default to 1. Do not touch if you're using <code>pages</code> parameter
</li>
</ul>
<p>Returns : <code><a title="msiempy.alarm.AlarmManager" href="#msiempy.alarm.AlarmManager">AlarmManager</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_data(self, pages=1, **kwargs):
    &#34;&#34;&#34;
    Load the data into the list.  
    Implements automatic paging over `msiempy.alarm.AlarmManager.qry_load_data`.  
    Default behaviour is to load all alarms informations. Meaning that foreach alarms, 
    the full details is loaded, then the trigerring event details is loaded.  
    
    Arguments :  

    - `pages` : Number of pages to load (not asynchronous).   

    Arguments passed to `msiempy.alarm.AlarmManager.qry_load_data` :  

    - `workers` : Number of asynchronous workers   
    - `alarms_details` : Load detailed alarms infos. If `False`, only a couple values are loaded, no `events` infos.  
    - `events_details` : Load detailed events infos. If `False`, no detailed `events` will be loaded only `str` representation.  
    - `use_query` : Uses the query module to retreive event data. Only works with SIEM v11.2.1 or greater.  
    Default behaviour will call `ipsGetAlertData` to retreive the complete event definition.    
    - `extra_fields` :  Only when `use_query=True`. Additionnal event fields to load in the query. See : `msiempy.event.EventManager`  
    - `page_number` : Page number, default to 1. Do not touch if you&#39;re using `pages` parameter  

    Returns : `msiempy.alarm.AlarmManager`
    &#34;&#34;&#34;

    items, completed = self.qry_load_data(**kwargs)
    #Casting items to Alarms
    alarms=[Alarm(adict=item) for item in items]

    #Iterative automatic paging (not asynchronous)
    if not completed and pages&gt;1 :
        next_kwargs={**kwargs}
        if &#39;page_number&#39; in kwargs : next_kwargs[&#39;page_number&#39;]=kwargs[&#39;page_number&#39;]+1
        else: next_kwargs[&#39;page_number&#39;]=2

        log.info(&#39;Loading pages... ({})&#39;.format(next_kwargs[&#39;page_number&#39;]))
        alarms=alarms+list(self.load_data(pages=pages-1, **next_kwargs))

    if &#39;page_number&#39; not in kwargs:
        log.info(str(len(alarms)) + &#34; alarms are matching your filter(s)&#34;)

    
    self.data=alarms
    return(self)</code></pre>
</details>
</dd>
<dt id="msiempy.alarm.AlarmManager.qry_load_data"><code class="name flex">
<span>def <span class="ident">qry_load_data</span></span>(<span>self, workers=10, alarms_details=True, events_details=True, use_query=False, extra_fields=[], page_number=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that query, filter and return the alarms data :<br>
-&gt; Fetch the list of alarms and load alarms details<br>
-&gt; Filter depending on alarms related filters<br>
-&gt; Load the events details<br>
-&gt; Filter depending on event related filters
</p>
<p>Arguments :
</p>
<ul>
<li><code>workers</code> : Number of asynchronous workers
</li>
<li><code>alarms_details</code> : Load detailed alarms infos. If <code>False</code>, only a couple values are loaded, no <code>events</code> infos.</li>
<li><code>events_details</code> : Load detailed events infos. If <code>False</code>, no detailed <code>events</code> will be loaded only <code>str</code> representation.</li>
<li><code>use_query</code> : Uses the query module to retreive event data. Only works with SIEM v11.2.1 or greater.
</li>
<li><code>extra_fields</code> :
Only when <code>use_query=True</code>. Additionnal event fields to load in the query. See : <code><a title="msiempy.event.EventManager" href="event.html#msiempy.event.EventManager">EventManager</a></code>
</li>
<li><code>page_number</code> : Page number, default to 1. Do not touch if you're using <code>pages</code> parameter
</li>
</ul>
<p>Returns : <code>tuple</code> : ( Results : <code>list</code> , Status of the query : <code>completed</code> )</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def qry_load_data(self, workers=10,
    alarms_details=True, events_details=True,
    use_query=False, extra_fields=[], page_number=1):
    &#34;&#34;&#34;
    Method that query, filter and return the alarms data :  
    -&gt; Fetch the list of alarms and load alarms details  
    -&gt; Filter depending on alarms related filters  
    -&gt; Load the events details  
    -&gt; Filter depending on event related filters  

    Arguments :  

    - `workers` : Number of asynchronous workers  
    - `alarms_details` : Load detailed alarms infos. If `False`, only a couple values are loaded, no `events` infos.
    - `events_details` : Load detailed events infos. If `False`, no detailed `events` will be loaded only `str` representation.
    - `use_query` : Uses the query module to retreive event data. Only works with SIEM v11.2.1 or greater.  
    - `extra_fields` :  Only when `use_query=True`. Additionnal event fields to load in the query. See : `msiempy.event.EventManager`  
    - `page_number` : Page number, default to 1. Do not touch if you&#39;re using `pages` parameter  
    
    Returns : `tuple` : ( Results : `list` , Status of the query : `completed` )

    &#34;&#34;&#34;

    if self.time_range == &#39;CUSTOM&#39; :
        no_filtered_alarms=self.nitro.request(
            &#39;get_alarms_custom_time&#39;,
            time_range=self.time_range,
            start_time=self.start_time,
            end_time=self.end_time,
            status=self.status_filter,
            page_size=self.page_size,
            page_number=page_number
            )

    else :
        no_filtered_alarms=self.nitro.request(
            &#39;get_alarms&#39;,
            time_range=self.time_range,
            status=self.status_filter,
            page_size=self.page_size,
            page_number=page_number
            )

    #Casting to list of Alarms to be able to call load_details etc...        
    alarm_based_filtered = [Alarm(adict=a) for a in no_filtered_alarms if self._alarm_match(a)]

    if alarms_details :

        log.info(&#34;Getting alarms infos...&#34;)
        alarm_detailed = self.perform(Alarm.load_details,
            list(alarm_based_filtered),
            asynch=True,
            progress=True,
            workers=workers)

        #Casting to list of Alarms to be able to call load_details etc...        
        detailed_alarm_based_filtered = [Alarm(adict=a) for a in alarm_detailed if self._alarm_match(a)]

        if events_details :
            log.info(&#34;Getting events infos...&#34;)
            event_detailed = self.perform(Alarm.load_events, 
                list(alarm_detailed),
                func_args=dict(use_query=use_query, extra_fields=extra_fields),
                asynch=True, 
                progress=True, 
                workers=workers)

            filtered_alarms = [a for a in event_detailed if self._event_match(a)]
        else:
            log.warning(&#39;Field based Event filters are ignored when `events_details is False`. You can use `events` keyword in alarms filters to match str representation.&#39;)
            filtered_alarms=detailed_alarm_based_filtered
    else :
        filtered_alarms = alarm_based_filtered
        log.warning(&#39;Event filters and some Alarm filters are ignored when `alarms_details is False`&#39;)

    return (( filtered_alarms , len(no_filtered_alarms) &lt; int(self.page_size) ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.core.query.FilteredQueryList" href="core/query.html#msiempy.core.query.FilteredQueryList">FilteredQueryList</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.core.query.FilteredQueryList.NitroJSONEncoder" href="core/types.html#msiempy.core.types.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.end_time" href="core/query.html#msiempy.core.query.FilteredQueryList.end_time">end_time</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.get_text" href="core/types.html#msiempy.core.types.NitroList.get_text">get_text</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.json" href="core/types.html#msiempy.core.types.NitroList.json">json</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.keys" href="core/types.html#msiempy.core.types.NitroList.keys">keys</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.nitro" href="core/types.html#msiempy.core.types.NitroObject.nitro">nitro</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.perform" href="core/types.html#msiempy.core.types.NitroList.perform">perform</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.refresh" href="core/types.html#msiempy.core.types.NitroList.refresh">refresh</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.search" href="core/types.html#msiempy.core.types.NitroList.search">search</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.start_time" href="core/query.html#msiempy.core.query.FilteredQueryList.start_time">start_time</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.text" href="core/types.html#msiempy.core.types.NitroList.text">text</a></code></li>
<li><code><a title="msiempy.core.query.FilteredQueryList.time_range" href="core/query.html#msiempy.core.query.FilteredQueryList.time_range">time_range</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="msiempy.alarm.Alarm"><code class="flex name class">
<span>class <span class="ident">Alarm</span></span>
<span>(</span><span>*arg, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Dict-Like object.
</p>
<p>Common keys :
</p>
<ul>
<li><code>id</code> : The ID of the triggered alarm
</li>
<li><code>summary</code>
: The summary of the triggered alarm
</li>
<li><code>assignee</code> : The assignee for this triggered alarm
</li>
<li><code>severity</code> : The severity for this triggered alarm
</li>
<li><code>triggeredDate</code> : The date this alarm was triggered
</li>
<li><code>acknowledgedDate</code> : The date this triggered alarm was acknowledged
</li>
<li><code>acknowledgedUsername</code> : The user that acknowledged this triggered alarm
</li>
<li><code>alarmName</code> : The name of the alarm that was triggered
</li>
<li><code>events</code> : The events that triggered the alarm
</li>
<li>And others&hellip; see <code><a title="msiempy.alarm.Alarm.ALARM_FIELDS_MAP" href="#msiempy.alarm.Alarm.ALARM_FIELDS_MAP">Alarm.ALARM_FIELDS_MAP</a></code>
</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>adict</code>: Alarm parameters
</li>
<li><code>id</code>: The alarm ID to instanciate. Will load informations</li>
</ul>
<p>Creates a empty Alarm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Alarm(NitroDict):
    &#34;&#34;&#34;
    Dict-Like object.  

    Common keys :  

    - `id` : The ID of the triggered alarm  
    - `summary`  : The summary of the triggered alarm  
    - `assignee` : The assignee for this triggered alarm  
    - `severity` : The severity for this triggered alarm  
    - `triggeredDate` : The date this alarm was triggered  
    - `acknowledgedDate` : The date this triggered alarm was acknowledged  
    - `acknowledgedUsername` : The user that acknowledged this triggered alarm  
    - `alarmName` : The name of the alarm that was triggered  
    - `events` : The events that triggered the alarm    
    - And others... see `msiempy.alarm.Alarm.ALARM_FIELDS_MAP`  
    
    Arguments:

    - `adict`: Alarm parameters  
    - `id`: The alarm ID to instanciate. Will load informations
    &#34;&#34;&#34;

    def __init__(self, *arg, **kwargs):
        &#34;&#34;&#34;Creates a empty Alarm.
        &#34;&#34;&#34;
        super().__init__(*arg, **kwargs)

        #Keep the id in the dict when instanciating an Alarm directly from its id.
        if &#39;id&#39; in kwargs :
            self.data[&#39;id&#39;] = {&#39;value&#39;:str(kwargs[&#39;id&#39;])}

    POSSIBLE_ALARM_STATUS=[
        [&#39;acknowledged&#39;, &#39;ack&#39;,],
        [&#39;unacknowledged&#39;, &#39;unack&#39;,],
        [&#39;&#39;, &#39;all&#39;, &#39;both&#39;]
    ]
    __pdoc__[&#39;Alarm.POSSIBLE_ALARM_STATUS&#39;]=&#34;&#34;&#34;Possible alarm statuses : ```%(statuses)s```&#34;&#34;&#34; % dict(statuses=&#39;, &#39;.join([ &#39;/&#39;.join(synonims) for synonims in POSSIBLE_ALARM_STATUS]))

    ALARM_EVENT_FILTER_FIELDS=[
    (&#34;ruleName&#34;,),
    (&#34;srcIp&#34;,),
    (&#34;destIp&#34;,),
    (&#34;protocol&#34;,),
    (&#34;lastTime&#34;,),
    (&#34;subtype&#34;,),
    (&#34;destPort&#34;,),
    (&#34;destMac&#34;,),
    (&#34;srcMac&#34;,),
    (&#34;srcPort&#34;,),
    (&#34;deviceName&#34;,),
    (&#34;sigId&#34;,),
    (&#34;normId&#34;,),
    (&#34;srcUser&#34;,),
    (&#34;destUser&#34;,),
    (&#34;normMessage&#34;,),
    (&#34;normDesc&#34;,),
    (&#34;host&#34;,),
    (&#34;domain&#34;,),
    (&#34;ipsId&#34;,),
    ]
    __pdoc__[&#39;Alarm.ALARM_EVENT_FILTER_FIELDS&#39;]=&#34;&#34;&#34;Static event related fields usable in a filter. Usable in `filters` parameter : ```%(fields)s```&#34;&#34;&#34; % dict(fields=&#39;, &#39;.join([ &#39;/&#39;.join(synonims) for synonims in ALARM_EVENT_FILTER_FIELDS]))

    ALARM_DEFAULT_FIELDS=[&#39;id&#39;,&#39;alarmName&#39;, &#39;summary&#39;,&#39;triggeredDate&#39;, &#39;acknowledgedUsername&#39;]
    __pdoc__[&#39;Alarm.ALARM_DEFAULT_FIELDS&#39;]=&#34;&#34;&#34;Defaulfs fields : `%(fields)s` 
    (not used in library, can bu useful for printing with `get_text(fields=msiempy.alarm.ALARM_DEFAULT_FIELDS)`)&#34;&#34;&#34; % dict(fields=&#39;, &#39;.join(ALARM_DEFAULT_FIELDS))


    def acknowledge(self):
        &#34;&#34;&#34;Mark the alarm as acknowledged.
        &#34;&#34;&#34;
        if self.nitro.api_v == 1:
            self.nitro.request(&#39;ack_alarms&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])
        else:
            self.nitro.request(&#39;ack_alarms_11_2_1&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])

    def unacknowledge(self):
        &#34;&#34;&#34;Mark the alarm as unacknowledge.
        &#34;&#34;&#34;
        if self.nitro.api_v == 1:
            self.nitro.request(&#39;unack_alarms&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])
        else:
            self.nitro.request(&#39;unack_alarms_11_2_1&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])


    def delete(self):
        &#34;&#34;&#34;Destructive action!
        Delete the alarm.
        &#34;&#34;&#34;
        if self.nitro.api_v == 1:
            self.nitro.request(&#39;delete_alarms&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])
        else:
            self.nitro.request(&#39;delete_alarms_11_2_1&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])

    def ceate_case(self):
        &#34;&#34;&#34;Not implemented : TODO
        &#34;&#34;&#34;
        raise NotImplementedError()

    def load_details(self):
        &#34;&#34;&#34;Update the alarm with detailled data loaded from the SIEM.
        &#34;&#34;&#34;
        the_id = self.data[&#39;id&#39;][&#39;value&#39;]
        self.data.update(self.data_from_id(the_id))
        self.data[&#39;id&#39;][&#39;value&#39;]=the_id

        return self

    def refresh(self):
        &#34;&#34;&#34;Update the alarm with detailled data loaded from the SIEM.  
        &#34;&#34;&#34;        
        self.load_details()

    def load_events(self, use_query=False, extra_fields=[]):
        &#34;&#34;&#34;
        Retreive the genuine Event object from an Alarm.
        Warning : This method will load the details of the first triggering event only.  

        Arguments:  

        - `use_query` : Uses the query module to retreive common event data. Only works with SIEM v 11.2 or greater.    
        Default behaviour will call `ipsGetAlertData` to retreive the complete event definition.  
        - `extra_fields` : Only when `use_query=True`. Additionnal event fields to load in the query. See : `msiempy.event.EventManager`  
        &#34;&#34;&#34;
        if isinstance(self.data[&#39;events&#39;], str):

            #Retreive the alert id from the event&#39;s string
            events_data=self.data[&#39;events&#39;].split(&#39;|&#39;)
            the_id = events_data[0]+&#39;|&#39;+events_data[1]

            #instanciate the event
            the_first_event=Event()
            the_first_event.data = Event().data_from_id(id=the_id, use_query=use_query, extra_fields=extra_fields)

            #set it as the only item of the event list
            self.data[&#39;events&#39;]= [ the_first_event ]

        else:
            log.info(&#39;The alarm {} ({}) has no events associated&#39;.format(self.data[&#39;alarmName&#39;], self.data[&#39;triggeredDate&#39;]))
            self.data[&#39;events&#39;]= [ Event() ]

        return self

    ALARM_FIELDS_MAP={&#39;EC&#39;: None,
                &#39;SMRY&#39;: &#39;summary&#39;,
                &#39;NAME&#39;: &#39;alarmName&#39;,
                &#39;FILTERS&#39;: &#39;filters&#39;,
                &#39;CTYPE&#39;: None,
                &#39;QID&#39;: &#39;queryId&#39;,
                &#39;ARM&#39;: &#39;alretRateMin&#39;,
                &#39;ARC&#39;: &#39;alertRateCount&#39;,
                &#39;PCTA&#39;: &#39;percentAbove&#39;,
                &#39;PCTB&#39;: &#39;percentBelow&#39;,
                &#39;OFFSETMIN&#39;: &#39;offsetMinutes&#39;,
                &#39;TIMEF&#39;: &#39;maximumConditionTriggerFrequency&#39;,
                &#39;XMIN&#39;: None,
                &#39;USEW&#39;: &#39;useWatchlist&#39;,
                &#39;MFLD&#39;: &#39;matchField&#39;,
                &#39;MVAL&#39;: &#39;matchValue&#39;,
                &#39;SVRTY&#39;: &#39;severity&#39;,
                &#39;ASNID&#39;: &#39;assigneeId&#39;,
                &#39;ASNNAME&#39;: &#39;assignee&#39;,
                &#39;TRGDATE&#39;: &#39;triggeredDate&#39;,
                &#39;ACKDATE&#39;: &#39;acknowledgedDate&#39;,
                &#39;ESCDATE&#39;: &#39;escalatedDate&#39;,
                &#39;CASEID&#39;: &#39;caseId&#39;,
                &#39;CASENAME&#39;: &#39;caseName&#39;,
                &#39;IOCNAME&#39;: &#39;iocName&#39;,
                &#39;IOCID&#39;: &#39;iocId&#39;,
                &#39;DESC&#39;: &#39;description&#39;,
                &#39;NID&#39;: None,
                &#39;ACTIONS&#39;: &#39;actions&#39;,
                &#39;NE&#39;: None,
                &#39;EVENTS&#39;: &#39;events&#39;,
                &#39;DCHNG&#39;: None}
    &#34;&#34;&#34;
    List of all `Alarm` possible fields.  
    This mapping is used to create new alarms and change genuine (UPPERCASE) key names to explicit ones.  
    If the value is None, the original key name is kept, otherwise the UPPERCASE key won&#39;t work. 
    ```
    {&#39;EC&#39;: None,
    &#39;SMRY&#39;: &#39;summary&#39;,
    &#39;NAME&#39;: &#39;alarmName&#39;,
    &#39;FILTERS&#39;: &#39;filters&#39;,
    &#39;CTYPE&#39;: None,
    &#39;QID&#39;: &#39;queryId&#39;,
    &#39;ARM&#39;: &#39;alretRateMin&#39;,
    &#39;ARC&#39;: &#39;alertRateCount&#39;,
    &#39;PCTA&#39;: &#39;percentAbove&#39;,
    &#39;PCTB&#39;: &#39;percentBelow&#39;,
    &#39;OFFSETMIN&#39;: &#39;offsetMinutes&#39;,
    &#39;TIMEF&#39;: &#39;maximumConditionTriggerFrequency&#39;,
    &#39;XMIN&#39;: None,
    &#39;USEW&#39;: &#39;useWatchlist&#39;,
    &#39;MFLD&#39;: &#39;matchField&#39;,
    &#39;MVAL&#39;: &#39;matchValue&#39;,
    &#39;SVRTY&#39;: &#39;severity&#39;,
    &#39;ASNID&#39;: &#39;assigneeId&#39;,
    &#39;ASNNAME&#39;: &#39;assignee&#39;,
    &#39;TRGDATE&#39;: &#39;triggeredDate&#39;,
    &#39;ACKDATE&#39;: &#39;acknowledgedDate&#39;,
    &#39;ESCDATE&#39;: &#39;escalatedDate&#39;,
    &#39;CASEID&#39;: &#39;caseId&#39;,
    &#39;CASENAME&#39;: &#39;caseName&#39;,
    &#39;IOCNAME&#39;: &#39;iocName&#39;,
    &#39;IOCID&#39;: &#39;iocId&#39;,
    &#39;DESC&#39;: &#39;description&#39;,
    &#39;NID&#39;: None,
    &#39;ACTIONS&#39;: &#39;actions&#39;,
    &#39;NE&#39;: None,
    &#39;EVENTS&#39;: &#39;events&#39;,
    &#39;DCHNG&#39;: None}
    ```
    &#34;&#34;&#34; 

    def map_alarm_int_fields(self, alarm_details):
        &#34;&#34;&#34;
        Map the internal ESM field names to msiempy style with `msiempy.alarm.Alarm.ALARM_FIELDS_MAP`.  
        Converts &#34;T&#34; and &#34;F&#34; to `True` and `False` and handle None values.  
        &#34;&#34;&#34;

        for key, val in alarm_details.items():
            if alarm_details[key] == key:
                alarm_details[key] = None
            elif alarm_details[key] in [&#39;f&#39;, &#39;F&#39;]:
                alarm_details[key] = False
            elif alarm_details[key] in [&#39;t&#39;, &#39;T&#39;]:
                alarm_details[key] = True
            else:
                alarm_details[key] = val

        new_alarm = {}

        for priv_key in self.ALARM_FIELDS_MAP: new_alarm.__setitem__(
            self.ALARM_FIELDS_MAP[priv_key] or priv_key, alarm_details.get(priv_key) or None )

        log.debug(&#39;NEW FULL alarm_details: &#39;+str(new_alarm))

        return new_alarm
                                                                                       
    def data_from_id(self, id):
        &#34;&#34;&#34;
        Gets the alarm parameters based on an ID
        &#34;&#34;&#34;
        alarms = self.nitro.request(&#39;get_alarm_details_int&#39;, id=str(id))
        # Wrap arround private api call
        alarms = {key: dehexify(val).replace(&#39;\n&#39;, &#39;|&#39;) for key, val in alarms.items()} 
        alarms = self.map_alarm_int_fields(alarms)        
        return alarms</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="msiempy.core.types.NitroDict" href="core/types.html#msiempy.core.types.NitroDict">NitroDict</a></li>
<li>collections.UserDict</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="msiempy.core.types.NitroObject" href="core/types.html#msiempy.core.types.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.alarm.Alarm.POSSIBLE_ALARM_STATUS"><code class="name">var <span class="ident">POSSIBLE_ALARM_STATUS</span></code></dt>
<dd>
<div class="desc"><p>Possible alarm statuses : <code>acknowledged/ack, unacknowledged/unack, /all/both</code></p></div>
</dd>
<dt id="msiempy.alarm.Alarm.ALARM_EVENT_FILTER_FIELDS"><code class="name">var <span class="ident">ALARM_EVENT_FILTER_FIELDS</span></code></dt>
<dd>
<div class="desc"><p>Static event related fields usable in a filter. Usable in <code>filters</code> parameter : <code>ruleName, srcIp, destIp, protocol, lastTime, subtype, destPort, destMac, srcMac, srcPort, deviceName, sigId, normId, srcUser, destUser, normMessage, normDesc, host, domain, ipsId</code></p></div>
</dd>
<dt id="msiempy.alarm.Alarm.ALARM_DEFAULT_FIELDS"><code class="name">var <span class="ident">ALARM_DEFAULT_FIELDS</span></code></dt>
<dd>
<div class="desc"><p>Defaulfs fields : <code>id, alarmName, summary, triggeredDate, acknowledgedUsername</code>
(not used in library, can bu useful for printing with <code>get_text(fields=msiempy.alarm.ALARM_DEFAULT_FIELDS)</code>)</p></div>
</dd>
<dt id="msiempy.alarm.Alarm.ALARM_FIELDS_MAP"><code class="name">var <span class="ident">ALARM_FIELDS_MAP</span></code></dt>
<dd>
<div class="desc"><p>List of all <code><a title="msiempy.alarm.Alarm" href="#msiempy.alarm.Alarm">Alarm</a></code> possible fields.<br>
This mapping is used to create new alarms and change genuine (UPPERCASE) key names to explicit ones.<br>
If the value is None, the original key name is kept, otherwise the UPPERCASE key won't work. </p>
<pre><code>{'EC': None,
'SMRY': 'summary',
'NAME': 'alarmName',
'FILTERS': 'filters',
'CTYPE': None,
'QID': 'queryId',
'ARM': 'alretRateMin',
'ARC': 'alertRateCount',
'PCTA': 'percentAbove',
'PCTB': 'percentBelow',
'OFFSETMIN': 'offsetMinutes',
'TIMEF': 'maximumConditionTriggerFrequency',
'XMIN': None,
'USEW': 'useWatchlist',
'MFLD': 'matchField',
'MVAL': 'matchValue',
'SVRTY': 'severity',
'ASNID': 'assigneeId',
'ASNNAME': 'assignee',
'TRGDATE': 'triggeredDate',
'ACKDATE': 'acknowledgedDate',
'ESCDATE': 'escalatedDate',
'CASEID': 'caseId',
'CASENAME': 'caseName',
'IOCNAME': 'iocName',
'IOCID': 'iocId',
'DESC': 'description',
'NID': None,
'ACTIONS': 'actions',
'NE': None,
'EVENTS': 'events',
'DCHNG': None}
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.alarm.Alarm.acknowledge"><code class="name flex">
<span>def <span class="ident">acknowledge</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Mark the alarm as acknowledged.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acknowledge(self):
    &#34;&#34;&#34;Mark the alarm as acknowledged.
    &#34;&#34;&#34;
    if self.nitro.api_v == 1:
        self.nitro.request(&#39;ack_alarms&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])
    else:
        self.nitro.request(&#39;ack_alarms_11_2_1&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])</code></pre>
</details>
</dd>
<dt id="msiempy.alarm.Alarm.unacknowledge"><code class="name flex">
<span>def <span class="ident">unacknowledge</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Mark the alarm as unacknowledge.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unacknowledge(self):
    &#34;&#34;&#34;Mark the alarm as unacknowledge.
    &#34;&#34;&#34;
    if self.nitro.api_v == 1:
        self.nitro.request(&#39;unack_alarms&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])
    else:
        self.nitro.request(&#39;unack_alarms_11_2_1&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])</code></pre>
</details>
</dd>
<dt id="msiempy.alarm.Alarm.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Destructive action!
Delete the alarm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
    &#34;&#34;&#34;Destructive action!
    Delete the alarm.
    &#34;&#34;&#34;
    if self.nitro.api_v == 1:
        self.nitro.request(&#39;delete_alarms&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])
    else:
        self.nitro.request(&#39;delete_alarms_11_2_1&#39;, ids=self.data[&#39;id&#39;][&#39;value&#39;])</code></pre>
</details>
</dd>
<dt id="msiempy.alarm.Alarm.ceate_case"><code class="name flex">
<span>def <span class="ident">ceate_case</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Not implemented : TODO</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ceate_case(self):
    &#34;&#34;&#34;Not implemented : TODO
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="msiempy.alarm.Alarm.load_details"><code class="name flex">
<span>def <span class="ident">load_details</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the alarm with detailled data loaded from the SIEM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_details(self):
    &#34;&#34;&#34;Update the alarm with detailled data loaded from the SIEM.
    &#34;&#34;&#34;
    the_id = self.data[&#39;id&#39;][&#39;value&#39;]
    self.data.update(self.data_from_id(the_id))
    self.data[&#39;id&#39;][&#39;value&#39;]=the_id

    return self</code></pre>
</details>
</dd>
<dt id="msiempy.alarm.Alarm.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the alarm with detailled data loaded from the SIEM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;Update the alarm with detailled data loaded from the SIEM.  
    &#34;&#34;&#34;        
    self.load_details()</code></pre>
</details>
</dd>
<dt id="msiempy.alarm.Alarm.load_events"><code class="name flex">
<span>def <span class="ident">load_events</span></span>(<span>self, use_query=False, extra_fields=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Retreive the genuine Event object from an Alarm.
Warning : This method will load the details of the first triggering event only.
</p>
<p>Arguments:
</p>
<ul>
<li><code>use_query</code> : Uses the query module to retreive common event data. Only works with SIEM v 11.2 or greater.
<br>
Default behaviour will call <code>ipsGetAlertData</code> to retreive the complete event definition.
</li>
<li><code>extra_fields</code> : Only when <code>use_query=True</code>. Additionnal event fields to load in the query. See : <code><a title="msiempy.event.EventManager" href="event.html#msiempy.event.EventManager">EventManager</a></code></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_events(self, use_query=False, extra_fields=[]):
    &#34;&#34;&#34;
    Retreive the genuine Event object from an Alarm.
    Warning : This method will load the details of the first triggering event only.  

    Arguments:  

    - `use_query` : Uses the query module to retreive common event data. Only works with SIEM v 11.2 or greater.    
    Default behaviour will call `ipsGetAlertData` to retreive the complete event definition.  
    - `extra_fields` : Only when `use_query=True`. Additionnal event fields to load in the query. See : `msiempy.event.EventManager`  
    &#34;&#34;&#34;
    if isinstance(self.data[&#39;events&#39;], str):

        #Retreive the alert id from the event&#39;s string
        events_data=self.data[&#39;events&#39;].split(&#39;|&#39;)
        the_id = events_data[0]+&#39;|&#39;+events_data[1]

        #instanciate the event
        the_first_event=Event()
        the_first_event.data = Event().data_from_id(id=the_id, use_query=use_query, extra_fields=extra_fields)

        #set it as the only item of the event list
        self.data[&#39;events&#39;]= [ the_first_event ]

    else:
        log.info(&#39;The alarm {} ({}) has no events associated&#39;.format(self.data[&#39;alarmName&#39;], self.data[&#39;triggeredDate&#39;]))
        self.data[&#39;events&#39;]= [ Event() ]

    return self</code></pre>
</details>
</dd>
<dt id="msiempy.alarm.Alarm.map_alarm_int_fields"><code class="name flex">
<span>def <span class="ident">map_alarm_int_fields</span></span>(<span>self, alarm_details)</span>
</code></dt>
<dd>
<div class="desc"><p>Map the internal ESM field names to msiempy style with <code><a title="msiempy.alarm.Alarm.ALARM_FIELDS_MAP" href="#msiempy.alarm.Alarm.ALARM_FIELDS_MAP">Alarm.ALARM_FIELDS_MAP</a></code>.<br>
Converts "T" and "F" to <code>True</code> and <code>False</code> and handle None values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_alarm_int_fields(self, alarm_details):
    &#34;&#34;&#34;
    Map the internal ESM field names to msiempy style with `msiempy.alarm.Alarm.ALARM_FIELDS_MAP`.  
    Converts &#34;T&#34; and &#34;F&#34; to `True` and `False` and handle None values.  
    &#34;&#34;&#34;

    for key, val in alarm_details.items():
        if alarm_details[key] == key:
            alarm_details[key] = None
        elif alarm_details[key] in [&#39;f&#39;, &#39;F&#39;]:
            alarm_details[key] = False
        elif alarm_details[key] in [&#39;t&#39;, &#39;T&#39;]:
            alarm_details[key] = True
        else:
            alarm_details[key] = val

    new_alarm = {}

    for priv_key in self.ALARM_FIELDS_MAP: new_alarm.__setitem__(
        self.ALARM_FIELDS_MAP[priv_key] or priv_key, alarm_details.get(priv_key) or None )

    log.debug(&#39;NEW FULL alarm_details: &#39;+str(new_alarm))

    return new_alarm</code></pre>
</details>
</dd>
<dt id="msiempy.alarm.Alarm.data_from_id"><code class="name flex">
<span>def <span class="ident">data_from_id</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the alarm parameters based on an ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_from_id(self, id):
    &#34;&#34;&#34;
    Gets the alarm parameters based on an ID
    &#34;&#34;&#34;
    alarms = self.nitro.request(&#39;get_alarm_details_int&#39;, id=str(id))
    # Wrap arround private api call
    alarms = {key: dehexify(val).replace(&#39;\n&#39;, &#39;|&#39;) for key, val in alarms.items()} 
    alarms = self.map_alarm_int_fields(alarms)        
    return alarms</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.core.types.NitroDict" href="core/types.html#msiempy.core.types.NitroDict">NitroDict</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.core.types.NitroDict.NitroJSONEncoder" href="core/types.html#msiempy.core.types.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.core.types.NitroDict.json" href="core/types.html#msiempy.core.types.NitroDict.json">json</a></code></li>
<li><code><a title="msiempy.core.types.NitroDict.nitro" href="core/types.html#msiempy.core.types.NitroObject.nitro">nitro</a></code></li>
<li><code><a title="msiempy.core.types.NitroDict.text" href="core/types.html#msiempy.core.types.NitroDict.text">text</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="msiempy" href="index.html">msiempy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="msiempy.alarm.AlarmManager" href="#msiempy.alarm.AlarmManager">AlarmManager</a></code></h4>
<ul class="two-column">
<li><code><a title="msiempy.alarm.AlarmManager.add_filter" href="#msiempy.alarm.AlarmManager.add_filter">add_filter</a></code></li>
<li><code><a title="msiempy.alarm.AlarmManager.add_event_filter" href="#msiempy.alarm.AlarmManager.add_event_filter">add_event_filter</a></code></li>
<li><code><a title="msiempy.alarm.AlarmManager.clear_filters" href="#msiempy.alarm.AlarmManager.clear_filters">clear_filters</a></code></li>
<li><code><a title="msiempy.alarm.AlarmManager.load_data" href="#msiempy.alarm.AlarmManager.load_data">load_data</a></code></li>
<li><code><a title="msiempy.alarm.AlarmManager.qry_load_data" href="#msiempy.alarm.AlarmManager.qry_load_data">qry_load_data</a></code></li>
<li><code><a title="msiempy.alarm.AlarmManager.filters" href="#msiempy.alarm.AlarmManager.filters">filters</a></code></li>
<li><code><a title="msiempy.alarm.AlarmManager.status_filter" href="#msiempy.alarm.AlarmManager.status_filter">status_filter</a></code></li>
<li><code><a title="msiempy.alarm.AlarmManager.event_filters" href="#msiempy.alarm.AlarmManager.event_filters">event_filters</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.alarm.Alarm" href="#msiempy.alarm.Alarm">Alarm</a></code></h4>
<ul class="">
<li><code><a title="msiempy.alarm.Alarm.acknowledge" href="#msiempy.alarm.Alarm.acknowledge">acknowledge</a></code></li>
<li><code><a title="msiempy.alarm.Alarm.unacknowledge" href="#msiempy.alarm.Alarm.unacknowledge">unacknowledge</a></code></li>
<li><code><a title="msiempy.alarm.Alarm.delete" href="#msiempy.alarm.Alarm.delete">delete</a></code></li>
<li><code><a title="msiempy.alarm.Alarm.ceate_case" href="#msiempy.alarm.Alarm.ceate_case">ceate_case</a></code></li>
<li><code><a title="msiempy.alarm.Alarm.load_details" href="#msiempy.alarm.Alarm.load_details">load_details</a></code></li>
<li><code><a title="msiempy.alarm.Alarm.refresh" href="#msiempy.alarm.Alarm.refresh">refresh</a></code></li>
<li><code><a title="msiempy.alarm.Alarm.load_events" href="#msiempy.alarm.Alarm.load_events">load_events</a></code></li>
<li><code><a title="msiempy.alarm.Alarm.map_alarm_int_fields" href="#msiempy.alarm.Alarm.map_alarm_int_fields">map_alarm_int_fields</a></code></li>
<li><code><a title="msiempy.alarm.Alarm.data_from_id" href="#msiempy.alarm.Alarm.data_from_id">data_from_id</a></code></li>
<li><code><a title="msiempy.alarm.Alarm.POSSIBLE_ALARM_STATUS" href="#msiempy.alarm.Alarm.POSSIBLE_ALARM_STATUS">POSSIBLE_ALARM_STATUS</a></code></li>
<li><code><a title="msiempy.alarm.Alarm.ALARM_EVENT_FILTER_FIELDS" href="#msiempy.alarm.Alarm.ALARM_EVENT_FILTER_FIELDS">ALARM_EVENT_FILTER_FIELDS</a></code></li>
<li><code><a title="msiempy.alarm.Alarm.ALARM_DEFAULT_FIELDS" href="#msiempy.alarm.Alarm.ALARM_DEFAULT_FIELDS">ALARM_DEFAULT_FIELDS</a></code></li>
<li><code><a title="msiempy.alarm.Alarm.ALARM_FIELDS_MAP" href="#msiempy.alarm.Alarm.ALARM_FIELDS_MAP">ALARM_FIELDS_MAP</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>
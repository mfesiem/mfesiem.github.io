<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>msiempy.core.session API documentation</title>
<meta name="description" content="HTTP level interface to the ESM API." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>msiempy.core.session</code></h1>
</header>
<section id="section-intro">
<p>HTTP level interface to the ESM API.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
HTTP level interface to the ESM API.  
&#34;&#34;&#34;
import logging
import requests
import json
import ast
import re
import urllib.parse
import inspect
import time
import urllib3

from .utils import tob64
from .config import NitroConfig

log = logging.getLogger(&#39;msiempy&#39;)

__pdoc__ = {} # Init pdoc to document dynamically

PARAMS = {
    &#34;login&#34;: (&#34;login&#34;,
            &#34;&#34;&#34;{&#34;username&#34;: &#34;%(username)s&#34;,
                &#34;password&#34; : &#34;%(password)s&#34;,
                &#34;locale&#34;: &#34;en_US&#34;,
                &#34;os&#34;: &#34;Win32&#34;}
                &#34;&#34;&#34;),

    &#34;get_devtree&#34;: (&#34;GRP_GETVIRTUALGROUPIPSLISTDATA&#34;,
                    &#34;&#34;&#34;{&#34;ITEMS&#34;: &#34;#{DC1 + DC2}&#34;,
                        &#34;DID&#34;: &#34;1&#34;,
                        &#34;HD&#34;: &#34;F&#34;,
                        &#34;NS&#34;: &#34;0&#34;}
                    &#34;&#34;&#34;),

    &#34;get_zones_devtree&#34;: (&#34;GRP_GETVIRTUALGROUPIPSLISTDATA&#34;,
                    &#34;&#34;&#34;{&#34;ITEMS&#34;: &#34;#{DC1 + DC2}&#34;,
                        &#34;DID&#34;: &#34;3&#34;,
                        &#34;HD&#34;: &#34;F&#34;,
                        &#34;NS&#34;: &#34;0&#34;}
                    &#34;&#34;&#34;),

    &#34;req_client_str&#34;: (&#34;DS_GETDSCLIENTLIST&#34;,
                        &#34;&#34;&#34;{&#34;DSID&#34;: &#34;%(ds_id)s&#34;,
                            &#34;SEARCH&#34;: &#34;&#34;}
                        &#34;&#34;&#34;),

    &#34;get_rfile&#34;: (&#34;MISC_READFILE&#34;,
                &#34;&#34;&#34;{&#34;FNAME&#34;: &#34;%(ftoken)s&#34;,
                &#34;SPOS&#34;: &#34;0&#34;,
                &#34;NBYTES&#34;: &#34;0&#34;}
                &#34;&#34;&#34;),

    &#34;del_rfile&#34;: (&#34;ESSMGT_DELETEFILE&#34;,
                &#34;&#34;&#34;{&#34;FN&#34;: &#34;%(ftoken)s&#34;}&#34;&#34;&#34;),

    &#34;get_rfile2&#34;: (&#34;MISC_READFILE&#34;,
                &#34;&#34;&#34;{&#34;FNAME&#34;: &#34;%(ftoken)s&#34;,
                &#34;SPOS&#34;: &#34;%(pos)s&#34;,
                &#34;NBYTES&#34;: &#34;%(nbytes)s&#34;}
                &#34;&#34;&#34;),

    &#34;get_wfile&#34;: (&#34;MISC_WRITEFILE&#34;,
                &#34;&#34;&#34;{&#34;DATA1&#34;: &#34;%(ds_id)s&#34;,
                        &#34;PATH&#34;: &#34;21&#34;,
                        &#34;ND&#34;: &#34;1&#34;} &#34;&#34;&#34;),
    
    &#34;get_rule_history&#34;: (&#34;PLCY_GETRULECHANGEINFO&#34;, 
                        &#34;&#34;&#34;{&#34;SHOW&#34;: &#34;F&#34;}&#34;&#34;&#34;),

    &#34;map_dtree&#34;: (&#34;map_dtree&#34;,
                &#34;&#34;&#34;{&#34;dev_type&#34;: &#34;%(dev_type)s&#34;,
                &#34;name&#34;: &#34;%(ds_name)s&#34;,
                &#34;ds_id&#34;: &#34;%(ds_id)s&#34;,
                &#34;enabled&#34;: &#34;%(enabled)s&#34;,
                &#34;ds_ip&#34;: &#34;%(ds_ip)s&#34;,
                &#34;hostname&#34; : &#34;%(hostname)s&#34;,
                &#34;typeID&#34;: &#34;%(type_id)s&#34;,
                &#34;vendor&#34;: &#34;&#34;,
                &#34;model&#34;: &#34;&#34;,
                &#34;tz_id&#34;: &#34;&#34;,
                &#34;date_order&#34;: &#34;&#34;,
                &#34;port&#34;: &#34;&#34;,
                &#34;syslog_tls&#34;: &#34;&#34;,
                &#34;client_groups&#34;: &#34;%(client_groups)s&#34;
                }
                &#34;&#34;&#34;),

    &#34;add_ds_11_1_3&#34;: (&#34;dsAddDataSource&#34;, 
                &#34;&#34;&#34;{&#34;datasource&#34;: {
                        &#34;parentId&#34;: {&#34;id&#34;: &#34;%(parent_id)s&#34;},
                        &#34;name&#34;: &#34;%(name)s&#34;,
                        &#34;ipAddress&#34;: &#34;%(ds_ip)s&#34;,
                        &#34;typeId&#34;: {&#34;id&#34;: &#34;%(type_id)s&#34;},
                        &#34;zoneId&#34;: &#34;%(zone_id)s&#34;,
                        &#34;enabled&#34;: &#34;%(enabled)s&#34;,
                        &#34;url&#34;: &#34;%(url)s&#34;,
                        &#34;id&#34;: {&#34;id&#34;: &#34;%(ds_id)s&#34;},
                        &#34;childEnabled&#34;: &#34;%(child_enabled)s&#34;,
                        &#34;childCount&#34;: &#34;%(child_count)s&#34;,
                        &#34;childType&#34;: &#34;%(child_type)s&#34;,
                        &#34;idmId&#34;: &#34;%(idm_id)s&#34;,
                        &#34;parameters&#34;: %(parameters)s
                    }}&#34;&#34;&#34;),

    &#34;add_ds_11_2_1&#34;: (&#34;dsAddDataSources&#34;, 
                    &#34;&#34;&#34;{&#34;receiverId&#34;: &#34;%(parent_id)s&#34;,
                        &#34;datasources&#34;: [{
                            &#34;name&#34;: &#34;%(name)s&#34;,
                            &#34;ipAddress&#34;: &#34;%(ds_ip)s&#34;,
                            &#34;typeId&#34;: {&#34;id&#34;: &#34;%(type_id)s&#34;},
                            &#34;zoneId&#34;: &#34;%(zone_id)s&#34;,
                            &#34;enabled&#34;: &#34;%(enabled)s&#34;,
                            &#34;url&#34;: &#34;%(url)s&#34;,
                            &#34;parameters&#34;: %(parameters)s
                            }]}&#34;&#34;&#34;),

    &#34;add_client1&#34;: (&#34;DS_ADDDSCLIENT&#34;, 
                    &#34;&#34;&#34;{&#34;PID&#34;: &#34;%(parent_id)s&#34;,
                    &#34;NAME&#34;: &#34;%(name)s&#34;,
                    &#34;ENABLED&#34;: &#34;%(enabled)s&#34;,
                    &#34;IP&#34;: &#34;%(ds_ip)s&#34;,
                    &#34;HOST&#34;: &#34;%(hostname)s&#34;,
                    &#34;TYPE&#34;: &#34;%(type_id)s&#34;,
                    &#34;TZID&#34;: &#34;%(tz_id)s&#34;,
                    &#34;DORDER&#34;: &#34;%(dorder)s&#34;,
                    &#34;MASKFLAG&#34;: &#34;%(maskflag)s&#34;,
                    &#34;PORT&#34;: &#34;%(port)s&#34;,
                    &#34;USETLS&#34;: &#34;%(require_tls)s&#34;
                    }&#34;&#34;&#34;),
                    
    &#34;get_recs&#34;: (&#34;devGetDeviceList?filterByRights=false&#34;,
                    &#34;&#34;&#34;{&#34;types&#34;: [&#34;RECEIVER&#34;]}
                    &#34;&#34;&#34;),

    &#34;get_dstypes&#34;: (&#34;dsGetDataSourceTypes&#34;,
                    &#34;&#34;&#34;{&#34;receiverId&#34;: {&#34;id&#34;: &#34;%(rec_id)s&#34;}
                        }
                    &#34;&#34;&#34;),
                    
    &#34;del_ds1&#34;: (&#34;dsDeleteDataSource&#34;,
                &#34;&#34;&#34;{&#34;receiverId&#34;: {&#34;id&#34;: &#34;%(parent_id)s&#34;},
                    &#34;datasourceId&#34;: {&#34;id&#34;: &#34;%(ds_id)s&#34;}}
                &#34;&#34;&#34;),

    &#34;del_ds2&#34;: (&#34;dsDeleteDataSources&#34;,
                &#34;&#34;&#34;{&#34;receiverId&#34;: {&#34;value&#34;: &#34;%(parent_id)s&#34;},
                    &#34;datasourceIds&#34;: [{&#34;value&#34;: &#34;%(ds_id)s&#34;}]}
                &#34;&#34;&#34;),

    &#34;del_client&#34;: (&#34;DS_DELETEDSCLIENTS&#34;, 
                    &#34;&#34;&#34;{&#34;DID&#34;: &#34;%(parent_id)s&#34;,
                            &#34;FTOKEN&#34;: &#34;%(ftoken)s&#34;}&#34;&#34;&#34;
                    ),

    &#34;get_job_status&#34;: (&#34;MISC_JOBSTATUS&#34;,
                        &#34;&#34;&#34;{&#34;JID&#34;: &#34;%(job_id)s&#34;}&#34;&#34;&#34;),

    &#34;ds_last_times&#34;: (&#34;QRY_GETDEVICELASTALERTTIME&#34;,&#34;&#34;&#34;{}&#34;&#34;&#34;),
                    
    &#34;zonetree&#34;: (&#34;zoneGetZoneTree&#34;,None),
                    
    &#34;ds_by_type&#34;: (&#34;QRY_GETDEVICECOUNTBYTYPE&#34;,None),

    &#34;_dev_types&#34;:  (&#34;dev_type_map&#34;,
                        &#34;&#34;&#34;{&#34;1&#34;: &#34;zone&#34;,
                            &#34;2&#34;: &#34;ERC&#34;,
                            &#34;3&#34;: &#34;datasource&#34;,
                            &#34;4&#34;: &#34;Database Event Monitor (DBM)&#34;,
                            &#34;5&#34;: &#34;DBM Database&#34;,
                            &#34;7&#34;: &#34;Policy Auditor&#34;,
                            &#34;10&#34;: &#34;Application Data Monitor (ADM)&#34;,
                            &#34;12&#34;: &#34;ELM&#34;,
                            &#34;14&#34;: &#34;Local ESM&#34;,
                            &#34;15&#34;: &#34;Advanced Correlation Engine (ACE)&#34;,
                            &#34;16&#34;: &#34;Asset datasource&#34;,
                            &#34;17&#34;: &#34;Score-based Correlation&#34;,
                            &#34;19&#34;: &#34;McAfee ePolicy Orchestrator (ePO)&#34;,
                            &#34;20&#34;: &#34;EPO&#34;,
                            &#34;21&#34;: &#34;McAfee Network Security Manager (NSM)&#34;,
                            &#34;22&#34;: &#34;McAfee Network Security Platform (NSP)&#34;,
                            &#34;23&#34;: &#34;NSP Port&#34;,
                            &#34;24&#34;: &#34;McAfee Vulnerability Manager (MVM)&#34;,
                            &#34;25&#34;: &#34;Enterprise Log Search (ELS)&#34;,
                            &#34;254&#34;: &#34;client_group&#34;,
                            &#34;256&#34;: &#34;client&#34;}
                        &#34;&#34;&#34;),
                        
        &#34;ds_details1&#34;: (&#34;dsGetDataSourceDetail&#34;,
                        &#34;&#34;&#34;{&#34;datasourceId&#34;: 
                            {&#34;id&#34;: &#34;%(ds_id)s&#34;}}
                        &#34;&#34;&#34;),

        &#34;ds_details2&#34;: (&#34;dsGetDataSourceDetail&#34;,
                        &#34;&#34;&#34;{&#34;datasourceId&#34;: {&#34;value&#34;: &#34;%(ds_id)s&#34;}}&#34;&#34;&#34;),


        &#34;get_alarms_custom_time&#34;: (&#34;&#34;&#34;alarmGetTriggeredAlarms?triggeredTimeRange=%(time_range)s&amp;customStart=%(start_time)s&amp;customEnd=%(end_time)s&amp;status=%(status)s&amp;pageSize=%(page_size)s&amp;pageNumber=%(page_number)s&#34;&#34;&#34;,
                    None),

        &#34;get_alarms&#34;: (&#34;&#34;&#34;alarmGetTriggeredAlarms?triggeredTimeRange=%(time_range)s&amp;status=%(status)s&amp;pageSize=%(page_size)s&amp;pageNumber=%(page_number)s&#34;&#34;&#34;, None),

        &#34;get_alarm_details_new&#34;: (&#34;&#34;&#34;notifyGetTriggeredNotificationDetail&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;id&#34;:%(id)s}&#34;&#34;&#34;),

        &#34;get_alarm_details&#34;: (&#34;&#34;&#34;notifyGetTriggeredNotification&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;id&#34;:%(id)s}&#34;&#34;&#34;),

        &#34;get_alarm_details_int&#34;: (&#34;NOTIFY_GETTRIGGEREDNOTIFICATIONDETAIL&#34;, 
                                    &#34;&#34;&#34;{&#34;TID&#34;: &#34;%(id)s&#34;}&#34;&#34;&#34;),

        &#34;ack_alarms&#34;: (&#34;&#34;&#34;alarmAcknowledgeTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:[{&#34;value&#34;:%(ids)s}]}&#34;&#34;&#34;),

        &#34;ack_alarms_11_2_1&#34;: (&#34;&#34;&#34;alarmAcknowledgeTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:{&#34;alarmIdList&#34;:[%(ids)s]}}&#34;&#34;&#34;),

        &#34;unack_alarms&#34;: (&#34;&#34;&#34;alarmUnacknowledgeTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:[{&#34;value&#34;:%(ids)s}]}&#34;&#34;&#34;),

        &#34;unack_alarms_11_2_1&#34;: (&#34;&#34;&#34;alarmUnacknowledgeTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:{&#34;alarmIdList&#34;:[%(ids)s]}}&#34;&#34;&#34;),

        &#34;delete_alarms&#34;: (&#34;&#34;&#34;alarmDeleteTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:[{&#34;value&#34;:%(ids)s}]}&#34;&#34;&#34;),
        
        &#34;delete_alarms_11_2_1&#34;: (&#34;&#34;&#34;alarmDeleteTriggeredAlarm&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;triggeredIds&#34;:{&#34;alarmIdList&#34;:[%(ids)s]}}&#34;&#34;&#34;),

        &#34;get_possible_filters&#34; : ( &#34;&#34;&#34;qryGetFilterFields&#34;&#34;&#34;, None ),

        &#34;get_possible_fields&#34; : ( &#34;&#34;&#34;qryGetSelectFields?type=%(type)s&amp;groupType=%(groupType)s&#34;&#34;&#34;, None ),

        &#34;get_esm_time&#34; : ( &#34;&#34;&#34;essmgtGetESSTime&#34;&#34;&#34;,None),

        &#34;get_alerts_now&#34; : (&#34;&#34;&#34;IPS_GETALERTSNOW&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;IPSID&#34;: &#34;%(ds_id)s&#34;}&#34;&#34;&#34;),

        &#34;get_flows_now&#34; : (&#34;&#34;&#34;IPS_GETALERTSNOW&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;IPSID&#34;: &#34;%(ds_id)s&#34;}&#34;&#34;&#34;),

        &#34;logout&#34; : ( &#34;&#34;&#34;userLogout&#34;&#34;&#34;, None ),

        &#34;get_user_locale&#34; : ( &#34;&#34;&#34;getUserLocale&#34;&#34;&#34;, None ),

        &#34;event_query_custom_time&#34; : (&#34;&#34;&#34;qryExecuteDetail?type=EVENT&amp;reverse=false&#34;&#34;&#34;, &#34;&#34;&#34;{
                &#34;config&#34;: {
                    &#34;timeRange&#34;: &#34;%(time_range)s&#34;,
                    &#34;customStart&#34;: &#34;%(start_time)s&#34;,
                    &#34;customEnd&#34;: &#34;%(end_time)s&#34;,
                    &#34;fields&#34;: %(fields)s,
                    &#34;filters&#34;: %(filters)s,
                    &#34;limit&#34;: %(limit)s,
                    &#34;offset&#34;: %(offset)s,
                    &#34;order&#34;: [{&#34;field&#34;: {&#34;name&#34;: &#34;%(order_field)s&#34;},
                                            &#34;direction&#34;: &#34;%(order_direction)s&#34;}]
                    }
                    }&#34;&#34;&#34;),

        &#34;event_query&#34; : (&#34;&#34;&#34;qryExecuteDetail?type=EVENT&amp;reverse=false&#34;&#34;&#34;, &#34;&#34;&#34;{
                &#34;config&#34;: {
                    &#34;timeRange&#34;:&#34;%(time_range)s&#34;,
                    &#34;fields&#34;:%(fields)s,
                    &#34;filters&#34;:%(filters)s,
                    &#34;limit&#34;:%(limit)s,
                    &#34;offset&#34;:%(offset)s,
                    &#34;order&#34;: [{&#34;field&#34;: {&#34;name&#34;: &#34;%(order_field)s&#34;},
                                            &#34;direction&#34;: &#34;%(order_direction)s&#34;}]
                    }
                    }&#34;&#34;&#34;),

        &#34;query_status&#34; : (&#34;&#34;&#34;qryGetStatus&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;resultID&#34;: %(resultID)s}&#34;&#34;&#34;),

        &#34;query_result&#34; : (&#34;&#34;&#34;qryGetResults?startPos=%(startPos)s&amp;numRows=%(numRows)s&amp;reverse=false&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;resultID&#34;: %(resultID)s}&#34;&#34;&#34;),
        
        &#34;time_zones&#34; : (&#34;&#34;&#34;userGetTimeZones&#34;&#34;&#34;, None),

        &#34;logout&#34; : (&#34;&#34;&#34;logout&#34;&#34;&#34;, None),
        
        &#34;add_note_to_event&#34; : (&#34;&#34;&#34;ipsAddAlertNote&#34;&#34;&#34;, &#34;&#34;&#34;{
            &#34;id&#34;: {&#34;value&#34;: &#34;%(id)s&#34;},
            &#34;note&#34;: {&#34;note&#34;: &#34;%(note)s&#34;}
        }&#34;&#34;&#34;),

        &#34;add_note_to_event_int&#34;: (&#34;&#34;&#34;IPS_ADDALERTNOTE&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;AID&#34;: &#34;%(id)s&#34;,
                                                            &#34;NOTE&#34;: &#34;%(note)s&#34;}&#34;&#34;&#34;),

        &#34;get_wl_types&#34;: (&#34;&#34;&#34;sysGetWatchlistFields&#34;&#34;&#34;, None),
        &#34;get_watchlists_no_filters&#34; : (&#34;&#34;&#34;sysGetWatchlists?hidden=%(hidden)s&amp;dynamic=%(dynamic)s&amp;writeOnly=%(writeOnly)s&amp;indexedOnly=%(indexedOnly)s&#34;&#34;&#34;, 
            None),

        &#34;get_watchlist_details&#34;: (&#34;&#34;&#34;sysGetWatchlistDetails&#34;&#34;&#34;,&#34;&#34;&#34;{&#34;id&#34;: %(id)s}&#34;&#34;&#34;),

        &#34;add_watchlist&#34;: (&#34;&#34;&#34;sysAddWatchlist&#34;&#34;&#34;, &#34;&#34;&#34;{
            &#34;watchlist&#34;: {
                &#34;name&#34;: &#34;%(name)s&#34;,
                &#34;type&#34;: {&#34;name&#34;: &#34;%(wl_type)s&#34;,
                            &#34;id&#34;: 0},
                &#34;customType&#34;: {&#34;name&#34;: &#34;&#34;,
                                &#34;id&#34;: 0},
                &#34;dynamic&#34;: &#34;False&#34;,
                &#34;enabled&#34;: &#34;True&#34;,
                &#34;search&#34;: &#34;&#34;,
                &#34;source&#34;: 0,
                &#34;updateType&#34;: &#34;EVERY_SO_MANY_MINUTES&#34;,
                &#34;updateDay&#34;: 0,
                &#34;updateMin&#34;: 0,
                &#34;ipsid&#34;: &#34;0&#34;,
                &#34;valueFile&#34;: {&#34;fileToken&#34;: &#34;&#34;},
                &#34;dbUrl&#34;: &#34;&#34;,
                &#34;mountPoint&#34;: &#34;&#34;,    
                &#34;path&#34;: &#34;&#34;,
                &#34;port&#34;: &#34;22&#34;,
                &#34;username&#34;: &#34;&#34;,
                &#34;password&#34;: &#34;&#34;,
                &#34;query&#34;: &#34;&#34;,
                &#34;lookup&#34;: &#34;&#34;,
                &#34;jobTrackerURL&#34;: &#34;&#34;,
                &#34;jobTrackerPort&#34;: &#34;&#34;,
                &#34;postArgs&#34;: &#34;&#34;,
                &#34;ignoreRegex&#34;: &#34;&#34;,
                &#34;method&#34;: 0,
                &#34;matchRegex&#34;: &#34;&#34;,
                &#34;lineSkip&#34;: 0,
                &#34;delimitRegex&#34;: &#34;&#34;,
                &#34;groups&#34;: 1
                            }}&#34;&#34;&#34;),
                                                        
        &#34;add_watchlist_values&#34;: (&#34;&#34;&#34;sysAddWatchlistValues&#34;&#34;&#34;,&#34;&#34;&#34;{
            &#34;watchlist&#34;: %(watchlist)s,
            &#34;values&#34;: %(values)s,
            }&#34;&#34;&#34;),

        &#34;get_watchlist_values&#34;: (&#34;SYS_GETWATCHLISTDETAILS&#34;,
                                        &#34;&#34;&#34;{&#34;WID&#34;: &#34;%(id)s&#34;, &#34;LIM&#34;: &#34;T&#34;}&#34;&#34;&#34;),

        &#34;remove_watchlists&#34;: (&#34;&#34;&#34;sysRemoveWatchlist&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;ids&#34;: {&#34;watchlistIdList&#34;: [&#34;%(wl_id_list)s&#34;]}}&#34;&#34;&#34;),

        &#34;get_alert_data&#34;: (&#34;&#34;&#34;ipsGetAlertData&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;id&#34;: {&#34;value&#34;:&#34;%(id)s&#34;}}&#34;&#34;&#34;),
        
        &#34;get_sys_info&#34;  : (&#34;SYS_GETSYSINFO&#34;,&#34;&#34;&#34;{}&#34;&#34;&#34;),
        
        &#34;build_stamp&#34; : (&#34;essmgtGetBuildStamp&#34;,None)
} #__pdoc__[&#39;NitroSession.PARAMS&#39;] = 
&#39;&#39;&#39;
SIEM API Methos/Parameters mapping.  
This structure provide a central place to aggregate API methods and parameters.  
The parameters are stored as docstrings to support string replacement.  

Args:  
    - `method` (str): Dict key associated with desired function
    Use normal dict access, PARAMS[&#34;method&#34;], or PARAMS.get(&#34;method&#34;)

Returns:  
    - `tuple `: (string, string) : The first string is the method name that is actually used as
    the URI or passed to the ESM. The second string is the params
    required for that method. Some params require variables be
    interpolated as documented in the data structure.

Usage exemple in `msiempy.core.session.NitroSession.request` source code.  

Important note : 
    Do not use sigle quotes (`&#39;`) to delimit data into the interpolated strings !

*Partial* data structure :  
```
{
    &#34;login&#34;: (&#34;login&#34;,
            &#34;&#34;&#34;{&#34;username&#34;: &#34;%(username)s&#34;,
                &#34;password&#34; : &#34;%(password)s&#34;,
                &#34;locale&#34;: &#34;en_US&#34;,
                &#34;os&#34;: &#34;Win32&#34;}
                &#34;&#34;&#34;),
    
    &#34;add_watchlist_values&#34;: (&#34;&#34;&#34;sysAddWatchlistValues&#34;&#34;&#34;,&#34;&#34;&#34;{
            &#34;watchlist&#34;: %(watchlist)s,
            &#34;values&#34;: %(values)s,
            }&#34;&#34;&#34;),

    &#34;get_watchlist_values&#34;: (&#34;SYS_GETWATCHLISTDETAILS&#34;,
                                    &#34;&#34;&#34;{&#34;WID&#34;: &#34;%(id)s&#34;, &#34;LIM&#34;: &#34;T&#34;}&#34;&#34;&#34;),

    &#34;remove_watchlists&#34;: (&#34;&#34;&#34;sysRemoveWatchlist&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;ids&#34;: {&#34;watchlistIdList&#34;: [&#34;%(wl_id_list)s&#34;]}}&#34;&#34;&#34;),

    &#34;get_alert_data&#34;: (&#34;&#34;&#34;ipsGetAlertData&#34;&#34;&#34;, &#34;&#34;&#34;{&#34;id&#34;: {&#34;value&#34;:&#34;%(id)s&#34;}}&#34;&#34;&#34;),
    
    &#34;get_sys_info&#34;  : (&#34;SYS_GETSYSINFO&#34;,&#34;&#34;&#34;{}&#34;&#34;&#34;),
    
    &#34;build_stamp&#34; : (&#34;essmgtGetBuildStamp&#34;,None),

    &#34;event_query&#34; : (&#34;&#34;&#34;qryExecuteDetail?type=EVENT&amp;reverse=false&#34;&#34;&#34;, &#34;&#34;&#34;{
                &#34;config&#34;: {
                    &#34;timeRange&#34;:&#34;%(time_range)s&#34;,
                    &#34;fields&#34;:%(fields)s,
                    &#34;filters&#34;:%(filters)s,
                    &#34;limit&#34;:%(limit)s,
                    &#34;offset&#34;:%(offset)s,
                    &#34;order&#34;: [{&#34;field&#34;: {&#34;name&#34;: &#34;%(order_field)s&#34;}, &#34;direction&#34;: &#34;%(order_direction)s&#34;}]
                    }}&#34;&#34;&#34;),

    [...]
}
```  
Please see `dump_api_params.py` script at https://github.com/mfesiem/msiempy/blob/master/samples/dump_api_params.py to dump the complete structure.
&#39;&#39;&#39;

class NitroSession():
    &#34;&#34;&#34;
    `msiempy.core.session.NitroSession` is the point of convergence of every requests that goes to the ESM.  
    It provides easier dialogue with the ESM by doing agument interpolation with `msiempy.core.params.PARAMS`.  

    It uses `msiempy.core.config.NitroConfig` to setup authentication, other configuration like verbosity, logfile, general timeout, are offered throught the config file.

    The init method is called every time you call NitroSession() constructor. But the properties are actually initiated only once.  

    Arguments:  

    - `conf_path` : Configuration file path.  
    - `conf_dict` : Manual config dict. ex: `{&#39;general&#39;:{&#39;verbose&#39;:True}}`. See `msiempy.core.config.NitroConfig` class to have full details.

    See `msiempy.core.session.NitroSession.esm_request` and `msiempy.core.session.NitroSession.request` for usage.  

    &#34;&#34;&#34;
    def __init__(self, conf_path=None, conf_dict=None):
        # global log
        self.__dict__ = NitroSession.__unique_state__
        
        #Init properties only once
        if NitroSession.__initiated__ == False :
            NitroSession.__initiated__ = True
            
            #Private attributes
            self._headers={&#39;Content-Type&#39;: &#39;application/json&#39;}
            
            #Config parsing
            self.config = NitroConfig(path=conf_path, config=conf_dict)
            NitroSession.config=self.config

            #Set the logging configuration
            self._init_log(verbose=self.config.verbose,
                quiet=self.config.quiet,
                logfile=self.config.logfile)

            self.api_v = 0
            self.logged_in=False
            self.login_info=dict()

            try :
                requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)
                urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
            except : 
                pass
            # logging.getLogger(&#34;urllib3&#34;).setLevel(logging.ERROR)

    BASE_URL = &#39;https://{}/rs/esm/&#39;
    &#34;&#34;&#34;API v2 base url: &#39;https://{}/rs/esm/&#39;&#34;&#34;&#34;

    BASE_URL_PRIV = &#39;https://{}/ess/&#39;
    &#34;&#34;&#34;Private API base URL: &#39;https://{}/ess/&#39;&#34;&#34;&#34;

    __initiated__ = False
    &#34;&#34;&#34;
    Weither the session has been intaciated. It&#39;s supposed to be a singleton.
    &#34;&#34;&#34;
    __unique_state__ = {}
    &#34;&#34;&#34;
    The singleton unique state.
    &#34;&#34;&#34;
    
    config = None
    &#34;&#34;&#34;
    `msiempy.core.config.NitroConfig` object.  
    &#34;&#34;&#34;
    
    PARAMS = PARAMS
        
    def __str__(self):
        return repr(self.__unique_state__) 

    def login(self, retry=1):
        &#34;&#34;&#34;Authentication is done lazily upon the first call to `msiempy.core.session.NitroSession.request` method, but you can still do it manually by calling this method.  
        Throws `msiempy.NitroError` if login fails.  
        &#34;&#34;&#34;
        userb64 = tob64(self.config.user)
        passb64 = self.config.passwd
        
        resp = self.request(&#39;login&#39;, username=userb64, password=passb64, raw=True, secure=True)
        
        if resp != None :
            try:
                resp.raise_for_status()
            except requests.HTTPError as e :
                if retry&gt;0:
                    time.sleep(1)
                    return self.login(retry=retry-1)
                else:
                    raise NitroError(&#39;ESM Login Error: &#39;, resp.text) from e
       
            self._headers[&#39;Cookie&#39;] = resp.headers.get(&#39;Set-Cookie&#39;)
            self._headers[&#39;X-Xsrf-Token&#39;] = resp.headers.get(&#39;Xsrf-Token&#39;)
            
            self.user_tz_id = dict(resp.json())[&#39;tzId&#39;]
            self.logged_in = True
            self.login_info=self.unpack_resp(resp)

            # Shorthanding the API version check 
            # 1 for pre 11.2.1, 2 for 11.2.1 and later
            # Not be confused with the ESM API v1 and v2 which are different.
            if str(self.version).startswith((&#39;9&#39;, &#39;10&#39;, &#39;11.0&#39;, &#39;11.1&#39;)):
                self.api_v = 1
            else:
                self.api_v = 2

            log.info(&#39;Logged into ESM {} with username {}. Last login {}&#39;.format(
                str(self.config.host),
                self.login_info[&#39;userName&#39;],
                self.login_info[&#39;lastLoginDate&#39;]))

            return True
        else:
            raise NitroError(&#39;ESM Login Error: Response empty&#39;)

    def logout(self):
        &#34;&#34;&#34; 
        This method will logout the session.
        &#34;&#34;&#34;
        self.api_v = 0
        self.request(&#39;logout&#39;, http=&#39;delete&#39;)
        self.logged_in=False
        self.login_info=dict()
        self._headers={&#39;Content-Type&#39;: &#39;application/json&#39;}
        self.user_tz_id = None

    def esm_request(self, method, data, http=&#39;post&#39;, callback=None, raw=False, secure=False, retry=1):
        &#34;&#34;&#34;
        Handle a lower level HTTP request to ESM API endpoints.  

        Format the request, handle the basic parsing of the SIEM result as well as other errors.  

        All upper cases method names signals to use the private API methods. 
        See `msiempy.core.session.NitroSession.format_priv_resp` and `msiempy.core.session.NitroSession.format_params`

        ESM responses are unpacked with `msiempy.core.session.NitroSession.unpack_resp`.  

        Arguments :  

        - `method` : ESM API enpoint name and url formatted parameters  
        - `http`: HTTP method.  
        - `data` : dict data to send  
        - `callback` : function to apply afterwards  
        - `raw` : If true will return the Response object from requests module. No retry when raw=True.     
        - `secure` : If true will not log the content of the request.   
        - `retry` : Number of time the request can be retried  

        Returns : 

        - a `dict`, `list` or `str` object. 
        - the `resquest.Response` object if raw=True  
        - `None` if Timeout or TooManyRedirects if raw=False  

        Raises:

        - `msiempy.core.session.NitroError` if any `HTTPError`

        Note : Private API is under /ess/ and public api is under /rs/esm  

        Exemple call:

            from msiempy import NitroSession
            s = NitroSession()
            s.login()
            # qryGetFilterFields 
            s.esm_request(&#39;qryGetFilterFields&#39;)
            # Get all last 24h alarms details with ESM API v2.  
            alarms = s.esm_request(&#39;v2/alarmGetTriggeredAlarms?triggeredTimeRange=LAST_24_HOURS&amp;status=&amp;pageSize=500&amp;pageNumber=1&#39;, None)
            for a in alarms:
                a.update(s.esm_request(&#39;v2/notifyGetTriggeredNotificationDetail&#39;, {&#39;id&#39;:a[&#39;id&#39;]}))

        &#34;&#34;&#34;

        url=str()
        privateApiCall=False
        result=None

        #Logging the data request if not secure | Logs anyway the method
        log.debug(&#39;Requesting HTTP &#39;+str(http)+&#39; &#39;+ str(method) + 
            (&#39; with data &#39;+str(data) if not secure else &#39; ***&#39;) )
        
        http_data=str()

        #Handling private API calls formatting
        if method == method.upper():
            privateApiCall=True
            url = self.BASE_URL_PRIV
            http_data = self.format_params(method, **data)
            log.debug(&#39;Private API call : &#39;+str(method)+&#39; Formatted params : &#39;+str(http_data))
        
        #Normal API calls
        else:
            url = self.BASE_URL
            if data :
                http_data = json.dumps(data)

        try :
            result = requests.request(
                http,
                urllib.parse.urljoin(url.format(self.config.host), method),
                data=http_data, 
                headers=self._headers,
                verify=self.config.ssl_verify,
                timeout=self.config.timeout,
                # Uncomment for debugging.
                # proxies={&#34;http&#34;: &#34;http://127.0.0.1:8888&#34;, &#34;https&#34;:&#34;http:127.0.0.1:8888&#34;}
            )

            if raw :
                log.debug(&#39;Returning raw requests Response object : &#39;+str(result))
                return result

            else:
                try:
                    result.raise_for_status()

                except requests.HTTPError as e :
                    error=None

                    if retry&gt;0 :
                        # Invalid session handler -&gt; re-login
                        if any([match in result.text for match in [&#39;ERROR_InvalidSession&#39;, &#39;ERROR_INVALID_SESSION&#39;,
                            &#39;Not Authorized User&#39;, &#39;Invalid Session&#39;, &#39;Username and password cannot be null&#39;]]):
                            error = NitroError(&#39;Authentication error with method ({}) and data : {} logging in and retrying esm_request(). From requests.HTTPError {} {}&#39;.format(
                                method, data, e, result.text))
                            log.warning(error)
                            self.logged_in=False
                            self.login()
                        
                        else: log.warning(&#39;An HTTP error occured ({} {}), retrying esm_request()&#39;.format(e, result.text))
                        
                        # Retry request
                        time.sleep(1)
                        return self.esm_request(method, data, http, callback, raw, secure, retry=retry-1)
                    
                    else :
                        error = NitroError(&#39;Error with method ({}) and data : {}. From requests.HTTPError {} {}&#39;.format(
                            method, data, e, result.text))
                        log.error(error)
                        raise error from e

                else: # The result is not an HTTP Error
                    response = result
                    result = self.unpack_resp(result)

                    if privateApiCall :
                        result = self.format_priv_resp(result)

                    if callback:
                        result = callback(result)

                    log.debug(&#39;{} -&gt; Result ({}): {}&#39;.format(
                        str(response),
                        type(result),
                        str(result)[:200] + &#39;[...]&#39; if len(str(result))&gt;200 else &#39;&#39;
                    ))

                    return result

        #Hard errors, could retry
        except requests.exceptions.Timeout as e:
            log.error(e)
            raise
        except requests.exceptions.TooManyRedirects as e :
            log.error(e)
            raise
        
    # def _request_http_error_handler(self, error, method, data, http, callback, raw, secure, retry):
    #     pass

    def version(self):
        &#34;&#34;&#34;
        Returns: `str` ESM short version.  
        Example: &#39;10.0.2&#39;
        &#34;&#34;&#34;
        return self.buildstamp().split()[0]

    def buildstamp(self):
        &#34;&#34;&#34;
        Returns: `str` ESM buildstamp.  
        Example: &#39;10.0.2 20170516001031&#39;
        &#34;&#34;&#34;
        return self.request(&#39;build_stamp&#39;)[&#39;buildStamp&#39;]

    def get_internal_file(self, file_token):
        &#34;&#34;&#34;Uses the private API to retrieve, assemble and delete a temp file from the ESM.
        
        Arguments:  

        - `file_token` (`str`): File token ID
        &#34;&#34;&#34;
        pos = 0
        nbytes = 0
        resp = self.request(&#39;get_rfile2&#39;, ftoken=file_token, pos=pos, nbytes=nbytes)

        if resp[&#39;FSIZE&#39;] == resp[&#39;BREAD&#39;]:
            data = resp[&#39;DATA&#39;]
            self.request(&#39;del_rfile&#39;, ftoken=file_token)
            return data
        
        data = []
        data.append(resp[&#39;DATA&#39;])
        file_size = int(resp[&#39;FSIZE&#39;])
        collected = int(resp[&#39;BREAD&#39;])

        while file_size &gt; collected:
            pos += int(resp[&#39;BREAD&#39;])
            nbytes = file_size - collected
            resp = self.request(&#39;get_rfile2&#39;, ftoken=file_token, pos=pos, nbytes=nbytes)
            collected += int(resp[&#39;BREAD&#39;])
            data.append(resp[&#39;DATA&#39;])

        resp = self.request(&#39;del_rfile&#39;, ftoken=file_token)
        return &#39;&#39;.join(data)

    def request(self, request, **kwargs):
        &#34;&#34;&#34;
        Interface to make ESM API calls more simple by interpolating `**kwargs` arguments with `msiempy.core.params.PARAMS` docstrings and build a valid datastructure for the HTTP data.  

        Then call the `msiempy.core.session.NitroSession.esm_request` method with the built data.  

        Also handles auto-login.  

        Arguments:  

        - `request`: Keyword corresponding to the request name in `msiempy.core.params.PARAMS` mapping.  
        - `http`: HTTP method.  
        - `callback` : function to apply afterwards  
        - `raw` : If true will return the Response object from requests module.   
        - `secure` : If true will not log the content of the request.   
        - `retry` : Number of time the request can be retried
        
        Interpolation parameters :  
        
        - `**kwargs` : Interpolation parameters that will be match to `msiempy.core.params.PARAMS` templates. Dynamic keyword arguments.  

        Returns :  

        - a `dict`, `list` or `str` object  
        - the `resquest.Response` object if raw=True  
        - `result.text` if `requests.HTTPError`,   
        - `None` if Timeout or TooManyRedirects if raw=False  

        Exemple call:

            from msiempy import NitroSession
            s = NitroSession()
            s.login()
            # Get all last 24h alarms details
            alarms = s.request(&#39;get_alarms&#39;, time_range=&#39;LAST_24_HOURS&#39;,  status=&#39;&#39;, page_size=500, page_number=0)
            for a in alarms:
                a.update(s.request(&#39;get_alarm_details_new&#39;, id=a[&#39;id&#39;]))


        &#34;&#34;&#34;
        log.debug(&#34;Calling nitro request : {} kwargs={}&#34;.format(
            str(request), &#39;***&#39; if &#39;secure&#39; in kwargs and kwargs[&#39;secure&#39;]==True else str(kwargs)))

        method, data = self.PARAMS.get(request)

        if data != None :
            data =  data % kwargs
            data = ast.literal_eval((data.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\t&#39;,&#39;&#39;)))
           
        if method != None:
            try :
                method = method % kwargs
            except TypeError as err :
                if (&#39;must be real number, not dict&#39; in str(err)):
                    log.warning(&#34;Interpolation failed probably because of the private API calls formatting... Unexpected behaviours can happend.&#34;)

        if not self.logged_in and method != &#39;login&#39;:
            # Autologin
            self.login()
    
        # Dynamically checking the esm_request arguments so additionnal parameters can be passed.  
        esm_request_args = inspect.getfullargspec(self.esm_request)[0]
        params={}
        for arg in kwargs :
            if arg in esm_request_args:
                params[arg]=kwargs[arg]
        return self.esm_request(method=method, data=data, **params)

    @staticmethod
    def _init_log(verbose=False, quiet=False, logfile=None):
        &#34;&#34;&#34;
        Private method. Inits the session&#39;s logger settings based on params
        All objects should be able to log stuff, so the logger is globaly accessible
        &#34;&#34;&#34;

        log.setLevel(logging.DEBUG)

        std = logging.StreamHandler()
        std.setLevel(logging.DEBUG)
        std.setFormatter(logging.Formatter(&#39;%(levelname)s - %(message)s&#39;))

        if verbose :
            std.setLevel(logging.DEBUG)
        elif quiet :
            std.setLevel(logging.CRITICAL)
        else :
            std.setLevel(logging.INFO)

        log.handlers=[]
        
        log.addHandler(std)

        if logfile :
            fh = logging.FileHandler(logfile)
            fh.setLevel(logging.DEBUG)
            fh.setFormatter(logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(message)s&#39;))
            log.addHandler(fh)

        if verbose and quiet :
            log.warning(&#34;Verbose and quiet values are both set to True. By default, output will be verbose.&#34;)

        return (log)

    @staticmethod
    def format_params(cmd, **params):
        &#34;&#34;&#34;
        Format private API call.  
        &#34;&#34;&#34;
        params = {k: v for k, v in params.items() if v != None}
        params = &#39;%14&#39;.join([k + &#39;%13&#39; + v + &#39;%13&#39; for (k, v) in params.items()])
        
        if params:
            params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39; + params + &#39;%14&#39;
        else:
            params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39;
        return params

    @staticmethod
    def format_priv_resp(resp):
        &#34;&#34;&#34;
        Format response from private API.  
        &#34;&#34;&#34;
        resp = re.search(&#39;Response=(.*)&#39;, resp).group(1)
        resp = resp.replace(&#39;%14&#39;, &#39; &#39;)
        pairs = resp.split()
        formatted = {}
        for pair in pairs:
            pair = pair.replace(&#39;%13&#39;, &#39; &#39;)
            pair = pair.split()
            key = pair[0]
            if key == &#39;ITEMS&#39;:
                value = pair[-1]
            else:
                value = urllib.parse.unquote(pair[-1])
            formatted[key] = value
        return formatted

    @staticmethod
    def unpack_resp(response) :
        &#34;&#34;&#34;Unpack data from response.  
        Should not be necessary with API v2.  
        Args: 
            response: requests.Response response object
        Returns a list, a dict or a string
        &#34;&#34;&#34;
        try :
            data = response.json()
            if isinstance(response.json(), dict):
                try:
                    data = data[&#39;value&#39;]
                except KeyError:
                    try:
                        data = data[&#39;return&#39;]
                    except KeyError:
                        pass
            
        except ValueError :
            data = response.text

        return data

class NitroError(Exception):
    &#34;&#34;&#34;
    Base ESM exception.  
    It&#39;s used when the user/passwd is incorrect and other HTTP errors.  
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="msiempy.core.session.PARAMS"><code class="name">var <span class="ident">PARAMS</span></code></dt>
<dd>
<div class="desc"><p>SIEM API Methos/Parameters mapping.<br>
This structure provide a central place to aggregate API methods and parameters.<br>
The parameters are stored as docstrings to support string replacement.
</p>
<p>Args:<br>
- <code>method</code> (str): Dict key associated with desired function
Use normal dict access, PARAMS["method"], or PARAMS.get("method")</p>
<p>Returns:<br>
- <code>tuple </code>: (string, string) : The first string is the method name that is actually used as
the URI or passed to the ESM. The second string is the params
required for that method. Some params require variables be
interpolated as documented in the data structure.</p>
<p>Usage exemple in <code><a title="msiempy.core.session.NitroSession.request" href="#msiempy.core.session.NitroSession.request">NitroSession.request()</a></code> source code.
</p>
<p>Important note :
Do not use sigle quotes (<code>'</code>) to delimit data into the interpolated strings !</p>
<p><em>Partial</em> data structure :
</p>
<pre><code>{
    &quot;login&quot;: (&quot;login&quot;,
            &quot;&quot;&quot;{&quot;username&quot;: &quot;%(username)s&quot;,
                &quot;password&quot; : &quot;%(password)s&quot;,
                &quot;locale&quot;: &quot;en_US&quot;,
                &quot;os&quot;: &quot;Win32&quot;}
                &quot;&quot;&quot;),

    &quot;add_watchlist_values&quot;: (&quot;&quot;&quot;sysAddWatchlistValues&quot;&quot;&quot;,&quot;&quot;&quot;{
            &quot;watchlist&quot;: %(watchlist)s,
            &quot;values&quot;: %(values)s,
            }&quot;&quot;&quot;),

    &quot;get_watchlist_values&quot;: (&quot;SYS_GETWATCHLISTDETAILS&quot;,
                                    &quot;&quot;&quot;{&quot;WID&quot;: &quot;%(id)s&quot;, &quot;LIM&quot;: &quot;T&quot;}&quot;&quot;&quot;),

    &quot;remove_watchlists&quot;: (&quot;&quot;&quot;sysRemoveWatchlist&quot;&quot;&quot;, &quot;&quot;&quot;{&quot;ids&quot;: {&quot;watchlistIdList&quot;: [&quot;%(wl_id_list)s&quot;]}}&quot;&quot;&quot;),

    &quot;get_alert_data&quot;: (&quot;&quot;&quot;ipsGetAlertData&quot;&quot;&quot;, &quot;&quot;&quot;{&quot;id&quot;: {&quot;value&quot;:&quot;%(id)s&quot;}}&quot;&quot;&quot;),

    &quot;get_sys_info&quot;  : (&quot;SYS_GETSYSINFO&quot;,&quot;&quot;&quot;{}&quot;&quot;&quot;),

    &quot;build_stamp&quot; : (&quot;essmgtGetBuildStamp&quot;,None),

    &quot;event_query&quot; : (&quot;&quot;&quot;qryExecuteDetail?type=EVENT&amp;reverse=false&quot;&quot;&quot;, &quot;&quot;&quot;{
                &quot;config&quot;: {
                    &quot;timeRange&quot;:&quot;%(time_range)s&quot;,
                    &quot;fields&quot;:%(fields)s,
                    &quot;filters&quot;:%(filters)s,
                    &quot;limit&quot;:%(limit)s,
                    &quot;offset&quot;:%(offset)s,
                    &quot;order&quot;: [{&quot;field&quot;: {&quot;name&quot;: &quot;%(order_field)s&quot;}, &quot;direction&quot;: &quot;%(order_direction)s&quot;}]
                    }}&quot;&quot;&quot;),

    [...]
}
</code></pre>
<p>Please see <code>dump_api_params.py</code> script at <a href="https://github.com/mfesiem/msiempy/blob/master/samples/dump_api_params.py">https://github.com/mfesiem/msiempy/blob/master/samples/dump_api_params.py</a> to dump the complete structure.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="msiempy.core.session.NitroSession"><code class="flex name class">
<span>class <span class="ident">NitroSession</span></span>
<span>(</span><span>conf_path=None, conf_dict=None)</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="msiempy.core.session.NitroSession" href="#msiempy.core.session.NitroSession">NitroSession</a></code> is the point of convergence of every requests that goes to the ESM.<br>
It provides easier dialogue with the ESM by doing agument interpolation with <code>msiempy.core.params.PARAMS</code>.
</p>
<p>It uses <code><a title="msiempy.core.config.NitroConfig" href="config.html#msiempy.core.config.NitroConfig">NitroConfig</a></code> to setup authentication, other configuration like verbosity, logfile, general timeout, are offered throught the config file.</p>
<p>The init method is called every time you call NitroSession() constructor. But the properties are actually initiated only once.
</p>
<p>Arguments:
</p>
<ul>
<li><code>conf_path</code> : Configuration file path.
</li>
<li><code>conf_dict</code> : Manual config dict. ex: <code>{'general':{'verbose':True}}</code>. See <code><a title="msiempy.core.config.NitroConfig" href="config.html#msiempy.core.config.NitroConfig">NitroConfig</a></code> class to have full details.</li>
</ul>
<p>See <code><a title="msiempy.core.session.NitroSession.esm_request" href="#msiempy.core.session.NitroSession.esm_request">NitroSession.esm_request()</a></code> and <code><a title="msiempy.core.session.NitroSession.request" href="#msiempy.core.session.NitroSession.request">NitroSession.request()</a></code> for usage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NitroSession():
    &#34;&#34;&#34;
    `msiempy.core.session.NitroSession` is the point of convergence of every requests that goes to the ESM.  
    It provides easier dialogue with the ESM by doing agument interpolation with `msiempy.core.params.PARAMS`.  

    It uses `msiempy.core.config.NitroConfig` to setup authentication, other configuration like verbosity, logfile, general timeout, are offered throught the config file.

    The init method is called every time you call NitroSession() constructor. But the properties are actually initiated only once.  

    Arguments:  

    - `conf_path` : Configuration file path.  
    - `conf_dict` : Manual config dict. ex: `{&#39;general&#39;:{&#39;verbose&#39;:True}}`. See `msiempy.core.config.NitroConfig` class to have full details.

    See `msiempy.core.session.NitroSession.esm_request` and `msiempy.core.session.NitroSession.request` for usage.  

    &#34;&#34;&#34;
    def __init__(self, conf_path=None, conf_dict=None):
        # global log
        self.__dict__ = NitroSession.__unique_state__
        
        #Init properties only once
        if NitroSession.__initiated__ == False :
            NitroSession.__initiated__ = True
            
            #Private attributes
            self._headers={&#39;Content-Type&#39;: &#39;application/json&#39;}
            
            #Config parsing
            self.config = NitroConfig(path=conf_path, config=conf_dict)
            NitroSession.config=self.config

            #Set the logging configuration
            self._init_log(verbose=self.config.verbose,
                quiet=self.config.quiet,
                logfile=self.config.logfile)

            self.api_v = 0
            self.logged_in=False
            self.login_info=dict()

            try :
                requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)
                urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
            except : 
                pass
            # logging.getLogger(&#34;urllib3&#34;).setLevel(logging.ERROR)

    BASE_URL = &#39;https://{}/rs/esm/&#39;
    &#34;&#34;&#34;API v2 base url: &#39;https://{}/rs/esm/&#39;&#34;&#34;&#34;

    BASE_URL_PRIV = &#39;https://{}/ess/&#39;
    &#34;&#34;&#34;Private API base URL: &#39;https://{}/ess/&#39;&#34;&#34;&#34;

    __initiated__ = False
    &#34;&#34;&#34;
    Weither the session has been intaciated. It&#39;s supposed to be a singleton.
    &#34;&#34;&#34;
    __unique_state__ = {}
    &#34;&#34;&#34;
    The singleton unique state.
    &#34;&#34;&#34;
    
    config = None
    &#34;&#34;&#34;
    `msiempy.core.config.NitroConfig` object.  
    &#34;&#34;&#34;
    
    PARAMS = PARAMS
        
    def __str__(self):
        return repr(self.__unique_state__) 

    def login(self, retry=1):
        &#34;&#34;&#34;Authentication is done lazily upon the first call to `msiempy.core.session.NitroSession.request` method, but you can still do it manually by calling this method.  
        Throws `msiempy.NitroError` if login fails.  
        &#34;&#34;&#34;
        userb64 = tob64(self.config.user)
        passb64 = self.config.passwd
        
        resp = self.request(&#39;login&#39;, username=userb64, password=passb64, raw=True, secure=True)
        
        if resp != None :
            try:
                resp.raise_for_status()
            except requests.HTTPError as e :
                if retry&gt;0:
                    time.sleep(1)
                    return self.login(retry=retry-1)
                else:
                    raise NitroError(&#39;ESM Login Error: &#39;, resp.text) from e
       
            self._headers[&#39;Cookie&#39;] = resp.headers.get(&#39;Set-Cookie&#39;)
            self._headers[&#39;X-Xsrf-Token&#39;] = resp.headers.get(&#39;Xsrf-Token&#39;)
            
            self.user_tz_id = dict(resp.json())[&#39;tzId&#39;]
            self.logged_in = True
            self.login_info=self.unpack_resp(resp)

            # Shorthanding the API version check 
            # 1 for pre 11.2.1, 2 for 11.2.1 and later
            # Not be confused with the ESM API v1 and v2 which are different.
            if str(self.version).startswith((&#39;9&#39;, &#39;10&#39;, &#39;11.0&#39;, &#39;11.1&#39;)):
                self.api_v = 1
            else:
                self.api_v = 2

            log.info(&#39;Logged into ESM {} with username {}. Last login {}&#39;.format(
                str(self.config.host),
                self.login_info[&#39;userName&#39;],
                self.login_info[&#39;lastLoginDate&#39;]))

            return True
        else:
            raise NitroError(&#39;ESM Login Error: Response empty&#39;)

    def logout(self):
        &#34;&#34;&#34; 
        This method will logout the session.
        &#34;&#34;&#34;
        self.api_v = 0
        self.request(&#39;logout&#39;, http=&#39;delete&#39;)
        self.logged_in=False
        self.login_info=dict()
        self._headers={&#39;Content-Type&#39;: &#39;application/json&#39;}
        self.user_tz_id = None

    def esm_request(self, method, data, http=&#39;post&#39;, callback=None, raw=False, secure=False, retry=1):
        &#34;&#34;&#34;
        Handle a lower level HTTP request to ESM API endpoints.  

        Format the request, handle the basic parsing of the SIEM result as well as other errors.  

        All upper cases method names signals to use the private API methods. 
        See `msiempy.core.session.NitroSession.format_priv_resp` and `msiempy.core.session.NitroSession.format_params`

        ESM responses are unpacked with `msiempy.core.session.NitroSession.unpack_resp`.  

        Arguments :  

        - `method` : ESM API enpoint name and url formatted parameters  
        - `http`: HTTP method.  
        - `data` : dict data to send  
        - `callback` : function to apply afterwards  
        - `raw` : If true will return the Response object from requests module. No retry when raw=True.     
        - `secure` : If true will not log the content of the request.   
        - `retry` : Number of time the request can be retried  

        Returns : 

        - a `dict`, `list` or `str` object. 
        - the `resquest.Response` object if raw=True  
        - `None` if Timeout or TooManyRedirects if raw=False  

        Raises:

        - `msiempy.core.session.NitroError` if any `HTTPError`

        Note : Private API is under /ess/ and public api is under /rs/esm  

        Exemple call:

            from msiempy import NitroSession
            s = NitroSession()
            s.login()
            # qryGetFilterFields 
            s.esm_request(&#39;qryGetFilterFields&#39;)
            # Get all last 24h alarms details with ESM API v2.  
            alarms = s.esm_request(&#39;v2/alarmGetTriggeredAlarms?triggeredTimeRange=LAST_24_HOURS&amp;status=&amp;pageSize=500&amp;pageNumber=1&#39;, None)
            for a in alarms:
                a.update(s.esm_request(&#39;v2/notifyGetTriggeredNotificationDetail&#39;, {&#39;id&#39;:a[&#39;id&#39;]}))

        &#34;&#34;&#34;

        url=str()
        privateApiCall=False
        result=None

        #Logging the data request if not secure | Logs anyway the method
        log.debug(&#39;Requesting HTTP &#39;+str(http)+&#39; &#39;+ str(method) + 
            (&#39; with data &#39;+str(data) if not secure else &#39; ***&#39;) )
        
        http_data=str()

        #Handling private API calls formatting
        if method == method.upper():
            privateApiCall=True
            url = self.BASE_URL_PRIV
            http_data = self.format_params(method, **data)
            log.debug(&#39;Private API call : &#39;+str(method)+&#39; Formatted params : &#39;+str(http_data))
        
        #Normal API calls
        else:
            url = self.BASE_URL
            if data :
                http_data = json.dumps(data)

        try :
            result = requests.request(
                http,
                urllib.parse.urljoin(url.format(self.config.host), method),
                data=http_data, 
                headers=self._headers,
                verify=self.config.ssl_verify,
                timeout=self.config.timeout,
                # Uncomment for debugging.
                # proxies={&#34;http&#34;: &#34;http://127.0.0.1:8888&#34;, &#34;https&#34;:&#34;http:127.0.0.1:8888&#34;}
            )

            if raw :
                log.debug(&#39;Returning raw requests Response object : &#39;+str(result))
                return result

            else:
                try:
                    result.raise_for_status()

                except requests.HTTPError as e :
                    error=None

                    if retry&gt;0 :
                        # Invalid session handler -&gt; re-login
                        if any([match in result.text for match in [&#39;ERROR_InvalidSession&#39;, &#39;ERROR_INVALID_SESSION&#39;,
                            &#39;Not Authorized User&#39;, &#39;Invalid Session&#39;, &#39;Username and password cannot be null&#39;]]):
                            error = NitroError(&#39;Authentication error with method ({}) and data : {} logging in and retrying esm_request(). From requests.HTTPError {} {}&#39;.format(
                                method, data, e, result.text))
                            log.warning(error)
                            self.logged_in=False
                            self.login()
                        
                        else: log.warning(&#39;An HTTP error occured ({} {}), retrying esm_request()&#39;.format(e, result.text))
                        
                        # Retry request
                        time.sleep(1)
                        return self.esm_request(method, data, http, callback, raw, secure, retry=retry-1)
                    
                    else :
                        error = NitroError(&#39;Error with method ({}) and data : {}. From requests.HTTPError {} {}&#39;.format(
                            method, data, e, result.text))
                        log.error(error)
                        raise error from e

                else: # The result is not an HTTP Error
                    response = result
                    result = self.unpack_resp(result)

                    if privateApiCall :
                        result = self.format_priv_resp(result)

                    if callback:
                        result = callback(result)

                    log.debug(&#39;{} -&gt; Result ({}): {}&#39;.format(
                        str(response),
                        type(result),
                        str(result)[:200] + &#39;[...]&#39; if len(str(result))&gt;200 else &#39;&#39;
                    ))

                    return result

        #Hard errors, could retry
        except requests.exceptions.Timeout as e:
            log.error(e)
            raise
        except requests.exceptions.TooManyRedirects as e :
            log.error(e)
            raise
        
    # def _request_http_error_handler(self, error, method, data, http, callback, raw, secure, retry):
    #     pass

    def version(self):
        &#34;&#34;&#34;
        Returns: `str` ESM short version.  
        Example: &#39;10.0.2&#39;
        &#34;&#34;&#34;
        return self.buildstamp().split()[0]

    def buildstamp(self):
        &#34;&#34;&#34;
        Returns: `str` ESM buildstamp.  
        Example: &#39;10.0.2 20170516001031&#39;
        &#34;&#34;&#34;
        return self.request(&#39;build_stamp&#39;)[&#39;buildStamp&#39;]

    def get_internal_file(self, file_token):
        &#34;&#34;&#34;Uses the private API to retrieve, assemble and delete a temp file from the ESM.
        
        Arguments:  

        - `file_token` (`str`): File token ID
        &#34;&#34;&#34;
        pos = 0
        nbytes = 0
        resp = self.request(&#39;get_rfile2&#39;, ftoken=file_token, pos=pos, nbytes=nbytes)

        if resp[&#39;FSIZE&#39;] == resp[&#39;BREAD&#39;]:
            data = resp[&#39;DATA&#39;]
            self.request(&#39;del_rfile&#39;, ftoken=file_token)
            return data
        
        data = []
        data.append(resp[&#39;DATA&#39;])
        file_size = int(resp[&#39;FSIZE&#39;])
        collected = int(resp[&#39;BREAD&#39;])

        while file_size &gt; collected:
            pos += int(resp[&#39;BREAD&#39;])
            nbytes = file_size - collected
            resp = self.request(&#39;get_rfile2&#39;, ftoken=file_token, pos=pos, nbytes=nbytes)
            collected += int(resp[&#39;BREAD&#39;])
            data.append(resp[&#39;DATA&#39;])

        resp = self.request(&#39;del_rfile&#39;, ftoken=file_token)
        return &#39;&#39;.join(data)

    def request(self, request, **kwargs):
        &#34;&#34;&#34;
        Interface to make ESM API calls more simple by interpolating `**kwargs` arguments with `msiempy.core.params.PARAMS` docstrings and build a valid datastructure for the HTTP data.  

        Then call the `msiempy.core.session.NitroSession.esm_request` method with the built data.  

        Also handles auto-login.  

        Arguments:  

        - `request`: Keyword corresponding to the request name in `msiempy.core.params.PARAMS` mapping.  
        - `http`: HTTP method.  
        - `callback` : function to apply afterwards  
        - `raw` : If true will return the Response object from requests module.   
        - `secure` : If true will not log the content of the request.   
        - `retry` : Number of time the request can be retried
        
        Interpolation parameters :  
        
        - `**kwargs` : Interpolation parameters that will be match to `msiempy.core.params.PARAMS` templates. Dynamic keyword arguments.  

        Returns :  

        - a `dict`, `list` or `str` object  
        - the `resquest.Response` object if raw=True  
        - `result.text` if `requests.HTTPError`,   
        - `None` if Timeout or TooManyRedirects if raw=False  

        Exemple call:

            from msiempy import NitroSession
            s = NitroSession()
            s.login()
            # Get all last 24h alarms details
            alarms = s.request(&#39;get_alarms&#39;, time_range=&#39;LAST_24_HOURS&#39;,  status=&#39;&#39;, page_size=500, page_number=0)
            for a in alarms:
                a.update(s.request(&#39;get_alarm_details_new&#39;, id=a[&#39;id&#39;]))


        &#34;&#34;&#34;
        log.debug(&#34;Calling nitro request : {} kwargs={}&#34;.format(
            str(request), &#39;***&#39; if &#39;secure&#39; in kwargs and kwargs[&#39;secure&#39;]==True else str(kwargs)))

        method, data = self.PARAMS.get(request)

        if data != None :
            data =  data % kwargs
            data = ast.literal_eval((data.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\t&#39;,&#39;&#39;)))
           
        if method != None:
            try :
                method = method % kwargs
            except TypeError as err :
                if (&#39;must be real number, not dict&#39; in str(err)):
                    log.warning(&#34;Interpolation failed probably because of the private API calls formatting... Unexpected behaviours can happend.&#34;)

        if not self.logged_in and method != &#39;login&#39;:
            # Autologin
            self.login()
    
        # Dynamically checking the esm_request arguments so additionnal parameters can be passed.  
        esm_request_args = inspect.getfullargspec(self.esm_request)[0]
        params={}
        for arg in kwargs :
            if arg in esm_request_args:
                params[arg]=kwargs[arg]
        return self.esm_request(method=method, data=data, **params)

    @staticmethod
    def _init_log(verbose=False, quiet=False, logfile=None):
        &#34;&#34;&#34;
        Private method. Inits the session&#39;s logger settings based on params
        All objects should be able to log stuff, so the logger is globaly accessible
        &#34;&#34;&#34;

        log.setLevel(logging.DEBUG)

        std = logging.StreamHandler()
        std.setLevel(logging.DEBUG)
        std.setFormatter(logging.Formatter(&#39;%(levelname)s - %(message)s&#39;))

        if verbose :
            std.setLevel(logging.DEBUG)
        elif quiet :
            std.setLevel(logging.CRITICAL)
        else :
            std.setLevel(logging.INFO)

        log.handlers=[]
        
        log.addHandler(std)

        if logfile :
            fh = logging.FileHandler(logfile)
            fh.setLevel(logging.DEBUG)
            fh.setFormatter(logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(message)s&#39;))
            log.addHandler(fh)

        if verbose and quiet :
            log.warning(&#34;Verbose and quiet values are both set to True. By default, output will be verbose.&#34;)

        return (log)

    @staticmethod
    def format_params(cmd, **params):
        &#34;&#34;&#34;
        Format private API call.  
        &#34;&#34;&#34;
        params = {k: v for k, v in params.items() if v != None}
        params = &#39;%14&#39;.join([k + &#39;%13&#39; + v + &#39;%13&#39; for (k, v) in params.items()])
        
        if params:
            params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39; + params + &#39;%14&#39;
        else:
            params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39;
        return params

    @staticmethod
    def format_priv_resp(resp):
        &#34;&#34;&#34;
        Format response from private API.  
        &#34;&#34;&#34;
        resp = re.search(&#39;Response=(.*)&#39;, resp).group(1)
        resp = resp.replace(&#39;%14&#39;, &#39; &#39;)
        pairs = resp.split()
        formatted = {}
        for pair in pairs:
            pair = pair.replace(&#39;%13&#39;, &#39; &#39;)
            pair = pair.split()
            key = pair[0]
            if key == &#39;ITEMS&#39;:
                value = pair[-1]
            else:
                value = urllib.parse.unquote(pair[-1])
            formatted[key] = value
        return formatted

    @staticmethod
    def unpack_resp(response) :
        &#34;&#34;&#34;Unpack data from response.  
        Should not be necessary with API v2.  
        Args: 
            response: requests.Response response object
        Returns a list, a dict or a string
        &#34;&#34;&#34;
        try :
            data = response.json()
            if isinstance(response.json(), dict):
                try:
                    data = data[&#39;value&#39;]
                except KeyError:
                    try:
                        data = data[&#39;return&#39;]
                    except KeyError:
                        pass
            
        except ValueError :
            data = response.text

        return data</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.core.session.NitroSession.BASE_URL"><code class="name">var <span class="ident">BASE_URL</span></code></dt>
<dd>
<div class="desc"><p>API v2 base url: 'https://{}/rs/esm/'</p></div>
</dd>
<dt id="msiempy.core.session.NitroSession.BASE_URL_PRIV"><code class="name">var <span class="ident">BASE_URL_PRIV</span></code></dt>
<dd>
<div class="desc"><p>Private API base URL: 'https://{}/ess/'</p></div>
</dd>
<dt id="msiempy.core.session.NitroSession.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"><p><code><a title="msiempy.core.config.NitroConfig" href="config.html#msiempy.core.config.NitroConfig">NitroConfig</a></code> object.</p></div>
</dd>
<dt id="msiempy.core.session.NitroSession.PARAMS"><code class="name">var <span class="ident">PARAMS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="msiempy.core.session.NitroSession.format_params"><code class="name flex">
<span>def <span class="ident">format_params</span></span>(<span>cmd, **params)</span>
</code></dt>
<dd>
<div class="desc"><p>Format private API call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def format_params(cmd, **params):
    &#34;&#34;&#34;
    Format private API call.  
    &#34;&#34;&#34;
    params = {k: v for k, v in params.items() if v != None}
    params = &#39;%14&#39;.join([k + &#39;%13&#39; + v + &#39;%13&#39; for (k, v) in params.items()])
    
    if params:
        params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39; + params + &#39;%14&#39;
    else:
        params = &#39;Request=API%13&#39; + cmd + &#39;%13%14&#39;
    return params</code></pre>
</details>
</dd>
<dt id="msiempy.core.session.NitroSession.format_priv_resp"><code class="name flex">
<span>def <span class="ident">format_priv_resp</span></span>(<span>resp)</span>
</code></dt>
<dd>
<div class="desc"><p>Format response from private API.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def format_priv_resp(resp):
    &#34;&#34;&#34;
    Format response from private API.  
    &#34;&#34;&#34;
    resp = re.search(&#39;Response=(.*)&#39;, resp).group(1)
    resp = resp.replace(&#39;%14&#39;, &#39; &#39;)
    pairs = resp.split()
    formatted = {}
    for pair in pairs:
        pair = pair.replace(&#39;%13&#39;, &#39; &#39;)
        pair = pair.split()
        key = pair[0]
        if key == &#39;ITEMS&#39;:
            value = pair[-1]
        else:
            value = urllib.parse.unquote(pair[-1])
        formatted[key] = value
    return formatted</code></pre>
</details>
</dd>
<dt id="msiempy.core.session.NitroSession.unpack_resp"><code class="name flex">
<span>def <span class="ident">unpack_resp</span></span>(<span>response)</span>
</code></dt>
<dd>
<div class="desc"><p>Unpack data from response.<br>
Should not be necessary with API v2.<br>
Args:
response: requests.Response response object
Returns a list, a dict or a string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def unpack_resp(response) :
    &#34;&#34;&#34;Unpack data from response.  
    Should not be necessary with API v2.  
    Args: 
        response: requests.Response response object
    Returns a list, a dict or a string
    &#34;&#34;&#34;
    try :
        data = response.json()
        if isinstance(response.json(), dict):
            try:
                data = data[&#39;value&#39;]
            except KeyError:
                try:
                    data = data[&#39;return&#39;]
                except KeyError:
                    pass
        
    except ValueError :
        data = response.text

    return data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.core.session.NitroSession.login"><code class="name flex">
<span>def <span class="ident">login</span></span>(<span>self, retry=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Authentication is done lazily upon the first call to <code><a title="msiempy.core.session.NitroSession.request" href="#msiempy.core.session.NitroSession.request">NitroSession.request()</a></code> method, but you can still do it manually by calling this method.<br>
Throws <code>msiempy.NitroError</code> if login fails.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def login(self, retry=1):
    &#34;&#34;&#34;Authentication is done lazily upon the first call to `msiempy.core.session.NitroSession.request` method, but you can still do it manually by calling this method.  
    Throws `msiempy.NitroError` if login fails.  
    &#34;&#34;&#34;
    userb64 = tob64(self.config.user)
    passb64 = self.config.passwd
    
    resp = self.request(&#39;login&#39;, username=userb64, password=passb64, raw=True, secure=True)
    
    if resp != None :
        try:
            resp.raise_for_status()
        except requests.HTTPError as e :
            if retry&gt;0:
                time.sleep(1)
                return self.login(retry=retry-1)
            else:
                raise NitroError(&#39;ESM Login Error: &#39;, resp.text) from e
   
        self._headers[&#39;Cookie&#39;] = resp.headers.get(&#39;Set-Cookie&#39;)
        self._headers[&#39;X-Xsrf-Token&#39;] = resp.headers.get(&#39;Xsrf-Token&#39;)
        
        self.user_tz_id = dict(resp.json())[&#39;tzId&#39;]
        self.logged_in = True
        self.login_info=self.unpack_resp(resp)

        # Shorthanding the API version check 
        # 1 for pre 11.2.1, 2 for 11.2.1 and later
        # Not be confused with the ESM API v1 and v2 which are different.
        if str(self.version).startswith((&#39;9&#39;, &#39;10&#39;, &#39;11.0&#39;, &#39;11.1&#39;)):
            self.api_v = 1
        else:
            self.api_v = 2

        log.info(&#39;Logged into ESM {} with username {}. Last login {}&#39;.format(
            str(self.config.host),
            self.login_info[&#39;userName&#39;],
            self.login_info[&#39;lastLoginDate&#39;]))

        return True
    else:
        raise NitroError(&#39;ESM Login Error: Response empty&#39;)</code></pre>
</details>
</dd>
<dt id="msiempy.core.session.NitroSession.logout"><code class="name flex">
<span>def <span class="ident">logout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method will logout the session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logout(self):
    &#34;&#34;&#34; 
    This method will logout the session.
    &#34;&#34;&#34;
    self.api_v = 0
    self.request(&#39;logout&#39;, http=&#39;delete&#39;)
    self.logged_in=False
    self.login_info=dict()
    self._headers={&#39;Content-Type&#39;: &#39;application/json&#39;}
    self.user_tz_id = None</code></pre>
</details>
</dd>
<dt id="msiempy.core.session.NitroSession.esm_request"><code class="name flex">
<span>def <span class="ident">esm_request</span></span>(<span>self, method, data, http='post', callback=None, raw=False, secure=False, retry=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle a lower level HTTP request to ESM API endpoints.
</p>
<p>Format the request, handle the basic parsing of the SIEM result as well as other errors.
</p>
<p>All upper cases method names signals to use the private API methods.
See <code><a title="msiempy.core.session.NitroSession.format_priv_resp" href="#msiempy.core.session.NitroSession.format_priv_resp">NitroSession.format_priv_resp()</a></code> and <code><a title="msiempy.core.session.NitroSession.format_params" href="#msiempy.core.session.NitroSession.format_params">NitroSession.format_params()</a></code></p>
<p>ESM responses are unpacked with <code><a title="msiempy.core.session.NitroSession.unpack_resp" href="#msiempy.core.session.NitroSession.unpack_resp">NitroSession.unpack_resp()</a></code>.
</p>
<p>Arguments :
</p>
<ul>
<li><code>method</code> : ESM API enpoint name and url formatted parameters
</li>
<li><code>http</code>: HTTP method.
</li>
<li><code>data</code> : dict data to send
</li>
<li><code>callback</code> : function to apply afterwards
</li>
<li><code>raw</code> : If true will return the Response object from requests module. No retry when raw=True.
</li>
<li><code>secure</code> : If true will not log the content of the request.
</li>
<li><code>retry</code> : Number of time the request can be retried
</li>
</ul>
<p>Returns : </p>
<ul>
<li>a <code>dict</code>, <code>list</code> or <code>str</code> object. </li>
<li>the <code>resquest.Response</code> object if raw=True
</li>
<li><code>None</code> if Timeout or TooManyRedirects if raw=False
</li>
</ul>
<p>Raises:</p>
<ul>
<li><code><a title="msiempy.core.session.NitroError" href="#msiempy.core.session.NitroError">NitroError</a></code> if any <code>HTTPError</code></li>
</ul>
<p>Note : Private API is under /ess/ and public api is under /rs/esm
</p>
<p>Exemple call:</p>
<pre><code>from msiempy import NitroSession
s = NitroSession()
s.login()
# qryGetFilterFields 
s.esm_request('qryGetFilterFields')
# Get all last 24h alarms details with ESM API v2.  
alarms = s.esm_request('v2/alarmGetTriggeredAlarms?triggeredTimeRange=LAST_24_HOURS&amp;status=&amp;pageSize=500&amp;pageNumber=1', None)
for a in alarms:
    a.update(s.esm_request('v2/notifyGetTriggeredNotificationDetail', {'id':a['id']}))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esm_request(self, method, data, http=&#39;post&#39;, callback=None, raw=False, secure=False, retry=1):
    &#34;&#34;&#34;
    Handle a lower level HTTP request to ESM API endpoints.  

    Format the request, handle the basic parsing of the SIEM result as well as other errors.  

    All upper cases method names signals to use the private API methods. 
    See `msiempy.core.session.NitroSession.format_priv_resp` and `msiempy.core.session.NitroSession.format_params`

    ESM responses are unpacked with `msiempy.core.session.NitroSession.unpack_resp`.  

    Arguments :  

    - `method` : ESM API enpoint name and url formatted parameters  
    - `http`: HTTP method.  
    - `data` : dict data to send  
    - `callback` : function to apply afterwards  
    - `raw` : If true will return the Response object from requests module. No retry when raw=True.     
    - `secure` : If true will not log the content of the request.   
    - `retry` : Number of time the request can be retried  

    Returns : 

    - a `dict`, `list` or `str` object. 
    - the `resquest.Response` object if raw=True  
    - `None` if Timeout or TooManyRedirects if raw=False  

    Raises:

    - `msiempy.core.session.NitroError` if any `HTTPError`

    Note : Private API is under /ess/ and public api is under /rs/esm  

    Exemple call:

        from msiempy import NitroSession
        s = NitroSession()
        s.login()
        # qryGetFilterFields 
        s.esm_request(&#39;qryGetFilterFields&#39;)
        # Get all last 24h alarms details with ESM API v2.  
        alarms = s.esm_request(&#39;v2/alarmGetTriggeredAlarms?triggeredTimeRange=LAST_24_HOURS&amp;status=&amp;pageSize=500&amp;pageNumber=1&#39;, None)
        for a in alarms:
            a.update(s.esm_request(&#39;v2/notifyGetTriggeredNotificationDetail&#39;, {&#39;id&#39;:a[&#39;id&#39;]}))

    &#34;&#34;&#34;

    url=str()
    privateApiCall=False
    result=None

    #Logging the data request if not secure | Logs anyway the method
    log.debug(&#39;Requesting HTTP &#39;+str(http)+&#39; &#39;+ str(method) + 
        (&#39; with data &#39;+str(data) if not secure else &#39; ***&#39;) )
    
    http_data=str()

    #Handling private API calls formatting
    if method == method.upper():
        privateApiCall=True
        url = self.BASE_URL_PRIV
        http_data = self.format_params(method, **data)
        log.debug(&#39;Private API call : &#39;+str(method)+&#39; Formatted params : &#39;+str(http_data))
    
    #Normal API calls
    else:
        url = self.BASE_URL
        if data :
            http_data = json.dumps(data)

    try :
        result = requests.request(
            http,
            urllib.parse.urljoin(url.format(self.config.host), method),
            data=http_data, 
            headers=self._headers,
            verify=self.config.ssl_verify,
            timeout=self.config.timeout,
            # Uncomment for debugging.
            # proxies={&#34;http&#34;: &#34;http://127.0.0.1:8888&#34;, &#34;https&#34;:&#34;http:127.0.0.1:8888&#34;}
        )

        if raw :
            log.debug(&#39;Returning raw requests Response object : &#39;+str(result))
            return result

        else:
            try:
                result.raise_for_status()

            except requests.HTTPError as e :
                error=None

                if retry&gt;0 :
                    # Invalid session handler -&gt; re-login
                    if any([match in result.text for match in [&#39;ERROR_InvalidSession&#39;, &#39;ERROR_INVALID_SESSION&#39;,
                        &#39;Not Authorized User&#39;, &#39;Invalid Session&#39;, &#39;Username and password cannot be null&#39;]]):
                        error = NitroError(&#39;Authentication error with method ({}) and data : {} logging in and retrying esm_request(). From requests.HTTPError {} {}&#39;.format(
                            method, data, e, result.text))
                        log.warning(error)
                        self.logged_in=False
                        self.login()
                    
                    else: log.warning(&#39;An HTTP error occured ({} {}), retrying esm_request()&#39;.format(e, result.text))
                    
                    # Retry request
                    time.sleep(1)
                    return self.esm_request(method, data, http, callback, raw, secure, retry=retry-1)
                
                else :
                    error = NitroError(&#39;Error with method ({}) and data : {}. From requests.HTTPError {} {}&#39;.format(
                        method, data, e, result.text))
                    log.error(error)
                    raise error from e

            else: # The result is not an HTTP Error
                response = result
                result = self.unpack_resp(result)

                if privateApiCall :
                    result = self.format_priv_resp(result)

                if callback:
                    result = callback(result)

                log.debug(&#39;{} -&gt; Result ({}): {}&#39;.format(
                    str(response),
                    type(result),
                    str(result)[:200] + &#39;[...]&#39; if len(str(result))&gt;200 else &#39;&#39;
                ))

                return result

    #Hard errors, could retry
    except requests.exceptions.Timeout as e:
        log.error(e)
        raise
    except requests.exceptions.TooManyRedirects as e :
        log.error(e)
        raise</code></pre>
</details>
</dd>
<dt id="msiempy.core.session.NitroSession.version"><code class="name flex">
<span>def <span class="ident">version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns: <code>str</code> ESM short version.<br>
Example: '10.0.2'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def version(self):
    &#34;&#34;&#34;
    Returns: `str` ESM short version.  
    Example: &#39;10.0.2&#39;
    &#34;&#34;&#34;
    return self.buildstamp().split()[0]</code></pre>
</details>
</dd>
<dt id="msiempy.core.session.NitroSession.buildstamp"><code class="name flex">
<span>def <span class="ident">buildstamp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns: <code>str</code> ESM buildstamp.<br>
Example: '10.0.2 20170516001031'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildstamp(self):
    &#34;&#34;&#34;
    Returns: `str` ESM buildstamp.  
    Example: &#39;10.0.2 20170516001031&#39;
    &#34;&#34;&#34;
    return self.request(&#39;build_stamp&#39;)[&#39;buildStamp&#39;]</code></pre>
</details>
</dd>
<dt id="msiempy.core.session.NitroSession.get_internal_file"><code class="name flex">
<span>def <span class="ident">get_internal_file</span></span>(<span>self, file_token)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the private API to retrieve, assemble and delete a temp file from the ESM.</p>
<p>Arguments:
</p>
<ul>
<li><code>file_token</code> (<code>str</code>): File token ID</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_internal_file(self, file_token):
    &#34;&#34;&#34;Uses the private API to retrieve, assemble and delete a temp file from the ESM.
    
    Arguments:  

    - `file_token` (`str`): File token ID
    &#34;&#34;&#34;
    pos = 0
    nbytes = 0
    resp = self.request(&#39;get_rfile2&#39;, ftoken=file_token, pos=pos, nbytes=nbytes)

    if resp[&#39;FSIZE&#39;] == resp[&#39;BREAD&#39;]:
        data = resp[&#39;DATA&#39;]
        self.request(&#39;del_rfile&#39;, ftoken=file_token)
        return data
    
    data = []
    data.append(resp[&#39;DATA&#39;])
    file_size = int(resp[&#39;FSIZE&#39;])
    collected = int(resp[&#39;BREAD&#39;])

    while file_size &gt; collected:
        pos += int(resp[&#39;BREAD&#39;])
        nbytes = file_size - collected
        resp = self.request(&#39;get_rfile2&#39;, ftoken=file_token, pos=pos, nbytes=nbytes)
        collected += int(resp[&#39;BREAD&#39;])
        data.append(resp[&#39;DATA&#39;])

    resp = self.request(&#39;del_rfile&#39;, ftoken=file_token)
    return &#39;&#39;.join(data)</code></pre>
</details>
</dd>
<dt id="msiempy.core.session.NitroSession.request"><code class="name flex">
<span>def <span class="ident">request</span></span>(<span>self, request, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Interface to make ESM API calls more simple by interpolating <code>**kwargs</code> arguments with <code>msiempy.core.params.PARAMS</code> docstrings and build a valid datastructure for the HTTP data.
</p>
<p>Then call the <code><a title="msiempy.core.session.NitroSession.esm_request" href="#msiempy.core.session.NitroSession.esm_request">NitroSession.esm_request()</a></code> method with the built data.
</p>
<p>Also handles auto-login.
</p>
<p>Arguments:
</p>
<ul>
<li><code>request</code>: Keyword corresponding to the request name in <code>msiempy.core.params.PARAMS</code> mapping.
</li>
<li><code>http</code>: HTTP method.
</li>
<li><code>callback</code> : function to apply afterwards
</li>
<li><code>raw</code> : If true will return the Response object from requests module.
</li>
<li><code>secure</code> : If true will not log the content of the request.
</li>
<li><code>retry</code> : Number of time the request can be retried</li>
</ul>
<p>Interpolation parameters :
</p>
<ul>
<li><code>**kwargs</code> : Interpolation parameters that will be match to <code>msiempy.core.params.PARAMS</code> templates. Dynamic keyword arguments.
</li>
</ul>
<p>Returns :
</p>
<ul>
<li>a <code>dict</code>, <code>list</code> or <code>str</code> object
</li>
<li>the <code>resquest.Response</code> object if raw=True
</li>
<li><code>result.text</code> if <code>requests.HTTPError</code>,
</li>
<li><code>None</code> if Timeout or TooManyRedirects if raw=False
</li>
</ul>
<p>Exemple call:</p>
<pre><code>from msiempy import NitroSession
s = NitroSession()
s.login()
# Get all last 24h alarms details
alarms = s.request('get_alarms', time_range='LAST_24_HOURS',  status='', page_size=500, page_number=0)
for a in alarms:
    a.update(s.request('get_alarm_details_new', id=a['id']))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request(self, request, **kwargs):
    &#34;&#34;&#34;
    Interface to make ESM API calls more simple by interpolating `**kwargs` arguments with `msiempy.core.params.PARAMS` docstrings and build a valid datastructure for the HTTP data.  

    Then call the `msiempy.core.session.NitroSession.esm_request` method with the built data.  

    Also handles auto-login.  

    Arguments:  

    - `request`: Keyword corresponding to the request name in `msiempy.core.params.PARAMS` mapping.  
    - `http`: HTTP method.  
    - `callback` : function to apply afterwards  
    - `raw` : If true will return the Response object from requests module.   
    - `secure` : If true will not log the content of the request.   
    - `retry` : Number of time the request can be retried
    
    Interpolation parameters :  
    
    - `**kwargs` : Interpolation parameters that will be match to `msiempy.core.params.PARAMS` templates. Dynamic keyword arguments.  

    Returns :  

    - a `dict`, `list` or `str` object  
    - the `resquest.Response` object if raw=True  
    - `result.text` if `requests.HTTPError`,   
    - `None` if Timeout or TooManyRedirects if raw=False  

    Exemple call:

        from msiempy import NitroSession
        s = NitroSession()
        s.login()
        # Get all last 24h alarms details
        alarms = s.request(&#39;get_alarms&#39;, time_range=&#39;LAST_24_HOURS&#39;,  status=&#39;&#39;, page_size=500, page_number=0)
        for a in alarms:
            a.update(s.request(&#39;get_alarm_details_new&#39;, id=a[&#39;id&#39;]))


    &#34;&#34;&#34;
    log.debug(&#34;Calling nitro request : {} kwargs={}&#34;.format(
        str(request), &#39;***&#39; if &#39;secure&#39; in kwargs and kwargs[&#39;secure&#39;]==True else str(kwargs)))

    method, data = self.PARAMS.get(request)

    if data != None :
        data =  data % kwargs
        data = ast.literal_eval((data.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\t&#39;,&#39;&#39;)))
       
    if method != None:
        try :
            method = method % kwargs
        except TypeError as err :
            if (&#39;must be real number, not dict&#39; in str(err)):
                log.warning(&#34;Interpolation failed probably because of the private API calls formatting... Unexpected behaviours can happend.&#34;)

    if not self.logged_in and method != &#39;login&#39;:
        # Autologin
        self.login()

    # Dynamically checking the esm_request arguments so additionnal parameters can be passed.  
    esm_request_args = inspect.getfullargspec(self.esm_request)[0]
    params={}
    for arg in kwargs :
        if arg in esm_request_args:
            params[arg]=kwargs[arg]
    return self.esm_request(method=method, data=data, **params)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="msiempy.core.session.NitroError"><code class="flex name class">
<span>class <span class="ident">NitroError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Base ESM exception.<br>
It's used when the user/passwd is incorrect and other HTTP errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NitroError(Exception):
    &#34;&#34;&#34;
    Base ESM exception.  
    It&#39;s used when the user/passwd is incorrect and other HTTP errors.  
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="msiempy.core" href="index.html">msiempy.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="msiempy.core.session.PARAMS" href="#msiempy.core.session.PARAMS">PARAMS</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="msiempy.core.session.NitroSession" href="#msiempy.core.session.NitroSession">NitroSession</a></code></h4>
<ul class="two-column">
<li><code><a title="msiempy.core.session.NitroSession.format_params" href="#msiempy.core.session.NitroSession.format_params">format_params</a></code></li>
<li><code><a title="msiempy.core.session.NitroSession.format_priv_resp" href="#msiempy.core.session.NitroSession.format_priv_resp">format_priv_resp</a></code></li>
<li><code><a title="msiempy.core.session.NitroSession.unpack_resp" href="#msiempy.core.session.NitroSession.unpack_resp">unpack_resp</a></code></li>
<li><code><a title="msiempy.core.session.NitroSession.login" href="#msiempy.core.session.NitroSession.login">login</a></code></li>
<li><code><a title="msiempy.core.session.NitroSession.logout" href="#msiempy.core.session.NitroSession.logout">logout</a></code></li>
<li><code><a title="msiempy.core.session.NitroSession.esm_request" href="#msiempy.core.session.NitroSession.esm_request">esm_request</a></code></li>
<li><code><a title="msiempy.core.session.NitroSession.version" href="#msiempy.core.session.NitroSession.version">version</a></code></li>
<li><code><a title="msiempy.core.session.NitroSession.buildstamp" href="#msiempy.core.session.NitroSession.buildstamp">buildstamp</a></code></li>
<li><code><a title="msiempy.core.session.NitroSession.get_internal_file" href="#msiempy.core.session.NitroSession.get_internal_file">get_internal_file</a></code></li>
<li><code><a title="msiempy.core.session.NitroSession.request" href="#msiempy.core.session.NitroSession.request">request</a></code></li>
<li><code><a title="msiempy.core.session.NitroSession.BASE_URL" href="#msiempy.core.session.NitroSession.BASE_URL">BASE_URL</a></code></li>
<li><code><a title="msiempy.core.session.NitroSession.BASE_URL_PRIV" href="#msiempy.core.session.NitroSession.BASE_URL_PRIV">BASE_URL_PRIV</a></code></li>
<li><code><a title="msiempy.core.session.NitroSession.config" href="#msiempy.core.session.NitroSession.config">config</a></code></li>
<li><code><a title="msiempy.core.session.NitroSession.PARAMS" href="#msiempy.core.session.NitroSession.PARAMS">PARAMS</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.core.session.NitroError" href="#msiempy.core.session.NitroError">NitroError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>